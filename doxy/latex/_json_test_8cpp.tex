\section{lib/\+Json\+Parser\+Generator\+R\+K/test/\+Json\+Test.cpp File Reference}
\label{_json_test_8cpp}\index{lib/\+Json\+Parser\+Generator\+R\+K/test/\+Json\+Test.\+cpp@{lib/\+Json\+Parser\+Generator\+R\+K/test/\+Json\+Test.\+cpp}}
{\ttfamily \#include \char`\"{}Particle.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}Json\+Parser\+Generator\+R\+K.\+h\char`\"{}}\newline
Include dependency graph for Json\+Test.\+cpp\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_json_test_8cpp__incl}
\end{center}
\end{figure}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \textbf{ assert\+Json\+Parser\+Buffer}(jp,  expected)~\textbf{ \+\_\+assert\+Json\+Parser\+Buffer}(jp, expected, \+\_\+\+\_\+\+L\+I\+N\+E\+\_\+\+\_\+)
\item 
\#define \textbf{ assert\+Json\+Writer\+Buffer}(jw,  expected)~\textbf{ \+\_\+assert\+Json\+Writer\+Buffer}(jw, expected, \+\_\+\+\_\+\+L\+I\+N\+E\+\_\+\+\_\+)
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \textbf{ print\+Tokens} (\textbf{ Json\+Parser} \&jp)
\item 
void \textbf{ print\+Token} (\textbf{ Json\+Parser} \&jp, const \textbf{ Json\+Parser\+Generator\+R\+K\+::jsmntok\+\_\+t} $\ast$tok)
\item 
void \textbf{ print\+Json} (\textbf{ Json\+Parser} \&jp)
\item 
char $\ast$ \textbf{ read\+Test\+Data} (const char $\ast$filename)
\item 
void \textbf{ \+\_\+assert\+Json\+Parser\+Buffer} (\textbf{ Json\+Parser} \&jp, const char $\ast$expected, size\+\_\+t line)
\item 
void \textbf{ \+\_\+assert\+Json\+Writer\+Buffer} (\textbf{ Json\+Writer} \&jw, const char $\ast$expected, size\+\_\+t line)
\item 
int \textbf{ main} (int argc, char $\ast$argv[$\,$])
\item 
void \textbf{ print\+Indent} (size\+\_\+t indent)
\item 
void \textbf{ print\+String} (const char $\ast$str)
\item 
void \textbf{ print\+Json\+Inner} (\textbf{ Json\+Parser} \&jp, const \textbf{ Json\+Parser\+Generator\+R\+K\+::jsmntok\+\_\+t} $\ast$container, size\+\_\+t indent)
\end{DoxyCompactItemize}


\subsection{Macro Definition Documentation}
\mbox{\label{_json_test_8cpp_a59ef6dccb1baa8810627fc434b441fb8}} 
\index{Json\+Test.\+cpp@{Json\+Test.\+cpp}!assert\+Json\+Parser\+Buffer@{assert\+Json\+Parser\+Buffer}}
\index{assert\+Json\+Parser\+Buffer@{assert\+Json\+Parser\+Buffer}!Json\+Test.\+cpp@{Json\+Test.\+cpp}}
\subsubsection{assert\+Json\+Parser\+Buffer}
{\footnotesize\ttfamily \#define assert\+Json\+Parser\+Buffer(\begin{DoxyParamCaption}\item[{}]{jp,  }\item[{}]{expected }\end{DoxyParamCaption})~\textbf{ \+\_\+assert\+Json\+Parser\+Buffer}(jp, expected, \+\_\+\+\_\+\+L\+I\+N\+E\+\_\+\+\_\+)}



Definition at line 44 of file Json\+Test.\+cpp.

\mbox{\label{_json_test_8cpp_a576bc9d27a740d45bb60fe2bef06cf97}} 
\index{Json\+Test.\+cpp@{Json\+Test.\+cpp}!assert\+Json\+Writer\+Buffer@{assert\+Json\+Writer\+Buffer}}
\index{assert\+Json\+Writer\+Buffer@{assert\+Json\+Writer\+Buffer}!Json\+Test.\+cpp@{Json\+Test.\+cpp}}
\subsubsection{assert\+Json\+Writer\+Buffer}
{\footnotesize\ttfamily \#define assert\+Json\+Writer\+Buffer(\begin{DoxyParamCaption}\item[{}]{jw,  }\item[{}]{expected }\end{DoxyParamCaption})~\textbf{ \+\_\+assert\+Json\+Writer\+Buffer}(jw, expected, \+\_\+\+\_\+\+L\+I\+N\+E\+\_\+\+\_\+)}



Definition at line 61 of file Json\+Test.\+cpp.



\subsection{Function Documentation}
\mbox{\label{_json_test_8cpp_ab2f1136e7778215387f4a4a5f13834e4}} 
\index{Json\+Test.\+cpp@{Json\+Test.\+cpp}!\+\_\+assert\+Json\+Parser\+Buffer@{\+\_\+assert\+Json\+Parser\+Buffer}}
\index{\+\_\+assert\+Json\+Parser\+Buffer@{\+\_\+assert\+Json\+Parser\+Buffer}!Json\+Test.\+cpp@{Json\+Test.\+cpp}}
\subsubsection{\+\_\+assert\+Json\+Parser\+Buffer()}
{\footnotesize\ttfamily void \+\_\+assert\+Json\+Parser\+Buffer (\begin{DoxyParamCaption}\item[{\textbf{ Json\+Parser} \&}]{jp,  }\item[{const char $\ast$}]{expected,  }\item[{size\+\_\+t}]{line }\end{DoxyParamCaption})}



Definition at line 30 of file Json\+Test.\+cpp.



References Json\+Buffer\+::get\+Buffer(), and Json\+Buffer\+::get\+Offset().


\begin{DoxyCode}
30                                                                                 \{
31     \textcolor{keywordtype}{char} *actual = (\textcolor{keywordtype}{char} *) malloc(jp.getOffset() + 1);
32     strncpy(actual, jp.getBuffer(), jp.getOffset());
33     actual[jp.getOffset()] = 0;
34 
35     \textcolor{keywordtype}{size\_t} expectedLen = strlen(expected);
36     \textcolor{keywordflow}{if} (expectedLen != jp.getOffset() || strcmp(actual, expected) != 0) \{
37         printf(\textcolor{stringliteral}{"line %lu: expectedLen=%lu actualLen=%lu\(\backslash\)n"}, line, expectedLen, jp.
      getOffset());
38         printf(\textcolor{stringliteral}{"expected: %s\(\backslash\)n"}, expected);
39         printf(\textcolor{stringliteral}{"actual:   %s\(\backslash\)n"}, actual);
40         assert(\textcolor{keyword}{false});
41     \}
42     free(actual);
43 \}
\end{DoxyCode}
\mbox{\label{_json_test_8cpp_ab12b58ca94b4b5836ba4bdac65bfe105}} 
\index{Json\+Test.\+cpp@{Json\+Test.\+cpp}!\+\_\+assert\+Json\+Writer\+Buffer@{\+\_\+assert\+Json\+Writer\+Buffer}}
\index{\+\_\+assert\+Json\+Writer\+Buffer@{\+\_\+assert\+Json\+Writer\+Buffer}!Json\+Test.\+cpp@{Json\+Test.\+cpp}}
\subsubsection{\+\_\+assert\+Json\+Writer\+Buffer()}
{\footnotesize\ttfamily void \+\_\+assert\+Json\+Writer\+Buffer (\begin{DoxyParamCaption}\item[{\textbf{ Json\+Writer} \&}]{jw,  }\item[{const char $\ast$}]{expected,  }\item[{size\+\_\+t}]{line }\end{DoxyParamCaption})}



Definition at line 47 of file Json\+Test.\+cpp.



References Json\+Buffer\+::get\+Buffer(), and Json\+Buffer\+::get\+Offset().


\begin{DoxyCode}
47                                                                                 \{
48     \textcolor{keywordtype}{char} *actual = (\textcolor{keywordtype}{char} *) malloc(jw.getOffset() + 1);
49     strncpy(actual, jw.getBuffer(), jw.getOffset());
50     actual[jw.getOffset()] = 0;
51 
52     \textcolor{keywordtype}{size\_t} expectedLen = strlen(expected);
53     \textcolor{keywordflow}{if} (expectedLen != jw.getOffset() || strcmp(actual, expected) != 0) \{
54         printf(\textcolor{stringliteral}{"line %lu: expectedLen=%lu actualLen=%lu\(\backslash\)n"}, line, expectedLen, jw.
      getOffset());
55         printf(\textcolor{stringliteral}{"expected: %s\(\backslash\)n"}, expected);
56         printf(\textcolor{stringliteral}{"actual:   %s\(\backslash\)n"}, actual);
57         assert(\textcolor{keyword}{false});
58     \}
59     free(actual);
60 \}
\end{DoxyCode}
\mbox{\label{_json_test_8cpp_a0ddf1224851353fc92bfbff6f499fa97}} 
\index{Json\+Test.\+cpp@{Json\+Test.\+cpp}!main@{main}}
\index{main@{main}!Json\+Test.\+cpp@{Json\+Test.\+cpp}}
\subsubsection{main()}
{\footnotesize\ttfamily int main (\begin{DoxyParamCaption}\item[{int}]{argc,  }\item[{char $\ast$}]{argv[$\,$] }\end{DoxyParamCaption})}



Definition at line 65 of file Json\+Test.\+cpp.



References Json\+Buffer\+::add\+Data(), Json\+Buffer\+::add\+String(), Json\+Buffer\+::allocate(), Json\+Modifier\+::append\+Array\+Value(), Json\+Parser\+Generator\+R\+K\+::jsmntok\+\_\+t\+::end, Json\+Modifier\+::find\+Left\+Comma(), Json\+Modifier\+::find\+Right\+Comma(), Json\+Modifier\+::finish(), Json\+Writer\+::finish\+Object\+Or\+Array(), Json\+Parser\+::get\+Array\+Size(), Json\+Parser\+::get\+Key\+Value\+Token\+By\+Index(), Json\+Parser\+::get\+Outer\+Array(), Json\+Parser\+::get\+Outer\+Object(), Json\+Parser\+::get\+Outer\+Token(), Json\+Parser\+::get\+Outer\+Value\+By\+Key(), Json\+Parser\+::get\+Reference(), Json\+Parser\+::get\+Token\+By\+Index(), Json\+Parser\+::get\+Token\+Json\+String(), Json\+Parser\+::get\+Token\+Value(), Json\+Parser\+::get\+Value\+By\+Col\+Row(), Json\+Parser\+::get\+Value\+By\+Index(), Json\+Parser\+::get\+Value\+By\+Key(), Json\+Parser\+::get\+Value\+Token\+By\+Index(), Json\+Parser\+::get\+Value\+Token\+By\+Key(), Json\+Reference\+::index(), Json\+Writer\+::insert\+Array\+Value(), Json\+Writer\+::insert\+Check\+Separator(), Json\+Writer\+::insert\+Key\+Array(), Json\+Writer\+::insert\+Key\+Object(), Json\+Writer\+::insert\+Key\+Value(), Json\+Writer\+::insert\+Key\+Vector(), Json\+Modifier\+::insert\+Or\+Update\+Key\+Value(), Json\+Writer\+::insertsprintf(), Json\+Writer\+::insert\+String(), Json\+Writer\+::insert\+Value(), Json\+Modifier\+::\+Json\+Modifier(), Json\+Writer\+::\+Json\+Writer(), Json\+Reference\+::key(), String\+::operator==(), Json\+Parser\+::parse(), read\+Test\+Data(), Json\+Modifier\+::remove\+Array\+Index(), Json\+Modifier\+::remove\+Key\+Value(), Json\+Writer\+::set\+Float\+Places(), Json\+Reference\+::size(), Json\+Parser\+Generator\+R\+K\+::jsmntok\+\_\+t\+::start, Json\+Modifier\+::start\+Append(), Json\+Writer\+::start\+Array(), Json\+Modifier\+::start\+Modify(), Json\+Writer\+::start\+Object(), Json\+Reference\+::value\+Double(), Json\+Reference\+::value\+Float(), Json\+Reference\+::value\+Int(), Json\+Reference\+::value\+String(), and Json\+Reference\+::value\+Unsigned\+Long().


\begin{DoxyCode}
65                                  \{
66 
67     \{
68         JsonParser jp;
69         \textcolor{keywordtype}{char} *data2a = readTestData(\textcolor{stringliteral}{"test2a.json"});
70         jp.addData(data2a, strlen(data2a));
71         free(data2a);
72 
73         jp.parse();
74 
75         String s;
76 
77         assert(jp.getValueByKey(jp.getOuterObject(), \textcolor{stringliteral}{"range"}, s));
78         assert(s == \textcolor{stringliteral}{"Sheet1!A2:B7"});
79 
80         assert(jp.getReference().key(\textcolor{stringliteral}{"range"}).valueString() == \textcolor{stringliteral}{"Sheet1!A2:B7"});
81 
82         assert(jp.getValueByKey(jp.getOuterObject(), \textcolor{stringliteral}{"majorDimension"}, s));
83         assert(s == \textcolor{stringliteral}{"COLUMNS"});
84 
85         assert(jp.getReference().key(\textcolor{stringliteral}{"majorDimension"}).valueString() == \textcolor{stringliteral}{"COLUMNS"});
86 
87         \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *values;
88         assert(jp.getValueTokenByKey(jp.getOuterObject(), \textcolor{stringliteral}{"values"}, values));
89         assert(jp.getArraySize(values) == 2);
90 
91         assert(jp.getReference().key(\textcolor{stringliteral}{"values"}).size() == 2);
92 
93         \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *col[2];
94         assert(jp.getValueTokenByIndex(values, 0, col[0]));
95         assert(jp.getArraySize(col[0]) == 4);
96 
97         assert(jp.getValueTokenByIndex(values, 1, col[1]));
98         assert(jp.getArraySize(col[1]) == 4);
99 
100         assert(jp.getReference().key(\textcolor{stringliteral}{"values"}).index(0).size() == 4);
101 
102         assert(jp.getValueByIndex(col[0], 0, s));
103         assert(s == \textcolor{stringliteral}{"Albert Albrecht"});
104 
105         assert(jp.getReference().key(\textcolor{stringliteral}{"values"}).index(0).index(0).valueString() == \textcolor{stringliteral}{"Albert Albrecht"});
106 
107         assert(jp.getValueByIndex(col[0], 1, s));
108         assert(s == \textcolor{stringliteral}{"Bob Billings"});
109 
110         assert(jp.getReference().key(\textcolor{stringliteral}{"values"}).index(0).index(1).valueString() == \textcolor{stringliteral}{"Bob Billings"});
111 
112         assert(jp.getValueByIndex(col[0], 2, s));
113         assert(s == \textcolor{stringliteral}{"Charlie Chaplin"});
114 
115         assert(jp.getReference().key(\textcolor{stringliteral}{"values"}).index(0).index(2).valueString() == \textcolor{stringliteral}{"Charlie Chaplin"});
116 
117         assert(jp.getValueByIndex(col[0], 3, s));
118         assert(s == \textcolor{stringliteral}{"Dave Dink"});
119 
120         assert(jp.getReference().key(\textcolor{stringliteral}{"values"}).index(0).index(3).valueString() == \textcolor{stringliteral}{"Dave Dink"});
121 
122         \textcolor{keywordtype}{int} intValue;
123         assert(jp.getValueByIndex(col[1], 0, intValue));
124         assert(intValue == 1234);
125 
126         assert(jp.getReference().key(\textcolor{stringliteral}{"values"}).index(1).index(0).valueInt() == 1234);
127 
128         assert(jp.getValueByIndex(col[1], 1, intValue));
129         assert(intValue == 2234);
130 
131         assert(jp.getReference().key(\textcolor{stringliteral}{"values"}).index(1).index(1).valueInt() == 2234);
132 
133         assert(jp.getValueByIndex(col[1], 2, intValue));
134         assert(intValue == 3234);
135 
136         assert(jp.getReference().key(\textcolor{stringliteral}{"values"}).index(1).index(2).valueInt() == 3234);
137 
138         assert(jp.getValueByIndex(col[1], 3, intValue));
139         assert(intValue == 4234);
140 
141         assert(jp.getReference().key(\textcolor{stringliteral}{"values"}).index(1).index(3).valueInt() == 4234);
142 
143         \textcolor{comment}{//}
144 
145         assert(jp.getValueByColRow(values, 0, 0, s));
146         assert(s == \textcolor{stringliteral}{"Albert Albrecht"});
147 
148         assert(jp.getValueByColRow(values, 1, 0, intValue));
149         assert(intValue == 1234);
150 
151         assert(jp.getValueByColRow(values, 0, 1, s));
152         assert(s == \textcolor{stringliteral}{"Bob Billings"});
153 
154         assert(jp.getValueByColRow(values, 1, 1, intValue));
155         assert(intValue == 2234);
156 
157         assert(jp.getValueByColRow(values, 1, 1, s));
158         assert(s == \textcolor{stringliteral}{"2234"});
159 
160         \textcolor{comment}{// printJson(jp);}
161     \}
162     \{
163         JsonParser jp;
164 
165         \textcolor{keywordtype}{char} *data2b = readTestData(\textcolor{stringliteral}{"test2b.json"});
166         \textcolor{comment}{//printf("%s", data2b);}
167 
168         jp.addData(data2b, strlen(data2b));
169         free(data2b);
170 
171         jp.parse();
172 
173         \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *key, *value;
174         String s;
175         \textcolor{keywordtype}{int} intValue;
176         \textcolor{keywordtype}{float} floatValue;
177         \textcolor{keywordtype}{double} doubleValue;
178         \textcolor{keywordtype}{bool} boolValue;
179 
180         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 0));
181         \textcolor{comment}{//printf("key: start=%d end=%d\(\backslash\)n", key->start, key->end);}
182         \textcolor{comment}{//printf("value: start=%d end=%d\(\backslash\)n", value->start, value->end);}
183         assert(key->start == 5);
184         assert(key->end == 7);
185         assert(jp.getTokenValue(key, s));
186         assert(s == \textcolor{stringliteral}{"t1"});
187         assert(value->start == 10);
188         assert(value->end == 13);
189 
190         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 1));
191         assert(key->start == 19);
192         assert(key->end == 21);
193         assert(value->start == 23);
194         assert(value->end == 27);
195         assert(jp.getTokenValue(value, intValue));
196         assert(intValue == 1234);
197 
198         assert(jp.getTokenValue(key, s));
199         assert(s== \textcolor{stringliteral}{"t2"});
200 
201         assert(jp.getValueTokenByKey(jp.getOuterObject(), \textcolor{stringliteral}{"t2"}, value));
202         assert(jp.getTokenValue(value, intValue));
203         assert(intValue == 1234);
204 
205         assert(jp.getValueByKey(jp.getOuterObject(), \textcolor{stringliteral}{"t2"}, intValue));
206         assert(intValue == 1234);
207 
208         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 2));
209         assert(jp.getTokenValue(value, floatValue));
210         assert(floatValue == 1234.5);
211         assert(jp.getTokenValue(value, doubleValue));
212         assert(doubleValue == 1234.5);
213 
214         assert(jp.getTokenValue(key, s));
215         assert(s == \textcolor{stringliteral}{"t3"});
216 
217         assert(jp.getValueTokenByKey(jp.getOuterObject(), \textcolor{stringliteral}{"t3"}, value));
218         assert(jp.getTokenValue(value, floatValue));
219         assert(floatValue == 1234.5);
220 
221 
222         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 3));
223         assert(jp.getTokenValue(key, s));
224         assert(s == \textcolor{stringliteral}{"t4"});
225         assert(jp.getTokenValue(value, boolValue));
226         assert(boolValue);
227 
228         assert(jp.getValueTokenByKey(jp.getOuterObject(), \textcolor{stringliteral}{"t4"}, value));
229         assert(jp.getTokenValue(value, boolValue));
230         assert(boolValue);
231 
232         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 4));
233         assert(jp.getTokenValue(key, s));
234         assert(s == \textcolor{stringliteral}{"t5"});
235         assert(jp.getTokenValue(value, boolValue));
236         assert(!boolValue);
237 
238         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 6));
239         assert(jp.getTokenValue(key, s));
240         assert(s == \textcolor{stringliteral}{"t7"});
241 
242         assert(jp.getTokenValue(value, s));
243         assert(s == \textcolor{stringliteral}{"\(\backslash\)"quoted\(\backslash\)""});
244 
245         assert(!jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 999));
246         assert(!jp.getValueTokenByKey(jp.getOuterObject(), \textcolor{stringliteral}{"xxx"}, value));
247 
248 
249         \textcolor{comment}{//printJson(jp);}
250 
251 
252     \}
253     \textcolor{comment}{// Static buffer test}
254     \{
255         JsonParserStatic<256, 25> jp;
256 
257         \textcolor{keywordtype}{char} *data2b = readTestData(\textcolor{stringliteral}{"test2b.json"});
258 
259         jp.addData(data2b, strlen(data2b));
260         free(data2b);
261 
262         jp.parse();
263 
264         \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *key, *value;
265         \textcolor{keywordtype}{char} buf[256];
266         \textcolor{keywordtype}{size\_t} bufLen;
267         \textcolor{keywordtype}{int} intValue;
268         \textcolor{keywordtype}{float} floatValue;
269         \textcolor{keywordtype}{double} doubleValue;
270         \textcolor{keywordtype}{bool} boolValue;
271 
272         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 0));
273         \textcolor{comment}{//printf("key: start=%d end=%d\(\backslash\)n", key->start, key->end);}
274         \textcolor{comment}{//printf("value: start=%d end=%d\(\backslash\)n", value->start, value->end);}
275         assert(key->start == 5);
276         assert(key->end == 7);
277         assert(value->start == 10);
278         assert(value->end == 13);
279         bufLen = \textcolor{keyword}{sizeof}(buf);
280         assert(jp.getTokenValue(value, buf, bufLen));
281         assert(bufLen == 4); \textcolor{comment}{// includes null terminator}
282         assert(strcmp(buf, \textcolor{stringliteral}{"abc"}) == 0);
283 
284         \textcolor{comment}{// Test exactly-sized buffer with null}
285         bufLen = 4;
286         assert(jp.getTokenValue(value, buf, bufLen));
287         assert(bufLen == 4);
288         assert(strcmp(buf, \textcolor{stringliteral}{"abc"}) == 0);
289 
290         \textcolor{comment}{// Test short buffer}
291         bufLen = 3;
292         assert(jp.getTokenValue(value, buf, bufLen));
293         assert(bufLen == 4);
294         assert(strcmp(buf, \textcolor{stringliteral}{"ab"}) == 0);
295 
296         \textcolor{comment}{// Test null buffer sizing}
297         assert(jp.getTokenValue(value, NULL, bufLen));
298         assert(bufLen == 4);
299 
300 
301         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 1));
302         assert(key->start == 19);
303         assert(key->end == 21);
304         assert(value->start == 23);
305         assert(value->end == 27);
306         assert(jp.getTokenValue(value, intValue));
307         assert(intValue == 1234);
308 
309         assert(jp.getValueTokenByKey(jp.getOuterObject(), \textcolor{stringliteral}{"t2"}, value));
310         assert(jp.getTokenValue(value, intValue));
311         assert(intValue == 1234);
312 
313         assert(jp.getValueByKey(jp.getOuterObject(), \textcolor{stringliteral}{"t2"}, intValue));
314         assert(intValue == 1234);
315 
316         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 2));
317         assert(jp.getTokenValue(value, floatValue));
318         assert(floatValue == 1234.5);
319         assert(jp.getTokenValue(value, doubleValue));
320         assert(doubleValue == 1234.5);
321 
322         assert(jp.getValueTokenByKey(jp.getOuterObject(), \textcolor{stringliteral}{"t3"}, value));
323         assert(jp.getTokenValue(value, floatValue));
324         assert(floatValue == 1234.5);
325 
326 
327         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 3));
328         assert(jp.getTokenValue(value, boolValue));
329         assert(boolValue);
330 
331         assert(jp.getValueTokenByKey(jp.getOuterObject(), \textcolor{stringliteral}{"t4"}, value));
332         assert(jp.getTokenValue(value, boolValue));
333         assert(boolValue);
334 
335         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 4));
336         assert(jp.getTokenValue(value, boolValue));
337         assert(!boolValue);
338 
339         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 6));
340 
341         bufLen = \textcolor{keyword}{sizeof}(buf);
342         assert(jp.getTokenValue(value, buf, bufLen));
343         assert(bufLen == 9); \textcolor{comment}{// includes null}
344         assert(strcmp(buf, \textcolor{stringliteral}{"\(\backslash\)"quoted\(\backslash\)""}) == 0);
345 
346         assert(!jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 999));
347         assert(!jp.getValueTokenByKey(jp.getOuterObject(), \textcolor{stringliteral}{"xxx"}, value));
348 
349     \}
350 
351     \textcolor{comment}{// Static buffer too small}
352     \{
353         JsonParserStatic<50, 25> jp;
354 
355         \textcolor{keywordtype}{char} *data2b = readTestData(\textcolor{stringliteral}{"test2b.json"});
356 
357         assert(!jp.addData(data2b, strlen(data2b)));
358 
359         free(data2b);
360     \}
361 
362     \textcolor{comment}{// Static buffer tokens too small}
363     \{
364         JsonParserStatic<256, 5> jp;
365 
366         \textcolor{keywordtype}{char} *data2b = readTestData(\textcolor{stringliteral}{"test2b.json"});
367 
368         assert(jp.addData(data2b, strlen(data2b)));
369         free(data2b);
370 
371         assert(!jp.parse());
372     \}
373 
374     \textcolor{comment}{// Unicode and some other odd data tests}
375     \{
376         JsonParser jp;
377         \textcolor{keywordtype}{char} *data = readTestData(\textcolor{stringliteral}{"test2c.json"});
378         jp.addData(data, strlen(data));
379         free(data);
380 
381         jp.parse();
382 
383         String s;
384         \textcolor{keywordtype}{int} intValue;
385 
386         \textcolor{comment}{// UTF-8 test: "t1":"ab\(\backslash\)"\(\backslash\)u00A2c\(\backslash\)u20AC"}
387         assert(jp.getValueByKey(jp.getOuterObject(), \textcolor{stringliteral}{"t1"}, s));
388 
389         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *sc = s;
390         printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, sc);
391 
392         \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *uc = (\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *)sc;
393 
394         \textcolor{keywordtype}{size\_t} ii = 0;
395         assert(sc[ii++] == \textcolor{charliteral}{'a'});
396         assert(sc[ii++] == \textcolor{charliteral}{'b'});
397         assert(sc[ii++] == \textcolor{charliteral}{'"'});
398 
399         assert(uc[ii++] == 0xc2);
400         assert(uc[ii++] == 0xa2);
401 
402         assert(uc[ii++] == 0xe2);
403         assert(uc[ii++] == 0x82);
404         assert(uc[ii++] == 0xac);
405 
406 
407         \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *t2obj;
408         assert(jp.getValueTokenByKey(jp.getOuterObject(), \textcolor{stringliteral}{"t2"}, t2obj));
409 
410         assert(jp.getValueByKey(t2obj, \textcolor{stringliteral}{"a"}, s));
411         assert(s == \textcolor{stringliteral}{"foo"});
412 
413         \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *t3obj;
414         assert(jp.getValueTokenByKey(jp.getOuterObject(), \textcolor{stringliteral}{"t3"}, t3obj));
415 
416 
417         assert(jp.getValueByIndex(t3obj, 0, intValue));
418         assert(intValue == 1);
419 
420         assert(jp.getValueByIndex(t3obj, 1, intValue));
421         assert(intValue == 2);
422 
423         assert(jp.getValueByIndex(t3obj, 2, intValue));
424         assert(intValue == 3);
425 
426         assert(jp.getValueByIndex(t3obj, 2, s));
427         assert(s == \textcolor{stringliteral}{"3"});
428 
429         \textcolor{comment}{// Using fluent API}
430         assert(jp.getReference().key(\textcolor{stringliteral}{"t2"}).key(\textcolor{stringliteral}{"a"}).valueString() == \textcolor{stringliteral}{"foo"});
431         assert(jp.getReference().key(\textcolor{stringliteral}{"t3"}).index(0).valueInt() == 1);
432         assert(jp.getReference().key(\textcolor{stringliteral}{"t3"}).index(1).valueInt() == 2);
433         assert(jp.getReference().key(\textcolor{stringliteral}{"t3"}).index(2).valueInt() == 3);
434         assert(jp.getReference().key(\textcolor{stringliteral}{"t3"}).index(2).valueUnsignedLong() == 3);
435         assert(jp.getReference().key(\textcolor{stringliteral}{"t3"}).index(2).valueString() == \textcolor{stringliteral}{"3"});
436         assert(jp.getReference().key(\textcolor{stringliteral}{"t3"}).index(2).valueFloat() == 3.0);
437         assert(jp.getReference().key(\textcolor{stringliteral}{"t3"}).index(2).valueDouble() == 3.0);
438 
439     \}
440 
441     \textcolor{comment}{// Test large data from OpenWeatherMap:}
442     \textcolor{comment}{// https://openweathermap.org/forecast5}
443     \textcolor{comment}{// http://api.openweathermap.org/data/2.5/forecast?id=524901&APPID=YOUR\_API\_KEY}
444     \{
445         JsonParser jp;
446         \textcolor{keywordtype}{char} *data = readTestData(\textcolor{stringliteral}{"test2d.json"});
447         \textcolor{keywordtype}{size\_t} dataLen = strlen(data);
448 
449         \textcolor{comment}{// Break it up into 255 byte segments like a subscription}
450         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} offset = 0; offset < dataLen; offset += 255) \{
451             \textcolor{keywordtype}{size\_t} count = dataLen - offset;
452             \textcolor{keywordflow}{if} (count > 255) \{
453                 count = 255;
454             \}
455             jp.addData(&data[offset], count);
456         \}
457         free(data);
458 
459         jp.parse();
460 
461         \textcolor{comment}{/*}
462 \textcolor{comment}{        
      \{"city":\{"id":524901,"name":"Moscow","coord":\{"lon":37.615555,"lat":55.75222\},"country":"RU","population":0,"sys":\{"population":0\}\},}
463 \textcolor{comment}{            "cod":"200","message":0.0168,"cnt":40,}
464 \textcolor{comment}{            
      "list":[\{"dt":1478984400,"main":\{"temp":267.67,"temp\_min":267.324,"temp\_max":267.67,"pressure":1010.4,"sea\_level":1031.53,"grnd\_level":1010.4,"humidity":90,"temp\_kf":0.34\},}
465 \textcolor{comment}{                "weather":[\{"id":600,"main":"Snow","description":"light
       snow","icon":"13n"\}],"clouds":\{"all":88\},"wind":\{"speed":4.93,"deg":278.007\},"snow":\{"3h":0.22125\},"sys":\{"pod":"n"\},"dt\_txt":"2016-11-12
       21:00:00"\},}
466 \textcolor{comment}{            \{"dt":1478995200,"main":\{"temp":268.12,"temp\_min":267.864}
467 \textcolor{comment}{         */}
468         String strValue;
469         \textcolor{keywordtype}{int} intValue;
470         \textcolor{keywordtype}{float} floatValue;
471 
472         \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *cityToken; \textcolor{comment}{// is an object}
473 
474         assert(jp.getValueTokenByKey(jp.getOuterObject(), \textcolor{stringliteral}{"city"}, cityToken));
475 
476         assert(jp.getValueByKey(cityToken, \textcolor{stringliteral}{"id"}, intValue));
477         assert(intValue == 524901);
478 
479         assert(jp.getValueByKey(cityToken, \textcolor{stringliteral}{"name"}, strValue));
480         assert(strValue == \textcolor{stringliteral}{"Moscow"});
481 
482         assert(jp.getValueByKey(cityToken, \textcolor{stringliteral}{"country"}, strValue));
483         assert(strValue == \textcolor{stringliteral}{"RU"});
484 
485         \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *listToken; \textcolor{comment}{// is an array}
486         assert(jp.getValueTokenByKey(jp.getOuterObject(), \textcolor{stringliteral}{"list"}, listToken));
487         assert(jp.getArraySize(listToken) > 1);
488 
489         \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *listObj; \textcolor{comment}{// is an object}
490         assert(jp.getValueTokenByIndex(listToken, 0, listObj));
491 
492         assert(jp.getValueByKey(listObj, \textcolor{stringliteral}{"dt"}, intValue));
493         assert(intValue == 1478984400);
494 
495         \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *mainObj; \textcolor{comment}{// is an array}
496         assert(jp.getValueTokenByKey(listObj, \textcolor{stringliteral}{"main"}, mainObj));
497 
498         assert(jp.getValueByKey(mainObj, \textcolor{stringliteral}{"temp"}, floatValue));
499         assert(floatValue >= 267.6 && floatValue <= 267.7); \textcolor{comment}{// 267.67}
500 
501         \textcolor{comment}{// Second in the list}
502         assert(jp.getValueTokenByIndex(listToken, 1, listObj));
503 
504         assert(jp.getValueByKey(listObj, \textcolor{stringliteral}{"dt"}, intValue));
505         assert(intValue == 1478995200);
506 
507         \textcolor{comment}{// This is the last array element to make sure we've parsed correctly all the way to to the end}
508         \textcolor{comment}{//
       \{"dt":1479405600,"main":\{"temp":267.329,"temp\_min":267.329,"temp\_max":267.329,"pressure":1024.37,
      "sea\_level":1045.84,"grnd\_level":1024.37,"humidity":91,"temp\_kf":0\},"weather":[\{"id":600,"main":"Snow","description":"light
       snow","icon":"13n"\}],"clouds":\{"all":80\},"wind":\{"speed":4.95,"deg":179.502\},"snow":\{"3h":0.105\},"sys":\{"pod":"n"\},"dt\_txt":"2016-11-17 18:00:00"\}]\}}
509         assert(jp.getValueTokenByIndex(listToken, jp.getArraySize(listToken) - 1, listObj));
510 
511         assert(jp.getValueByKey(listObj, \textcolor{stringliteral}{"dt"}, intValue));
512         assert(intValue == 1479405600);
513 
514         assert(jp.getValueByKey(listObj, \textcolor{stringliteral}{"dt\_txt"}, strValue));
515         assert(strValue == \textcolor{stringliteral}{"2016-11-17 18:00:00"});
516 
517 
518     \}
519     \textcolor{comment}{// Test large data from wunderground.com}
520     \{
521         JsonParser jp;
522         \textcolor{keywordtype}{char} *data = readTestData(\textcolor{stringliteral}{"test2e.json"});
523         \textcolor{keywordtype}{size\_t} dataLen = strlen(data);
524 
525         \textcolor{comment}{// Break it up into 255 byte segments like a subscription}
526         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} offset = 0; offset < dataLen; offset += 255) \{
527             \textcolor{keywordtype}{size\_t} count = dataLen - offset;
528             \textcolor{keywordflow}{if} (count > 255) \{
529                 count = 255;
530             \}
531             jp.addData(&data[offset], count);
532         \}
533         free(data);
534 
535         jp.parse();
536 
537         \textcolor{comment}{// Use the fluent-style API here}
538         assert(jp.getReference().key(\textcolor{stringliteral}{"response"}).key(\textcolor{stringliteral}{"version"}).valueString() == \textcolor{stringliteral}{"0.1"});
539 
540         assert(jp.getReference().key(\textcolor{stringliteral}{"forecast"}).key(\textcolor{stringliteral}{"txt\_forecast"}).key(\textcolor{stringliteral}{"date"}).
      valueString() == \textcolor{stringliteral}{"12:25 PM EST"});
541         assert(jp.getReference().key(\textcolor{stringliteral}{"forecast"}).key(\textcolor{stringliteral}{"txt\_forecast"}).key(\textcolor{stringliteral}{"forecastday"}).
      key(\textcolor{stringliteral}{"period"}).valueInt() == 7);
542 
543     \}
544 
545     \textcolor{comment}{// Test data from Github issue}
546     \textcolor{comment}{// https://github.com/rickkas7/JsonParserGeneratorRK/issues/1}
547     \textcolor{comment}{// \{"A--":\{"M":\{"M":2,"U":5000,"T":10,"C":[0,255]\}\}\}}
548     \{
549         JsonParser jp;
550         String s;
551 
552         \textcolor{keywordtype}{char} *data = readTestData(\textcolor{stringliteral}{"test2f.json"});
553 
554         jp.addString(data);
555         free(data);
556 
557         \textcolor{keywordtype}{bool} bResult = jp.parse();
558         assert(bResult);
559 
560         \textcolor{comment}{// Check fluent parser}
561         assert(jp.getReference().key(\textcolor{stringliteral}{"A--"}).key(\textcolor{stringliteral}{"M"}).key(\textcolor{stringliteral}{"U"}).valueInt() == 5000);
562 
563         \textcolor{comment}{// Check iteration}
564         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} ii = 0; ; ii++) \{
565             \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *keyToken;
566             \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *valueToken;
567             String name;
568 
569             \textcolor{keywordflow}{if} (!jp.getKeyValueTokenByIndex(jp.getOuterObject(), keyToken, valueToken, ii)) \{
570                 \textcolor{comment}{// Reached end}
571                 assert(ii == 1);
572                 \textcolor{keywordflow}{break};
573             \}
574 
575             bResult = jp.getTokenValue(keyToken, name);
576             assert(bResult);
577 
578             assert(name == \textcolor{stringliteral}{"A--"});
579 
580             \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *valueTokenInnerM;
581 
582             bResult = jp.getValueTokenByKey(valueToken, \textcolor{stringliteral}{"M"}, valueTokenInnerM);
583             assert(bResult);
584 
585             \textcolor{comment}{// Convert back to a JSON string}
586             bResult = jp.getTokenJsonString(valueTokenInnerM, s);
587             assert(bResult);
588             assert(s == \textcolor{stringliteral}{"\{\(\backslash\)"M\(\backslash\)":2,\(\backslash\)"U\(\backslash\)":5000,\(\backslash\)"T\(\backslash\)":10,\(\backslash\)"C\(\backslash\)":[0,255]\}"});
589 
590             \textcolor{comment}{// Parse inner}
591             \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} jj = 0; ; jj++) \{
592                 \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *keyTokenInner;
593                 \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *valueTokenInner;
594 
595                 \textcolor{keywordflow}{if} (!jp.getKeyValueTokenByIndex(valueTokenInnerM, keyTokenInner, valueTokenInner, jj)) \{
596                     \textcolor{comment}{// Reached end}
597                     \textcolor{keywordflow}{break};
598                 \}
599                 bResult = jp.getTokenValue(keyTokenInner, name);
600                 assert(bResult);
601 
602                 \textcolor{keywordtype}{int} intValue;
603 
604                 \textcolor{keywordflow}{if} (name == \textcolor{stringliteral}{"M"}) \{
605                     bResult = jp.getTokenValue(valueTokenInner, intValue);
606                     assert(bResult);
607                     assert(intValue == 2);
608                 \}
609                 \textcolor{keywordflow}{else}
610                 \textcolor{keywordflow}{if} (name == \textcolor{stringliteral}{"U"}) \{
611                     bResult = jp.getTokenValue(valueTokenInner, intValue);
612                     assert(bResult);
613                     assert(intValue == 5000);
614 
615                     \textcolor{comment}{// Convert back to a string}
616                     bResult = jp.getTokenJsonString(valueTokenInner, s);
617                     assert(bResult);
618 
619                     assert(s == \textcolor{stringliteral}{"5000"});
620                 \}
621                 \textcolor{keywordflow}{else}
622                 \textcolor{keywordflow}{if} (name == \textcolor{stringliteral}{"T"}) \{
623                     bResult = jp.getTokenValue(valueTokenInner, intValue);
624                     assert(bResult);
625                     assert(intValue == 10);
626                 \}
627                 \textcolor{keywordflow}{else}
628                 \textcolor{keywordflow}{if} (name == \textcolor{stringliteral}{"C"}) \{
629                     assert(jp.getArraySize(valueTokenInner) == 2);
630 
631                     bResult = jp.getValueByIndex(valueTokenInner, 0, intValue);
632                     assert(bResult);
633                     assert(intValue == 0);
634 
635                     bResult = jp.getValueByIndex(valueTokenInner, 1, intValue);
636                     assert(bResult);
637                     assert(intValue == 255);
638 
639                     \textcolor{comment}{// Convert back to a string}
640                     bResult = jp.getTokenJsonString(valueTokenInner, s);
641                     assert(bResult);
642 
643                     assert(s == \textcolor{stringliteral}{"[0,255]"});
644                 \}
645                 \textcolor{keywordflow}{else} \{
646                     assert(0);
647                 \}
648             \}
649 
650             \textcolor{comment}{// Test converting back to JSON}
651             \textcolor{comment}{// \{"A--":\{"M":\{"M":2,"U":5000,"T":10,"C":[0,255]\}\}\}}
652             String s;
653             bResult = jp.getTokenJsonString(jp.getOuterToken(), s);
654             assert(bResult);
655 
656             \textcolor{keyword}{const} \textcolor{keywordtype}{char} *expected = \textcolor{stringliteral}{"\{\(\backslash\)"A--\(\backslash\)":\{\(\backslash\)"M\(\backslash\)":\{\(\backslash\)"M\(\backslash\)":2,\(\backslash\)"U\(\backslash\)":5000,\(\backslash\)"T\(\backslash\)":10,\(\backslash\)"C\(\backslash\)":[0,255]\}\}\}"};
657 
658             assert(s == expected);
659 
660             \textcolor{keywordtype}{char} newJsonBuf[64];
661             \textcolor{keywordtype}{size\_t} bufLen = \textcolor{keyword}{sizeof}(newJsonBuf);
662             bResult = jp.getTokenJsonString(jp.getOuterToken(), newJsonBuf, bufLen);
663             assert(bResult);
664 
665             assert(bufLen = (strlen(expected) + 1));
666             assert(strcmp(newJsonBuf, expected) == 0);
667 
668         \}
669 
670         \{
671             \textcolor{comment}{// \{"DID":"0000111122223333395abcd","NOM":"T","BV":"3.8","SOC":"3","PWR":"F","CHG":"T"\}}
672             JsonParserStatic<256, 14> jp;
673             String s;
674 
675             \textcolor{keywordtype}{char} *data = readTestData(\textcolor{stringliteral}{"test2g.json"});
676 
677             jp.addString(data);
678             free(data);
679 
680             \textcolor{keywordtype}{bool} bResult = jp.parse();
681             assert(bResult);
682 
683             bResult = jp.getOuterValueByKey(\textcolor{stringliteral}{"DID"}, s);
684             assert(bResult);
685             assert(s == \textcolor{stringliteral}{"0000111122223333395abcd"});
686 
687 
688             bResult = jp.getOuterValueByKey(\textcolor{stringliteral}{"NOM"}, s);
689             assert(bResult);
690             assert(s == \textcolor{stringliteral}{"T"});
691 
692             \textcolor{keywordtype}{float} f;
693             bResult = jp.getOuterValueByKey(\textcolor{stringliteral}{"BV"}, f);
694             assert(bResult);
695             assert(f > 3.7 && f < 3.9);
696 
697             \textcolor{keywordtype}{int} i;
698             bResult = jp.getOuterValueByKey(\textcolor{stringliteral}{"SOC"}, i);
699             assert(bResult);
700             assert(i == 3);
701 
702             bResult = jp.getOuterValueByKey(\textcolor{stringliteral}{"PWR"}, s);
703             assert(bResult);
704             assert(s == \textcolor{stringliteral}{"F"});
705 
706             bResult = jp.getOuterValueByKey(\textcolor{stringliteral}{"CHG"}, s);
707             assert(bResult);
708             assert(s == \textcolor{stringliteral}{"T"});
709 
710         \}
711     \}
712 
713     \textcolor{comment}{// Calling parse on an empty buffer should return false}
714     \textcolor{comment}{// https://github.com/rickkas7/JsonParserGeneratorRK/issues/7}
715     \{
716         JsonParser jp;
717         String s;
718 
719         jp.addString(\textcolor{stringliteral}{""});
720         
721         \textcolor{keywordtype}{bool} bResult = jp.parse();
722         assert(!bResult);
723     \}
724 
725     \{
726         \textcolor{comment}{//
       https://community.particle.io/t/jsonparsergeneratorrk-parsing-a-child-key-from-a-firebase-get-webhook/56395}
727         \textcolor{comment}{// \{"-M5sN1MfCHcXHkLBlwWW":\{"aug":false,"fan":true,"ign":true\}\}}
728         JsonParserStatic<256, 14> jp;
729         String s;
730 
731         \textcolor{keywordtype}{char} *data = readTestData(\textcolor{stringliteral}{"test2h.json"});
732 
733         jp.addString(data);
734         free(data);
735 
736         \textcolor{keywordtype}{bool} bResult = jp.parse();
737         assert(bResult);
738 
739         \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *firstObject;
740         bResult = jp.getValueTokenByIndex(jp.getOuterObject(), 1, firstObject);
741         assert(bResult);
742         assert(firstObject != 0);
743 
744         \textcolor{keywordtype}{bool} bValue;
745 
746         bResult = jp.getValueByKey(firstObject, \textcolor{stringliteral}{"aug"}, bValue);
747         assert(bResult);
748         assert(bValue == \textcolor{keyword}{false});
749 
750         bResult = jp.getValueByKey(firstObject, \textcolor{stringliteral}{"fan"}, bValue);
751         assert(bResult);
752         assert(bValue == \textcolor{keyword}{true});
753 
754         bResult = jp.getValueByKey(firstObject, \textcolor{stringliteral}{"ign"}, bValue);
755         assert(bResult);
756         assert(bValue == \textcolor{keyword}{true});
757 
758     \}
759 
760     \textcolor{comment}{// Writer test, unallocated buffer}
761     \{
762         JsonWriter jw;
763         jw.addString(\textcolor{stringliteral}{"abcdefgh"});
764         assertJsonWriterBuffer(jw, \textcolor{stringliteral}{"abcdefgh"});
765     \}
766     \textcolor{comment}{// Writer test, small allocated buffer}
767     \{
768         JsonWriter jw;
769         jw.allocate(6);
770         jw.addString(\textcolor{stringliteral}{"abcdefgh"});
771         assertJsonWriterBuffer(jw, \textcolor{stringliteral}{"abcdefgh"});
772     \}
773     \textcolor{comment}{// Writer test - sprintf}
774     \{
775         JsonWriterStatic<100> jw;
776 
777         jw.insertsprintf(\textcolor{stringliteral}{"%04x"}, 0x1234);
778         assertJsonWriterBuffer(jw, \textcolor{stringliteral}{"1234"});
779     \}
780     \textcolor{comment}{// Writer test - string insert Unicode}
781     \{
782         JsonWriterStatic<100> jw;
783 
784         \textcolor{keywordtype}{char} tmp[4];
785         tmp[0] = 0xc2;
786         tmp[1] = 0xa2;
787         tmp[2] = 0;
788 
789         jw.insertString(tmp, \textcolor{keyword}{true});
790         assertJsonWriterBuffer(jw, \textcolor{stringliteral}{"\(\backslash\)"\(\backslash\)\(\backslash\)u00A2\(\backslash\)""});
791     \}
792     \{
793         JsonWriterStatic<100> jw;
794         \textcolor{keywordtype}{char} tmp[4];
795         tmp[0]= 0xe2;
796         tmp[1]= 0x82;
797         tmp[2] = 0xac;
798         tmp[3] = 0;
799 
800         jw.insertString(tmp, \textcolor{keyword}{false});
801         assertJsonWriterBuffer(jw, \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)u20AC"});
802     \}
803 
804     \textcolor{comment}{// Writer test - special chars}
805     \{
806         JsonWriterStatic<100> jw;
807 
808         jw.insertString(\textcolor{stringliteral}{"\(\backslash\)b\(\backslash\)f\(\backslash\)n\(\backslash\)r\(\backslash\)t\(\backslash\)"\(\backslash\)\(\backslash\)"}, \textcolor{keyword}{false});
809         assertJsonWriterBuffer(jw, \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)b\(\backslash\)\(\backslash\)f\(\backslash\)\(\backslash\)n\(\backslash\)\(\backslash\)r\(\backslash\)\(\backslash\)t\(\backslash\)\(\backslash\)\(\backslash\)"\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)"});
810 
811     \}
812 
813     \textcolor{comment}{// Writer test - simple array}
814     \{
815         JsonWriterStatic<256> jw;
816 
817         jw.startArray();
818 
819         jw.insertArrayValue(\textcolor{keyword}{true});
820         jw.insertArrayValue(1234);
821         jw.insertArrayValue(\textcolor{stringliteral}{"test"});
822 
823         jw.finishObjectOrArray();
824 
825         \textcolor{comment}{//printf("'%s'\(\backslash\)n", jw.getBuffer());}
826 
827         assertJsonWriterBuffer(jw, \textcolor{stringliteral}{"[true,1234,\(\backslash\)"test\(\backslash\)"]"});
828 
829     \}
830 
831     \textcolor{comment}{// Writer test - simple object}
832     \{
833         JsonWriterStatic<256> jw;
834 
835         jw.startObject();
836 
837         jw.insertKeyValue(\textcolor{stringliteral}{"a"}, \textcolor{keyword}{true});
838         jw.insertKeyValue(\textcolor{stringliteral}{"b"}, 1234);
839         jw.insertKeyValue(\textcolor{stringliteral}{"c"}, \textcolor{stringliteral}{"test"});
840 
841         jw.finishObjectOrArray();
842 
843         assertJsonWriterBuffer(jw, \textcolor{stringliteral}{"\{\(\backslash\)"a\(\backslash\)":true,\(\backslash\)"b\(\backslash\)":1234,\(\backslash\)"c\(\backslash\)":\(\backslash\)"test\(\backslash\)"\}"});
844 
845     \}
846 
847     \textcolor{comment}{// Writer test - null termination test}
848     \{
849         \textcolor{keywordtype}{char} buf[256];
850         memset(buf, \textcolor{charliteral}{'x'}, \textcolor{keyword}{sizeof}(buf));
851         JsonWriter jw(buf, \textcolor{keyword}{sizeof}(buf));
852 
853         jw.startObject();
854 
855         jw.insertKeyValue(\textcolor{stringliteral}{"a"}, \textcolor{keyword}{true});
856         jw.insertKeyValue(\textcolor{stringliteral}{"b"}, 1234);
857         jw.insertKeyValue(\textcolor{stringliteral}{"c"}, \textcolor{stringliteral}{"test"});
858 
859         jw.finishObjectOrArray();
860 
861         assertJsonWriterBuffer(jw, \textcolor{stringliteral}{"\{\(\backslash\)"a\(\backslash\)":true,\(\backslash\)"b\(\backslash\)":1234,\(\backslash\)"c\(\backslash\)":\(\backslash\)"test\(\backslash\)"\}"});
862 
863     \}
864 
865     \textcolor{comment}{// Writer test - nested}
866     \{
867         JsonWriterStatic<256> jw;
868 
869         jw.startObject();
870 
871         jw.insertKeyArray(\textcolor{stringliteral}{"a"});
872         jw.insertArrayValue(123);
873         jw.insertArrayValue(456);
874         jw.insertArrayValue(789);
875         jw.finishObjectOrArray();
876 
877         jw.insertKeyObject(\textcolor{stringliteral}{"b"});
878         jw.insertKeyValue(\textcolor{stringliteral}{"ba"}, \textcolor{keyword}{true});
879         jw.insertKeyValue(\textcolor{stringliteral}{"bb"}, 1234);
880         jw.finishObjectOrArray();
881 
882         jw.finishObjectOrArray();
883 
884         assertJsonWriterBuffer(jw, \textcolor{stringliteral}{"\{\(\backslash\)"a\(\backslash\)":[123,456,789],\(\backslash\)"b\(\backslash\)":\{\(\backslash\)"ba\(\backslash\)":true,\(\backslash\)"bb\(\backslash\)":1234\}\}"});
885 
886     \}
887 
888     \textcolor{comment}{// Writer test - array of objects - low level API}
889     \{
890         JsonWriterStatic<256> jw;
891 
892         jw.startArray();
893 
894         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} ii = 0; ii < 5; ii++) \{
895             \textcolor{comment}{// This used to be necessary, but now startObject takes care of this automatically}
896             \textcolor{comment}{// jw.insertCheckSeparator();}
897             jw.startObject();
898             jw.insertKeyValue(\textcolor{stringliteral}{"ii"}, ii);
899 
900             jw.finishObjectOrArray();
901         \}
902 
903         jw.finishObjectOrArray();
904 
905         \textcolor{comment}{// printf("'%s'\(\backslash\)n", jw.getBuffer());}
906 
907         assertJsonWriterBuffer(jw, \textcolor{stringliteral}{"[\{\(\backslash\)"ii\(\backslash\)":0\},\{\(\backslash\)"ii\(\backslash\)":1\},\{\(\backslash\)"ii\(\backslash\)":2\},\{\(\backslash\)"ii\(\backslash\)":3\},\{\(\backslash\)"ii\(\backslash\)":4\}]"});
908 
909     \}
910 
911     \textcolor{comment}{// Writer test - float places object}
912     \{
913         JsonWriterStatic<256> jw;
914 
915         jw.startObject();
916 
917         jw.setFloatPlaces(2);
918         jw.insertKeyValue(\textcolor{stringliteral}{"a"}, 12.3333);
919 
920         jw.setFloatPlaces(0);
921         jw.insertKeyValue(\textcolor{stringliteral}{"b"}, (\textcolor{keywordtype}{double})12.77777777);
922 
923         jw.finishObjectOrArray();
924 
925         assertJsonWriterBuffer(jw, \textcolor{stringliteral}{"\{\(\backslash\)"a\(\backslash\)":12.33,\(\backslash\)"b\(\backslash\)":13\}"});
926 
927     \}
928 
929     \textcolor{comment}{// Writer test - int array}
930     \{
931         JsonWriterStatic<256> jw;
932 
933         \textcolor{keywordtype}{int} array[3];
934         array[0] = 1;
935         array[1] = 2;
936         array[2] = 3;
937 
938         jw.startObject();
939 
940         jw.setFloatPlaces(2);
941         jw.insertKeyValue(\textcolor{stringliteral}{"a"}, \textcolor{stringliteral}{"test"});
942 
943         jw.insertKeyArray(\textcolor{stringliteral}{"b"}, array, \textcolor{keyword}{sizeof}(array)/\textcolor{keyword}{sizeof}(array[0]));
944         
945         \textcolor{comment}{// This closes the outer object}
946         jw.finishObjectOrArray();
947 
948         assertJsonWriterBuffer(jw, \textcolor{stringliteral}{"\{\(\backslash\)"a\(\backslash\)":\(\backslash\)"test\(\backslash\)",\(\backslash\)"b\(\backslash\)":[1,2,3]\}"});
949     \}
950 
951     \textcolor{comment}{// Writer test - float vector}
952     \{
953         JsonWriterStatic<256> jw;
954 
955         std::vector<float> vector;
956         vector.push\_back(1.1);
957         vector.push\_back(2.2);
958         vector.push\_back(3.333);
959 
960         jw.startObject();
961 
962         jw.setFloatPlaces(2);
963         jw.insertKeyValue(\textcolor{stringliteral}{"a"}, \textcolor{stringliteral}{"test"});
964         jw.insertKeyVector(\textcolor{stringliteral}{"b"}, vector);
965 
966         \textcolor{comment}{// This closes the outer object}
967         jw.finishObjectOrArray();
968 
969         assertJsonWriterBuffer(jw, \textcolor{stringliteral}{"\{\(\backslash\)"a\(\backslash\)":\(\backslash\)"test\(\backslash\)",\(\backslash\)"b\(\backslash\)":[1.10,2.20,3.33]\}"});
970 
971     \}
972  
973     \textcolor{comment}{// Writer test - float vector #2}
974     \{
975         JsonWriterStatic<256> jw;
976 
977         std::vector<float> vector;
978         vector.push\_back(1.1);
979         vector.push\_back(2.2);
980         vector.push\_back(3.333);
981         \textcolor{keywordflow}{if} (vector.size() > 2) \{
982             \textcolor{comment}{// Remove the first (oldest) element}
983             vector.erase(vector.begin());
984         \}
985 
986         jw.startObject();
987 
988         jw.setFloatPlaces(2);
989         jw.insertKeyValue(\textcolor{stringliteral}{"a"}, \textcolor{stringliteral}{"test"});
990         jw.insertKeyVector(\textcolor{stringliteral}{"b"}, vector);
991 
992         
993         \textcolor{comment}{// This closes the outer object}
994         jw.finishObjectOrArray();
995 
996         assertJsonWriterBuffer(jw, \textcolor{stringliteral}{"\{\(\backslash\)"a\(\backslash\)":\(\backslash\)"test\(\backslash\)",\(\backslash\)"b\(\backslash\)":[2.20,3.33]\}"});
997 
998     \}
999 
1000     \textcolor{comment}{// Modifier test - make string longer}
1001     \{
1002         JsonParserStatic<512, 32> jp;
1003 
1004         \textcolor{keywordtype}{char} *data2b = readTestData(\textcolor{stringliteral}{"test2b.json"});
1005         \textcolor{comment}{//printf("%s", data2b);}
1006 
1007         jp.addData(data2b, strlen(data2b));
1008         free(data2b);
1009 
1010         jp.parse();
1011 
1012         \textcolor{comment}{// printTokens(jp);}
1013         \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *key, *value;
1014 
1015         \textcolor{keywordtype}{bool} bResult = jp.getValueTokenByKey(jp.getOuterToken(), \textcolor{stringliteral}{"t1"}, value);
1016         assert(bResult);
1017 
1018         JsonModifier mod(jp);
1019         bResult = mod.startModify(value);
1020         assert(bResult);
1021 
1022         mod.insertString(\textcolor{stringliteral}{"this is a test"});
1023         mod.finish();
1024 
1025         \textcolor{comment}{// printf("after modify\(\backslash\)n");}
1026         \textcolor{comment}{// printTokens(jp);}
1027 
1028         String s;
1029         \textcolor{keywordtype}{int} intValue;
1030         \textcolor{keywordtype}{float} floatValue;
1031         \textcolor{keywordtype}{double} doubleValue;
1032         \textcolor{keywordtype}{bool} boolValue;
1033 
1034         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 0));
1035         \textcolor{comment}{//printf("key: start=%d end=%d\(\backslash\)n", key->start, key->end);}
1036         \textcolor{comment}{//printf("value: start=%d end=%d\(\backslash\)n", value->start, value->end);}
1037         assert(key->start == 5);
1038         assert(key->end == 7);
1039         assert(jp.getTokenValue(key, s));
1040         assert(s == \textcolor{stringliteral}{"t1"});
1041 
1042         assert(value->start == 10);
1043         assert(value->end == 24);
1044         assert(jp.getTokenValue(value, s));
1045         assert(s == \textcolor{stringliteral}{"this is a test"});
1046 
1047         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 1));
1048         assert(jp.getTokenValue(value, intValue));
1049         assert(intValue == 1234);
1050 
1051         assert(jp.getTokenValue(key, s));
1052         assert(s== \textcolor{stringliteral}{"t2"});
1053 
1054         assert(jp.getValueByKey(jp.getOuterObject(), \textcolor{stringliteral}{"t2"}, intValue));
1055         assert(intValue == 1234);
1056 
1057         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 2));
1058         assert(jp.getTokenValue(value, floatValue));
1059         assert(floatValue == 1234.5);
1060 
1061         assert(jp.getValueTokenByKey(jp.getOuterObject(), \textcolor{stringliteral}{"t3"}, value));
1062         assert(jp.getTokenValue(value, floatValue));
1063         assert(floatValue == 1234.5);
1064 
1065         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 3));
1066         assert(jp.getTokenValue(key, s));
1067         assert(s == \textcolor{stringliteral}{"t4"});
1068         assert(jp.getTokenValue(value, boolValue));
1069         assert(boolValue);
1070 
1071         assert(jp.getValueTokenByKey(jp.getOuterObject(), \textcolor{stringliteral}{"t4"}, value));
1072         assert(jp.getTokenValue(value, boolValue));
1073         assert(boolValue);
1074 
1075         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 4));
1076         assert(jp.getTokenValue(key, s));
1077         assert(s == \textcolor{stringliteral}{"t5"});
1078         assert(jp.getTokenValue(value, boolValue));
1079         assert(!boolValue);
1080 
1081         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 6));
1082         assert(jp.getTokenValue(key, s));
1083         assert(s == \textcolor{stringliteral}{"t7"});
1084 
1085         assert(jp.getTokenValue(value, s));
1086         assert(s == \textcolor{stringliteral}{"\(\backslash\)"quoted\(\backslash\)""});
1087     \}
1088 
1089 
1090     \textcolor{comment}{// Modifier test - make string shorter}
1091     \{
1092         JsonParserStatic<512, 32> jp;
1093 
1094         \textcolor{keywordtype}{char} *data2b = readTestData(\textcolor{stringliteral}{"test2b.json"});
1095         \textcolor{comment}{//printf("%s", data2b);}
1096 
1097         jp.addData(data2b, strlen(data2b));
1098         free(data2b);
1099 
1100         jp.parse();
1101 
1102         \textcolor{comment}{// printTokens(jp);}
1103         \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *key, *value;
1104 
1105         \textcolor{keywordtype}{bool} bResult = jp.getValueTokenByKey(jp.getOuterToken(), \textcolor{stringliteral}{"t1"}, value);
1106         assert(bResult);
1107 
1108         JsonModifier mod(jp);
1109         bResult = mod.startModify(value);
1110         assert(bResult);
1111 
1112         mod.insertString(\textcolor{stringliteral}{"x"});
1113         mod.finish();
1114 
1115         \textcolor{comment}{// printf("after modify\(\backslash\)n");}
1116         \textcolor{comment}{// printTokens(jp);}
1117 
1118         String s;
1119         \textcolor{keywordtype}{int} intValue;
1120         \textcolor{keywordtype}{float} floatValue;
1121         \textcolor{keywordtype}{double} doubleValue;
1122         \textcolor{keywordtype}{bool} boolValue;
1123 
1124         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 0));
1125         \textcolor{comment}{//printf("key: start=%d end=%d\(\backslash\)n", key->start, key->end);}
1126         \textcolor{comment}{//printf("value: start=%d end=%d\(\backslash\)n", value->start, value->end);}
1127         assert(key->start == 5);
1128         assert(key->end == 7);
1129         assert(jp.getTokenValue(key, s));
1130         assert(s == \textcolor{stringliteral}{"t1"});
1131 
1132         assert(value->start == 10);
1133         assert(value->end == 11);
1134         assert(jp.getTokenValue(value, s));
1135         assert(s == \textcolor{stringliteral}{"x"});
1136 
1137         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 1));
1138         assert(jp.getTokenValue(value, intValue));
1139         assert(intValue == 1234);
1140 
1141         assert(jp.getTokenValue(key, s));
1142         assert(s== \textcolor{stringliteral}{"t2"});
1143 
1144         assert(jp.getValueByKey(jp.getOuterObject(), \textcolor{stringliteral}{"t2"}, intValue));
1145         assert(intValue == 1234);
1146 
1147         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 2));
1148         assert(jp.getTokenValue(value, floatValue));
1149         assert(floatValue == 1234.5);
1150 
1151         assert(jp.getValueTokenByKey(jp.getOuterObject(), \textcolor{stringliteral}{"t3"}, value));
1152         assert(jp.getTokenValue(value, floatValue));
1153         assert(floatValue == 1234.5);
1154 
1155         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 3));
1156         assert(jp.getTokenValue(key, s));
1157         assert(s == \textcolor{stringliteral}{"t4"});
1158         assert(jp.getTokenValue(value, boolValue));
1159         assert(boolValue);
1160 
1161         assert(jp.getValueTokenByKey(jp.getOuterObject(), \textcolor{stringliteral}{"t4"}, value));
1162         assert(jp.getTokenValue(value, boolValue));
1163         assert(boolValue);
1164 
1165         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 4));
1166         assert(jp.getTokenValue(key, s));
1167         assert(s == \textcolor{stringliteral}{"t5"});
1168         assert(jp.getTokenValue(value, boolValue));
1169         assert(!boolValue);
1170 
1171         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 6));
1172         assert(jp.getTokenValue(key, s));
1173         assert(s == \textcolor{stringliteral}{"t7"});
1174 
1175         assert(jp.getTokenValue(value, s));
1176         assert(s == \textcolor{stringliteral}{"\(\backslash\)"quoted\(\backslash\)""});
1177     \}
1178 
1179     \textcolor{comment}{// Modifier test - change integer (same size)}
1180     \{
1181         JsonParserStatic<512, 32> jp;
1182 
1183         \textcolor{keywordtype}{char} *data2b = readTestData(\textcolor{stringliteral}{"test2b.json"});
1184         \textcolor{comment}{//printf("%s", data2b);}
1185 
1186         jp.addData(data2b, strlen(data2b));
1187         free(data2b);
1188 
1189         jp.parse();
1190 
1191         \textcolor{comment}{// printTokens(jp);}
1192         \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *key, *value;
1193 
1194         \textcolor{keywordtype}{bool} bResult = jp.getValueTokenByKey(jp.getOuterToken(), \textcolor{stringliteral}{"t2"}, value);
1195         assert(bResult);
1196 
1197         JsonModifier mod(jp);
1198         bResult = mod.startModify(value);
1199         assert(bResult);
1200 
1201         mod.insertValue((\textcolor{keywordtype}{int})9999);
1202         mod.finish();
1203 
1204         \textcolor{comment}{// printf("after modify\(\backslash\)n");}
1205         \textcolor{comment}{// printTokens(jp);}
1206 
1207         String s;
1208         \textcolor{keywordtype}{int} intValue;
1209         \textcolor{keywordtype}{float} floatValue;
1210         \textcolor{keywordtype}{double} doubleValue;
1211         \textcolor{keywordtype}{bool} boolValue;
1212 
1213         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 0));
1214         \textcolor{comment}{//printf("key: start=%d end=%d\(\backslash\)n", key->start, key->end);}
1215         \textcolor{comment}{//printf("value: start=%d end=%d\(\backslash\)n", value->start, value->end);}
1216         assert(jp.getTokenValue(key, s));
1217         assert(s == \textcolor{stringliteral}{"t1"});
1218 
1219         assert(jp.getTokenValue(value, s));
1220         assert(s == \textcolor{stringliteral}{"abc"});
1221 
1222         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 1));
1223         assert(jp.getTokenValue(value, intValue));
1224         assert(intValue == 9999);
1225 
1226         assert(jp.getTokenValue(key, s));
1227         assert(s== \textcolor{stringliteral}{"t2"});
1228 
1229         assert(jp.getValueByKey(jp.getOuterObject(), \textcolor{stringliteral}{"t2"}, intValue));
1230         assert(intValue == 9999);
1231 
1232         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 2));
1233         assert(jp.getTokenValue(value, floatValue));
1234         assert(floatValue == 1234.5);
1235 
1236         assert(jp.getValueTokenByKey(jp.getOuterObject(), \textcolor{stringliteral}{"t3"}, value));
1237         assert(jp.getTokenValue(value, floatValue));
1238         assert(floatValue == 1234.5);
1239 
1240         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 3));
1241         assert(jp.getTokenValue(key, s));
1242         assert(s == \textcolor{stringliteral}{"t4"});
1243         assert(jp.getTokenValue(value, boolValue));
1244         assert(boolValue);
1245 
1246         assert(jp.getValueTokenByKey(jp.getOuterObject(), \textcolor{stringliteral}{"t4"}, value));
1247         assert(jp.getTokenValue(value, boolValue));
1248         assert(boolValue);
1249 
1250         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 4));
1251         assert(jp.getTokenValue(key, s));
1252         assert(s == \textcolor{stringliteral}{"t5"});
1253         assert(jp.getTokenValue(value, boolValue));
1254         assert(!boolValue);
1255 
1256         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 6));
1257         assert(jp.getTokenValue(key, s));
1258         assert(s == \textcolor{stringliteral}{"t7"});
1259 
1260         assert(jp.getTokenValue(value, s));
1261         assert(s == \textcolor{stringliteral}{"\(\backslash\)"quoted\(\backslash\)""});
1262     \}
1263 
1264     \textcolor{comment}{// Modifier test - change double}
1265     \{
1266         JsonParserStatic<512, 32> jp;
1267 
1268         \textcolor{keywordtype}{char} *data2b = readTestData(\textcolor{stringliteral}{"test2b.json"});
1269         \textcolor{comment}{//printf("%s", data2b);}
1270 
1271         jp.addData(data2b, strlen(data2b));
1272         free(data2b);
1273 
1274         jp.parse();
1275 
1276         \textcolor{comment}{// printTokens(jp);}
1277         \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *key, *value;
1278 
1279         \textcolor{keywordtype}{bool} bResult = jp.getValueTokenByKey(jp.getOuterToken(), \textcolor{stringliteral}{"t3"}, value);
1280         assert(bResult);
1281 
1282         JsonModifier mod(jp);
1283         bResult = mod.startModify(value);
1284         assert(bResult);
1285 
1286         mod.insertValue((\textcolor{keywordtype}{double})12345.6);
1287         mod.finish();
1288 
1289         \textcolor{comment}{// printf("after modify\(\backslash\)n");}
1290         \textcolor{comment}{// printTokens(jp);}
1291 
1292         String s;
1293         \textcolor{keywordtype}{int} intValue;
1294         \textcolor{keywordtype}{float} floatValue;
1295         \textcolor{keywordtype}{double} doubleValue;
1296         \textcolor{keywordtype}{bool} boolValue;
1297 
1298         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 0));
1299         \textcolor{comment}{//printf("key: start=%d end=%d\(\backslash\)n", key->start, key->end);}
1300         \textcolor{comment}{//printf("value: start=%d end=%d\(\backslash\)n", value->start, value->end);}
1301         assert(jp.getTokenValue(key, s));
1302         assert(s == \textcolor{stringliteral}{"t1"});
1303 
1304         assert(jp.getTokenValue(value, s));
1305         assert(s == \textcolor{stringliteral}{"abc"});
1306 
1307         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 1));
1308         assert(jp.getTokenValue(value, intValue));
1309         assert(intValue == 1234);
1310 
1311         assert(jp.getTokenValue(key, s));
1312         assert(s== \textcolor{stringliteral}{"t2"});
1313 
1314         assert(jp.getValueByKey(jp.getOuterObject(), \textcolor{stringliteral}{"t2"}, intValue));
1315         assert(intValue == 1234);
1316 
1317         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 2));
1318         assert(jp.getTokenValue(value, doubleValue));
1319         assert(doubleValue == 12345.6);
1320 
1321         assert(jp.getValueTokenByKey(jp.getOuterObject(), \textcolor{stringliteral}{"t3"}, value));
1322         assert(jp.getTokenValue(value, doubleValue));
1323         assert(doubleValue == 12345.6);
1324 
1325         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 3));
1326         assert(jp.getTokenValue(key, s));
1327         assert(s == \textcolor{stringliteral}{"t4"});
1328         assert(jp.getTokenValue(value, boolValue));
1329         assert(boolValue);
1330 
1331         assert(jp.getValueTokenByKey(jp.getOuterObject(), \textcolor{stringliteral}{"t4"}, value));
1332         assert(jp.getTokenValue(value, boolValue));
1333         assert(boolValue);
1334 
1335         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 4));
1336         assert(jp.getTokenValue(key, s));
1337         assert(s == \textcolor{stringliteral}{"t5"});
1338         assert(jp.getTokenValue(value, boolValue));
1339         assert(!boolValue);
1340 
1341         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 6));
1342         assert(jp.getTokenValue(key, s));
1343         assert(s == \textcolor{stringliteral}{"t7"});
1344 
1345         assert(jp.getTokenValue(value, s));
1346         assert(s == \textcolor{stringliteral}{"\(\backslash\)"quoted\(\backslash\)""});
1347     \}
1348 
1349     \textcolor{comment}{// Array test low-level findLeftCommand. findRightComma}
1350     \{
1351         JsonParserStatic<512, 32> jp;
1352 
1353         jp.addString(\textcolor{stringliteral}{"[1, 2 , 3]"});
1354 
1355         jp.parse();
1356 
1357         \textcolor{comment}{//printTokens(jp);}
1358 
1359         JsonModifier mod(jp);
1360 
1361         \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *arrayToken = jp.getOuterArray();
1362 
1363         \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *tok;
1364 
1365         tok = jp.getTokenByIndex(arrayToken, 0);
1366         assert(mod.findLeftComma(tok) == -1);
1367         assert(mod.findRightComma(tok) == 2);
1368 
1369         tok = jp.getTokenByIndex(arrayToken, 1);
1370         assert(mod.findLeftComma(tok) == 2);
1371         assert(mod.findRightComma(tok) == 6);
1372 
1373         tok = jp.getTokenByIndex(arrayToken, 2);
1374         assert(mod.findLeftComma(tok) == 6);
1375         assert(mod.findRightComma(tok) == -1);
1376 
1377         mod.removeArrayIndex(arrayToken, 0);
1378         \textcolor{comment}{// printTokens(jp);}
1379 
1380         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *expected = \textcolor{stringliteral}{"[ 2 , 3]"};
1381         assertJsonParserBuffer(jp, expected);
1382 
1383         mod.removeArrayIndex(arrayToken, 1);
1384         \textcolor{comment}{// printTokens(jp);}
1385 
1386         expected = \textcolor{stringliteral}{"[ 2 ]"};
1387         assertJsonParserBuffer(jp, expected);
1388 
1389         mod.removeArrayIndex(arrayToken, 0);
1390 
1391         expected = \textcolor{stringliteral}{"[  ]"};
1392         assertJsonParserBuffer(jp, expected);
1393 
1394         arrayToken = jp.getOuterArray();
1395         mod.startAppend(arrayToken);
1396 
1397         mod.insertCheckSeparator();
1398         mod.insertValue(4);
1399 
1400         mod.finish();
1401         \textcolor{comment}{//printTokens(jp);}
1402 
1403         expected = \textcolor{stringliteral}{"[  4]"};
1404         assertJsonParserBuffer(jp, expected);
1405 
1406         mod.startAppend(arrayToken);
1407 
1408         mod.insertCheckSeparator();
1409         mod.insertValue(5);
1410 
1411         mod.finish();
1412         \textcolor{comment}{//printTokens(jp);}
1413 
1414         expected = \textcolor{stringliteral}{"[  4,5]"};
1415         assertJsonParserBuffer(jp, expected);
1416 
1417     \}
1418 
1419     \textcolor{comment}{// Array test low-level findLeftCommand. findRightComma with strings}
1420     \{
1421         JsonParserStatic<512, 32> jp;
1422 
1423         jp.addString(\textcolor{stringliteral}{"[\(\backslash\)"a\(\backslash\)", \(\backslash\)"b\(\backslash\)" ,\(\backslash\)"c\(\backslash\)" ]"});
1424 
1425         jp.parse();
1426 
1427         \textcolor{comment}{//printTokens(jp);}
1428 
1429         JsonModifier mod(jp);
1430 
1431         \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *arrayToken = jp.getOuterArray();
1432 
1433         \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *tok;
1434 
1435         tok = jp.getTokenByIndex(arrayToken, 0);
1436         assert(mod.findLeftComma(tok) == -1);
1437         assert(mod.findRightComma(tok) == 4);
1438 
1439         tok = jp.getTokenByIndex(arrayToken, 1);
1440         assert(mod.findLeftComma(tok) == 4);
1441         assert(mod.findRightComma(tok) == 10);
1442 
1443         tok = jp.getTokenByIndex(arrayToken, 2);
1444         assert(mod.findLeftComma(tok) == 10);
1445         assert(mod.findRightComma(tok) == -1);
1446 
1447         mod.removeArrayIndex(arrayToken, 0);
1448         \textcolor{comment}{// printTokens(jp);}
1449 
1450         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *expected = \textcolor{stringliteral}{"[ \(\backslash\)"b\(\backslash\)" ,\(\backslash\)"c\(\backslash\)" ]"};
1451         assertJsonParserBuffer(jp, expected);
1452 
1453         mod.removeArrayIndex(arrayToken, 0);
1454         expected = \textcolor{stringliteral}{"[ \(\backslash\)"c\(\backslash\)" ]"};
1455         assertJsonParserBuffer(jp, expected);
1456 
1457         mod.removeArrayIndex(arrayToken, 0);
1458         expected = \textcolor{stringliteral}{"[  ]"};
1459         assertJsonParserBuffer(jp, expected);
1460         \textcolor{comment}{// printTokens(jp);}
1461 
1462         arrayToken = jp.getOuterArray();
1463         mod.startAppend(arrayToken);
1464 
1465         \textcolor{comment}{//mod.insertCheckSeparator();}
1466         mod.insertArrayValue(\textcolor{stringliteral}{"d"});
1467 
1468         mod.finish();
1469         \textcolor{comment}{//printTokens(jp);}
1470 
1471         expected = \textcolor{stringliteral}{"[  \(\backslash\)"d\(\backslash\)"]"};
1472         assertJsonParserBuffer(jp, expected);
1473 
1474         mod.startAppend(arrayToken);
1475 
1476         mod.insertArrayValue(\textcolor{stringliteral}{"e"});
1477 
1478         mod.finish();
1479         \textcolor{comment}{// printTokens(jp);}
1480 
1481         expected = \textcolor{stringliteral}{"[  \(\backslash\)"d\(\backslash\)",\(\backslash\)"e\(\backslash\)"]"};
1482         assertJsonParserBuffer(jp, expected);
1483 
1484     \}
1485 
1486     \textcolor{comment}{// Object test removeKeyValue insertKeyValue}
1487     \textcolor{comment}{// Note: uses low-level API, probably best to use insertOrUpdateKeyValue in most code}
1488     \{
1489         JsonParserStatic<512, 32> jp;
1490 
1491         jp.addString(\textcolor{stringliteral}{"\{\(\backslash\)"a\(\backslash\)":1, \(\backslash\)"b\(\backslash\)":\(\backslash\)"x\(\backslash\)" ,\(\backslash\)"c\(\backslash\)":3 \}"});
1492 
1493         jp.parse();
1494 
1495         \textcolor{comment}{//printTokens(jp);}
1496 
1497         JsonModifier mod(jp);
1498 
1499         mod.removeKeyValue(jp.getOuterObject(), \textcolor{stringliteral}{"a"});
1500 
1501         \textcolor{comment}{//printTokens(jp);}
1502         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *expected = \textcolor{stringliteral}{"\{ \(\backslash\)"b\(\backslash\)":\(\backslash\)"x\(\backslash\)" ,\(\backslash\)"c\(\backslash\)":3 \}"};
1503         assertJsonParserBuffer(jp, expected);
1504 
1505         mod.removeKeyValue(jp.getOuterObject(), \textcolor{stringliteral}{"c"});
1506 
1507         \textcolor{comment}{//printTokens(jp);}
1508         expected = \textcolor{stringliteral}{"\{ \(\backslash\)"b\(\backslash\)":\(\backslash\)"x\(\backslash\)"  \}"};
1509         assertJsonParserBuffer(jp, expected);
1510 
1511         mod.removeKeyValue(jp.getOuterObject(), \textcolor{stringliteral}{"b"});
1512 
1513         \textcolor{comment}{//printTokens(jp);}
1514         expected = \textcolor{stringliteral}{"\{   \}"};
1515         assertJsonParserBuffer(jp, expected);
1516 
1517 
1518         mod.startAppend(jp.getOuterObject());
1519 
1520         mod.insertKeyValue(\textcolor{stringliteral}{"d"}, (\textcolor{keywordtype}{int})4);
1521 
1522         mod.finish();
1523         \textcolor{comment}{//printTokens(jp);}
1524         expected = \textcolor{stringliteral}{"\{   \(\backslash\)"d\(\backslash\)":4\}"};
1525         assertJsonParserBuffer(jp, expected);
1526 
1527 
1528         mod.startAppend(jp.getOuterObject());
1529 
1530         mod.insertKeyValue(\textcolor{stringliteral}{"e"}, \textcolor{stringliteral}{"test"});
1531 
1532         mod.finish();
1533         \textcolor{comment}{//printTokens(jp);}
1534         expected = \textcolor{stringliteral}{"\{   \(\backslash\)"d\(\backslash\)":4,\(\backslash\)"e\(\backslash\)":\(\backslash\)"test\(\backslash\)"\}"};
1535         assertJsonParserBuffer(jp, expected);
1536     \}
1537 
1538     \textcolor{comment}{// High level insertOrUpdateKeyValue API test}
1539     \{
1540         JsonParserStatic<512, 32> jp;
1541 
1542         jp.addString(\textcolor{stringliteral}{"\{\}"});
1543 
1544         jp.parse();
1545 
1546         \textcolor{comment}{//printTokens(jp);}
1547 
1548         JsonModifier mod(jp);
1549 
1550         mod.insertOrUpdateKeyValue(jp.getOuterObject(), \textcolor{stringliteral}{"a"}, (int)1);
1551 
1552         \textcolor{comment}{// printTokens(jp);}
1553 
1554         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *expected = \textcolor{stringliteral}{"\{\(\backslash\)"a\(\backslash\)":1\}"};
1555         assertJsonParserBuffer(jp, expected);
1556 
1557         mod.insertOrUpdateKeyValue(jp.getOuterObject(), \textcolor{stringliteral}{"b"}, \textcolor{stringliteral}{"x"});
1558 
1559         \textcolor{comment}{// printTokens(jp);}
1560 
1561         expected = \textcolor{stringliteral}{"\{\(\backslash\)"a\(\backslash\)":1,\(\backslash\)"b\(\backslash\)":\(\backslash\)"x\(\backslash\)"\}"};
1562         assertJsonParserBuffer(jp, expected);
1563 
1564         mod.insertOrUpdateKeyValue(jp.getOuterObject(), \textcolor{stringliteral}{"b"}, \textcolor{stringliteral}{"xxx"});
1565 
1566         \textcolor{comment}{// printTokens(jp);}
1567 
1568         expected = \textcolor{stringliteral}{"\{\(\backslash\)"a\(\backslash\)":1,\(\backslash\)"b\(\backslash\)":\(\backslash\)"xxx\(\backslash\)"\}"};
1569         assertJsonParserBuffer(jp, expected);
1570 
1571         \textcolor{comment}{// Updating a value will reorder the keys in the object}
1572         mod.insertOrUpdateKeyValue(jp.getOuterObject(), \textcolor{stringliteral}{"a"}, (int)999);
1573 
1574         expected = \textcolor{stringliteral}{"\{\(\backslash\)"b\(\backslash\)":\(\backslash\)"xxx\(\backslash\)",\(\backslash\)"a\(\backslash\)":999\}"};
1575         assertJsonParserBuffer(jp, expected);
1576 
1577         \textcolor{comment}{// String to number}
1578         mod.insertOrUpdateKeyValue(jp.getOuterObject(), \textcolor{stringliteral}{"b"}, (int)123);
1579 
1580         expected = \textcolor{stringliteral}{"\{\(\backslash\)"a\(\backslash\)":999,\(\backslash\)"b\(\backslash\)":123\}"};
1581         assertJsonParserBuffer(jp, expected);
1582 
1583         \textcolor{comment}{// Number to string}
1584         mod.insertOrUpdateKeyValue(jp.getOuterObject(), \textcolor{stringliteral}{"b"}, \textcolor{stringliteral}{"x"});
1585 
1586         expected = \textcolor{stringliteral}{"\{\(\backslash\)"a\(\backslash\)":999,\(\backslash\)"b\(\backslash\)":\(\backslash\)"x\(\backslash\)"\}"};
1587         assertJsonParserBuffer(jp, expected);
1588 
1589         \textcolor{comment}{// bool}
1590         mod.insertOrUpdateKeyValue(jp.getOuterObject(), \textcolor{stringliteral}{"c"}, \textcolor{keyword}{true});
1591 
1592         expected = \textcolor{stringliteral}{"\{\(\backslash\)"a\(\backslash\)":999,\(\backslash\)"b\(\backslash\)":\(\backslash\)"x\(\backslash\)",\(\backslash\)"c\(\backslash\)":true\}"};
1593         assertJsonParserBuffer(jp, expected);
1594 
1595         \textcolor{comment}{// float}
1596         mod.insertOrUpdateKeyValue(jp.getOuterObject(), \textcolor{stringliteral}{"d"}, 3.5);
1597 
1598         expected = \textcolor{stringliteral}{"\{\(\backslash\)"a\(\backslash\)":999,\(\backslash\)"b\(\backslash\)":\(\backslash\)"x\(\backslash\)",\(\backslash\)"c\(\backslash\)":true,\(\backslash\)"d\(\backslash\)":3.500000\}"};
1599         assertJsonParserBuffer(jp, expected);
1600 
1601     \}
1602 
1603     \textcolor{comment}{// High level appendArrayValue API test}
1604     \{
1605         JsonParserStatic<512, 32> jp;
1606 
1607         jp.addString(\textcolor{stringliteral}{"[]"});
1608 
1609         jp.parse();
1610 
1611         \textcolor{comment}{// printTokens(jp);}
1612 
1613         JsonModifier mod(jp);
1614 
1615         mod.appendArrayValue(jp.getOuterArray(), (int)1);
1616 
1617         \textcolor{comment}{// printTokens(jp);}
1618 
1619         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *expected = \textcolor{stringliteral}{"[1]"};
1620         assertJsonParserBuffer(jp, expected);
1621 
1622 
1623         mod.appendArrayValue(jp.getOuterArray(), (int)2);
1624 
1625         \textcolor{comment}{//printTokens(jp);}
1626 
1627         expected = \textcolor{stringliteral}{"[1,2]"};
1628         assertJsonParserBuffer(jp, expected);
1629 
1630         mod.appendArrayValue(jp.getOuterArray(), (float)3.5);
1631 
1632         \textcolor{comment}{//printTokens(jp);}
1633 
1634         expected = \textcolor{stringliteral}{"[1,2,3.500000]"};
1635         assertJsonParserBuffer(jp, expected);
1636 
1637         mod.appendArrayValue(jp.getOuterArray(), (bool)\textcolor{keyword}{true});
1638 
1639         \textcolor{comment}{//printTokens(jp);}
1640 
1641         expected = \textcolor{stringliteral}{"[1,2,3.500000,true]"};
1642         assertJsonParserBuffer(jp, expected);
1643 
1644         mod.appendArrayValue(jp.getOuterArray(), \textcolor{stringliteral}{"xxx"});
1645 
1646         \textcolor{comment}{// printTokens(jp);}
1647 
1648         expected = \textcolor{stringliteral}{"[1,2,3.500000,true,\(\backslash\)"xxx\(\backslash\)"]"};
1649         assertJsonParserBuffer(jp, expected);
1650 
1651     \}
1652 
1653     \textcolor{comment}{// Array in object test}
1654     \{
1655         JsonParserStatic<512, 32> jp;
1656 
1657         jp.addString(\textcolor{stringliteral}{"\{\(\backslash\)"t2\(\backslash\)":\{\(\backslash\)"a\(\backslash\)":\(\backslash\)"foo\(\backslash\)"\},\(\backslash\)"t3\(\backslash\)":[1, 2, 3]\}"});
1658 
1659         jp.parse();
1660 
1661         JsonModifier mod(jp);
1662 
1663         \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *arrayToken = 0;
1664         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *expected;
1665 
1666         \textcolor{keywordtype}{bool} bResult = jp.getValueTokenByKey(jp.getOuterObject(), \textcolor{stringliteral}{"t3"}, arrayToken);
1667         assert(bResult);
1668         assert(arrayToken);
1669 
1670         mod.appendArrayValue(arrayToken, 4);
1671 
1672         expected = \textcolor{stringliteral}{"\{\(\backslash\)"t2\(\backslash\)":\{\(\backslash\)"a\(\backslash\)":\(\backslash\)"foo\(\backslash\)"\},\(\backslash\)"t3\(\backslash\)":[1, 2, 3,4]\}"};
1673         assertJsonParserBuffer(jp, expected);
1674     \}
1675 
1676     \textcolor{comment}{// Object in object test}
1677     \{
1678         JsonParserStatic<512, 32> jp;
1679 
1680         jp.addString(\textcolor{stringliteral}{"\{\(\backslash\)"t2\(\backslash\)":\{\(\backslash\)"a\(\backslash\)":\(\backslash\)"foo\(\backslash\)"\},\(\backslash\)"t3\(\backslash\)":[1, 2, 3]\}"});
1681 
1682         jp.parse();
1683 
1684         JsonModifier mod(jp);
1685 
1686         \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *t2Token = 0;
1687         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *expected;
1688 
1689         \textcolor{keywordtype}{bool} bResult = jp.getValueTokenByKey(jp.getOuterObject(), \textcolor{stringliteral}{"t2"}, t2Token);
1690         assert(bResult);
1691         assert(t2Token);
1692 
1693         mod.insertOrUpdateKeyValue(t2Token, \textcolor{stringliteral}{"b"}, \textcolor{stringliteral}{"xxx"});
1694 
1695         expected = \textcolor{stringliteral}{"\{\(\backslash\)"t2\(\backslash\)":\{\(\backslash\)"a\(\backslash\)":\(\backslash\)"foo\(\backslash\)",\(\backslash\)"b\(\backslash\)":\(\backslash\)"xxx\(\backslash\)"\},\(\backslash\)"t3\(\backslash\)":[1, 2, 3]\}"};
1696         assertJsonParserBuffer(jp, expected);
1697 
1698 
1699         jp.getValueTokenByKey(jp.getOuterObject(), \textcolor{stringliteral}{"t2"}, t2Token);
1700         mod.insertOrUpdateKeyValue(t2Token, \textcolor{stringliteral}{"b"}, \textcolor{stringliteral}{"x"});
1701 
1702         expected = \textcolor{stringliteral}{"\{\(\backslash\)"t2\(\backslash\)":\{\(\backslash\)"a\(\backslash\)":\(\backslash\)"foo\(\backslash\)",\(\backslash\)"b\(\backslash\)":\(\backslash\)"x\(\backslash\)"\},\(\backslash\)"t3\(\backslash\)":[1, 2, 3]\}"};
1703         assertJsonParserBuffer(jp, expected);
1704 
1705         jp.getValueTokenByKey(jp.getOuterObject(), \textcolor{stringliteral}{"t2"}, t2Token);
1706         mod.insertOrUpdateKeyValue(t2Token, \textcolor{stringliteral}{"a"}, (\textcolor{keywordtype}{int})5);
1707 
1708         expected = \textcolor{stringliteral}{"\{\(\backslash\)"t2\(\backslash\)":\{\(\backslash\)"b\(\backslash\)":\(\backslash\)"x\(\backslash\)",\(\backslash\)"a\(\backslash\)":5\},\(\backslash\)"t3\(\backslash\)":[1, 2, 3]\}"};
1709         assertJsonParserBuffer(jp, expected);
1710     \}
1711 
1712     \textcolor{comment}{// Append an object to an array}
1713     \{
1714         JsonParserStatic<512, 32> jp;
1715 
1716         jp.addString(\textcolor{stringliteral}{"[]"});
1717 
1718         jp.parse();
1719 
1720         JsonModifier mod(jp);
1721 
1722         \textcolor{comment}{//printTokens(jp);}
1723 
1724         mod.startAppend(jp.getOuterArray());
1725 
1726         mod.startObject();
1727 
1728         mod.insertKeyValue(\textcolor{stringliteral}{"a"}, (\textcolor{keywordtype}{int})1);
1729         mod.insertKeyValue(\textcolor{stringliteral}{"b"}, (\textcolor{keywordtype}{bool})\textcolor{keyword}{false});
1730         mod.insertKeyValue(\textcolor{stringliteral}{"c"}, \textcolor{stringliteral}{"x"});
1731 
1732         mod.finishObjectOrArray();
1733 
1734         mod.finish();
1735 
1736         \textcolor{comment}{//printTokens(jp);}
1737 
1738         \textcolor{keyword}{const} \textcolor{keywordtype}{char} *expected;
1739         expected = \textcolor{stringliteral}{"[\{\(\backslash\)"a\(\backslash\)":1,\(\backslash\)"b\(\backslash\)":false,\(\backslash\)"c\(\backslash\)":\(\backslash\)"x\(\backslash\)"\}]"};
1740         assertJsonParserBuffer(jp, expected);
1741 
1742         \textcolor{comment}{// Add another item to the array}
1743         mod.startAppend(jp.getOuterArray());
1744 
1745         mod.startObject();
1746 
1747         mod.insertKeyValue(\textcolor{stringliteral}{"a"}, (\textcolor{keywordtype}{int})999);
1748 
1749         mod.finishObjectOrArray();
1750 
1751         mod.finish();
1752 
1753         \textcolor{comment}{//printTokens(jp);}
1754 
1755         expected = \textcolor{stringliteral}{"[\{\(\backslash\)"a\(\backslash\)":1,\(\backslash\)"b\(\backslash\)":false,\(\backslash\)"c\(\backslash\)":\(\backslash\)"x\(\backslash\)"\},\{\(\backslash\)"a\(\backslash\)":999\}]"};
1756         assertJsonParserBuffer(jp, expected);
1757 
1758     \}
1759 
1760     \textcolor{comment}{// Append an array to an object}
1761     \{
1762         JsonParserStatic<512, 32> jp;
1763 
1764         jp.addString(\textcolor{stringliteral}{"\{\}"});
1765 
1766         jp.parse();
1767 
1768         JsonModifier mod(jp);
1769 
1770         mod.startAppend(jp.getOuterObject());
1771 
1772         mod.insertKeyArray(\textcolor{stringliteral}{"a"});
1773 
1774         mod.insertArrayValue(1);
1775         mod.insertArrayValue(2);
1776         mod.insertArrayValue(3);
1777 
1778         mod.finishObjectOrArray();
1779 
1780         mod.finish();
1781 
1782         \textcolor{comment}{//printTokens(jp);}
1783         assertJsonParserBuffer(jp, \textcolor{stringliteral}{"\{\(\backslash\)"a\(\backslash\)":[1,2,3]\}"});
1784 
1785         \textcolor{comment}{// Add another object to the array}
1786 
1787         mod.startAppend(jp.getOuterObject());
1788 
1789         mod.insertKeyArray(\textcolor{stringliteral}{"b"});
1790 
1791         mod.insertArrayValue(\textcolor{stringliteral}{"test"});
1792 
1793         mod.finishObjectOrArray();
1794 
1795         mod.finish();
1796 
1797         \textcolor{comment}{//printTokens(jp);}
1798 
1799         assertJsonParserBuffer(jp, \textcolor{stringliteral}{"\{\(\backslash\)"a\(\backslash\)":[1,2,3],\(\backslash\)"b\(\backslash\)":[\(\backslash\)"test\(\backslash\)"]\}"});
1800 
1801         \textcolor{comment}{// Add a simple value to the object}
1802         mod.insertOrUpdateKeyValue(jp.getOuterObject(), \textcolor{stringliteral}{"c"}, \textcolor{stringliteral}{"xxx"});
1803 
1804         assertJsonParserBuffer(jp, \textcolor{stringliteral}{"\{\(\backslash\)"a\(\backslash\)":[1,2,3],\(\backslash\)"b\(\backslash\)":[\(\backslash\)"test\(\backslash\)"],\(\backslash\)"c\(\backslash\)":\(\backslash\)"xxx\(\backslash\)"\}"});
1805 
1806         \textcolor{comment}{//printTokens(jp);}
1807 
1808         \textcolor{comment}{// Change an array value to a simple value}
1809         mod.insertOrUpdateKeyValue(jp.getOuterObject(), \textcolor{stringliteral}{"b"}, (int)99);
1810 
1811         assertJsonParserBuffer(jp, \textcolor{stringliteral}{"\{\(\backslash\)"a\(\backslash\)":[1,2,3],\(\backslash\)"c\(\backslash\)":\(\backslash\)"xxx\(\backslash\)",\(\backslash\)"b\(\backslash\)":99\}"});
1812 
1813     \}
1814 
1815 \}
\end{DoxyCode}
\mbox{\label{_json_test_8cpp_ae269cd10672ea800dd6fd6f14e48d0f8}} 
\index{Json\+Test.\+cpp@{Json\+Test.\+cpp}!print\+Indent@{print\+Indent}}
\index{print\+Indent@{print\+Indent}!Json\+Test.\+cpp@{Json\+Test.\+cpp}}
\subsubsection{print\+Indent()}
{\footnotesize\ttfamily void print\+Indent (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{indent }\end{DoxyParamCaption})}



Definition at line 1861 of file Json\+Test.\+cpp.



Referenced by print\+Json\+Inner().


\begin{DoxyCode}
1861                                 \{
1862     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} ii = 0; ii < 2 * indent; ii++) \{
1863         printf(\textcolor{stringliteral}{" "});
1864     \}
1865 \}
\end{DoxyCode}
\mbox{\label{_json_test_8cpp_aa852eb9203676959147483523ec49997}} 
\index{Json\+Test.\+cpp@{Json\+Test.\+cpp}!print\+Json@{print\+Json}}
\index{print\+Json@{print\+Json}!Json\+Test.\+cpp@{Json\+Test.\+cpp}}
\subsubsection{print\+Json()}
{\footnotesize\ttfamily void print\+Json (\begin{DoxyParamCaption}\item[{\textbf{ Json\+Parser} \&}]{jp }\end{DoxyParamCaption})}



Definition at line 1963 of file Json\+Test.\+cpp.



References Json\+Parser\+::get\+Outer\+Token(), and print\+Json\+Inner().



Referenced by subscription\+Handler().


\begin{DoxyCode}
1963                                \{
1964     printJsonInner(jp, jp.getOuterToken(), 0);
1965 \}
\end{DoxyCode}
\mbox{\label{_json_test_8cpp_a7a86f133587ae90abe048be568db828f}} 
\index{Json\+Test.\+cpp@{Json\+Test.\+cpp}!print\+Json\+Inner@{print\+Json\+Inner}}
\index{print\+Json\+Inner@{print\+Json\+Inner}!Json\+Test.\+cpp@{Json\+Test.\+cpp}}
\subsubsection{print\+Json\+Inner()}
{\footnotesize\ttfamily void print\+Json\+Inner (\begin{DoxyParamCaption}\item[{\textbf{ Json\+Parser} \&}]{jp,  }\item[{const \textbf{ Json\+Parser\+Generator\+R\+K\+::jsmntok\+\_\+t} $\ast$}]{container,  }\item[{size\+\_\+t}]{indent }\end{DoxyParamCaption})}



Definition at line 1889 of file Json\+Test.\+cpp.



References Json\+Parser\+Generator\+R\+K\+::jsmntok\+\_\+t\+::end, Json\+Buffer\+::get\+Buffer(), Json\+Parser\+::get\+Key\+Value\+Token\+By\+Index(), Json\+Parser\+::get\+Token\+Value(), Json\+Parser\+::get\+Value\+Token\+By\+Index(), Json\+Parser\+Generator\+R\+K\+::\+J\+S\+M\+N\+\_\+\+A\+R\+R\+AY, Json\+Parser\+Generator\+R\+K\+::\+J\+S\+M\+N\+\_\+\+O\+B\+J\+E\+CT, Json\+Parser\+Generator\+R\+K\+::\+J\+S\+M\+N\+\_\+\+P\+R\+I\+M\+I\+T\+I\+VE, Json\+Parser\+Generator\+R\+K\+::\+J\+S\+M\+N\+\_\+\+S\+T\+R\+I\+NG, Json\+Parser\+Generator\+R\+K\+::\+J\+S\+M\+N\+\_\+\+U\+N\+D\+E\+F\+I\+N\+ED, print\+Indent(), print\+Json\+Inner(), print\+String(), Json\+Parser\+Generator\+R\+K\+::jsmntok\+\_\+t\+::start, and Json\+Parser\+Generator\+R\+K\+::jsmntok\+\_\+t\+::type.



Referenced by print\+Json(), and print\+Json\+Inner().


\begin{DoxyCode}
1889                                                                                                     \{
1890 
1891     \textcolor{keywordflow}{switch}(container->type) \{
1892     \textcolor{keywordflow}{case} JsonParserGeneratorRK::JSMN_OBJECT: \{
1893         printIndent(indent);
1894         printf(\textcolor{stringliteral}{"\{\(\backslash\)n"});
1895 
1896         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} ii = 0; ; ii++) \{
1897             \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *keyToken;
1898             \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *valueToken;
1899 
1900             \textcolor{keywordflow}{if} (!jp.getKeyValueTokenByIndex(container, keyToken, valueToken, ii)) \{
1901                 \textcolor{keywordflow}{break};
1902             \}
1903             \textcolor{keywordflow}{if} (ii > 0) \{
1904                 printf(\textcolor{stringliteral}{",\(\backslash\)n"});
1905             \}
1906 
1907             String keyName;
1908             jp.getTokenValue(keyToken, keyName);
1909 
1910             printIndent(indent + 1);
1911             printString(keyName);
1912             printf(\textcolor{stringliteral}{":"});
1913             printJsonInner(jp, valueToken, indent + 1);
1914         \}
1915         printf(\textcolor{stringliteral}{"\(\backslash\)n"});
1916         printIndent(indent);
1917         printf(\textcolor{stringliteral}{"\}\(\backslash\)n"});
1918         \textcolor{keywordflow}{break};
1919     \}
1920     \textcolor{keywordflow}{case} JsonParserGeneratorRK::JSMN_ARRAY: \{
1921         printIndent(indent);
1922         printf(\textcolor{stringliteral}{"[\(\backslash\)n"});
1923 
1924         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} ii = 0; ; ii++) \{
1925             \textcolor{keyword}{const} JsonParserGeneratorRK::jsmntok_t *valueToken;
1926 
1927             \textcolor{keywordflow}{if} (!jp.getValueTokenByIndex(container, ii, valueToken)) \{
1928                 \textcolor{keywordflow}{break};
1929             \}
1930             \textcolor{keywordflow}{if} (ii > 0) \{
1931                 printf(\textcolor{stringliteral}{",\(\backslash\)n"});
1932             \}
1933             printIndent(indent + 1);
1934             printJsonInner(jp, valueToken, indent + 1);
1935         \}
1936         printf(\textcolor{stringliteral}{"\(\backslash\)n"});
1937         printIndent(indent);
1938         printf(\textcolor{stringliteral}{"]\(\backslash\)n"});
1939         \textcolor{keywordflow}{break};
1940     \}
1941     \textcolor{keywordflow}{case} JsonParserGeneratorRK::JSMN_STRING: \{
1942         printf(\textcolor{stringliteral}{"\(\backslash\)""});
1943         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} ii = container->start; ii < container->end; ii++) \{
1944             printf(\textcolor{stringliteral}{"%c"}, jp.getBuffer()[ii]);
1945         \}
1946         printf(\textcolor{stringliteral}{"\(\backslash\)""});
1947         \textcolor{keywordflow}{break};
1948     \}
1949     \textcolor{keywordflow}{case} JsonParserGeneratorRK::JSMN_PRIMITIVE: \{
1950         \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} ii = container->start; ii < container->end; ii++) \{
1951             printf(\textcolor{stringliteral}{"%c"}, jp.getBuffer()[ii]);
1952         \}
1953         \textcolor{keywordflow}{break};
1954     \}
1955     \textcolor{keywordflow}{case} JsonParserGeneratorRK::JSMN_UNDEFINED:
1956     \textcolor{keywordflow}{default}: \{
1957         \textcolor{keywordflow}{break};
1958     \}
1959     \}
1960 
1961 \}
\end{DoxyCode}
\mbox{\label{_json_test_8cpp_abe6d5621640c26d89a09be56928cd923}} 
\index{Json\+Test.\+cpp@{Json\+Test.\+cpp}!print\+String@{print\+String}}
\index{print\+String@{print\+String}!Json\+Test.\+cpp@{Json\+Test.\+cpp}}
\subsubsection{print\+String()}
{\footnotesize\ttfamily void print\+String (\begin{DoxyParamCaption}\item[{const char $\ast$}]{str }\end{DoxyParamCaption})}



Definition at line 1867 of file Json\+Test.\+cpp.



Referenced by print\+Json\+Inner().


\begin{DoxyCode}
1867                                   \{
1868     printf(\textcolor{stringliteral}{"\(\backslash\)""});
1869 
1870     \textcolor{keywordflow}{for}(\textcolor{keywordtype}{size\_t} ii = 0; str[ii]; ii++) \{
1871         \textcolor{keywordflow}{if} (str[ii] == \textcolor{charliteral}{'"'}) \{
1872             printf(\textcolor{stringliteral}{"\(\backslash\)\(\backslash\)\(\backslash\)""});
1873         \}
1874         \textcolor{keywordflow}{else}
1875         \textcolor{keywordflow}{if} (str[ii] == \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'}) \{
1876             printf(\textcolor{stringliteral}{"\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)"});
1877         \}
1878         \textcolor{keywordflow}{else}
1879         \textcolor{keywordflow}{if} (str[ii] >= 32 && str[ii] < 127) \{
1880             printf(\textcolor{stringliteral}{"%c"}, str[ii]);
1881         \}
1882         \textcolor{keywordflow}{else} \{
1883             printf(\textcolor{stringliteral}{"\(\backslash\)\(\backslash\)x%02x"}, str[ii]);
1884         \}
1885     \}
1886     printf(\textcolor{stringliteral}{"\(\backslash\)""});
1887 \}
\end{DoxyCode}
\mbox{\label{_json_test_8cpp_a7e1fe2b914cc5ce32aed1deeb1c4ddbd}} 
\index{Json\+Test.\+cpp@{Json\+Test.\+cpp}!print\+Token@{print\+Token}}
\index{print\+Token@{print\+Token}!Json\+Test.\+cpp@{Json\+Test.\+cpp}}
\subsubsection{print\+Token()}
{\footnotesize\ttfamily void print\+Token (\begin{DoxyParamCaption}\item[{\textbf{ Json\+Parser} \&}]{jp,  }\item[{const \textbf{ Json\+Parser\+Generator\+R\+K\+::jsmntok\+\_\+t} $\ast$}]{tok }\end{DoxyParamCaption})}



Definition at line 1827 of file Json\+Test.\+cpp.



References Json\+Parser\+Generator\+R\+K\+::jsmntok\+\_\+t\+::end, Json\+Buffer\+::get\+Buffer(), Json\+Parser\+Generator\+R\+K\+::\+J\+S\+M\+N\+\_\+\+A\+R\+R\+AY, Json\+Parser\+Generator\+R\+K\+::\+J\+S\+M\+N\+\_\+\+O\+B\+J\+E\+CT, Json\+Parser\+Generator\+R\+K\+::\+J\+S\+M\+N\+\_\+\+P\+R\+I\+M\+I\+T\+I\+VE, Json\+Parser\+Generator\+R\+K\+::\+J\+S\+M\+N\+\_\+\+S\+T\+R\+I\+NG, Json\+Parser\+Generator\+R\+K\+::\+J\+S\+M\+N\+\_\+\+U\+N\+D\+E\+F\+I\+N\+ED, Json\+Parser\+Generator\+R\+K\+::jsmntok\+\_\+t\+::size, Json\+Parser\+Generator\+R\+K\+::jsmntok\+\_\+t\+::start, and Json\+Parser\+Generator\+R\+K\+::jsmntok\+\_\+t\+::type.



Referenced by print\+Tokens().


\begin{DoxyCode}
1827                                                                            \{
1828     \textcolor{keywordtype}{char} tempBuf[1024];
1829 
1830     \textcolor{keyword}{const} \textcolor{keywordtype}{char} *typeName = \textcolor{stringliteral}{"UNKNOWN"};
1831     \textcolor{keywordflow}{switch}(tok->type) \{
1832     \textcolor{keywordflow}{case} JsonParserGeneratorRK::JSMN_UNDEFINED:
1833         typeName = \textcolor{stringliteral}{"UNDEFINED"};
1834         \textcolor{keywordflow}{break};
1835 
1836     \textcolor{keywordflow}{case} JsonParserGeneratorRK::JSMN_OBJECT:
1837         typeName = \textcolor{stringliteral}{"OBJECT"};
1838         \textcolor{keywordflow}{break};
1839 
1840     \textcolor{keywordflow}{case} JsonParserGeneratorRK::JSMN_ARRAY:
1841         typeName = \textcolor{stringliteral}{"ARRAY"};
1842         \textcolor{keywordflow}{break};
1843 
1844     \textcolor{keywordflow}{case} JsonParserGeneratorRK::JSMN_STRING:
1845         typeName = \textcolor{stringliteral}{"STRING"};
1846         \textcolor{keywordflow}{break};
1847 
1848     \textcolor{keywordflow}{case} JsonParserGeneratorRK::JSMN_PRIMITIVE:
1849         typeName = \textcolor{stringliteral}{"PRIMITIVE"};
1850         \textcolor{keywordflow}{break};
1851     \}
1852 
1853     memcpy(tempBuf, jp.getBuffer() + tok->start, tok->end - tok->start);
1854     tempBuf[tok->end - tok->start] = 0;
1855 
1856     printf(\textcolor{stringliteral}{"type=%s start=%d end=%d size=%d %s\(\backslash\)n"}, typeName, tok->start, tok->
      end, tok->size, tempBuf);
1857 \}
\end{DoxyCode}
\mbox{\label{_json_test_8cpp_a3c76ffaf6c0f5a9674b5e0d0011de388}} 
\index{Json\+Test.\+cpp@{Json\+Test.\+cpp}!print\+Tokens@{print\+Tokens}}
\index{print\+Tokens@{print\+Tokens}!Json\+Test.\+cpp@{Json\+Test.\+cpp}}
\subsubsection{print\+Tokens()}
{\footnotesize\ttfamily void print\+Tokens (\begin{DoxyParamCaption}\item[{\textbf{ Json\+Parser} \&}]{jp }\end{DoxyParamCaption})}



Definition at line 1818 of file Json\+Test.\+cpp.



References Json\+Parser\+::get\+Tokens(), Json\+Parser\+::get\+Tokens\+End(), and print\+Token().


\begin{DoxyCode}
1818                                  \{
1819     JsonParserGeneratorRK::jsmntok_t *tokensEnd = jp.getTokensEnd();
1820 
1821     \textcolor{keywordflow}{for}(JsonParserGeneratorRK::jsmntok_t *tok = jp.getTokens(); tok < tokensEnd; tok++) \{
1822         printToken(jp, tok);
1823     \}
1824 
1825 \}
\end{DoxyCode}
\mbox{\label{_json_test_8cpp_a8d4e253ece41d6e85125ce277ed1deea}} 
\index{Json\+Test.\+cpp@{Json\+Test.\+cpp}!read\+Test\+Data@{read\+Test\+Data}}
\index{read\+Test\+Data@{read\+Test\+Data}!Json\+Test.\+cpp@{Json\+Test.\+cpp}}
\subsubsection{read\+Test\+Data()}
{\footnotesize\ttfamily char$\ast$ read\+Test\+Data (\begin{DoxyParamCaption}\item[{const char $\ast$}]{filename }\end{DoxyParamCaption})}



Definition at line 8 of file Json\+Test.\+cpp.



Referenced by main().


\begin{DoxyCode}
8                                          \{
9     \textcolor{keywordtype}{char} *data;
10 
11     FILE *fd = fopen(filename, \textcolor{stringliteral}{"r"});
12     \textcolor{keywordflow}{if} (!fd) \{
13         printf(\textcolor{stringliteral}{"failed to open %s"}, filename);
14         \textcolor{keywordflow}{return} 0;
15     \}
16 
17     fseek(fd, 0, SEEK\_END);
18     \textcolor{keywordtype}{size\_t} size = ftell(fd);
19     fseek(fd, 0, SEEK\_SET);
20 
21     data = (\textcolor{keywordtype}{char} *) malloc(size + 1);
22     fread(data, 1, size, fd);
23     data[size] = 0;
24 
25     fclose(fd);
26 
27     \textcolor{keywordflow}{return} data;
28 \}
\end{DoxyCode}
