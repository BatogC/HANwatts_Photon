\section{M\+F\+R\+C522 Class Reference}
\label{class_m_f_r_c522}\index{M\+F\+R\+C522@{M\+F\+R\+C522}}


{\ttfamily \#include $<$M\+F\+R\+C522.\+h$>$}



Collaboration diagram for M\+F\+R\+C522\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=163pt]{class_m_f_r_c522__coll__graph}
\end{center}
\end{figure}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \textbf{ M\+I\+F\+A\+R\+E\+\_\+\+Key}
\item 
struct \textbf{ Uid}
\end{DoxyCompactItemize}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \textbf{ P\+C\+D\+\_\+\+Register} \{ \newline
\textbf{ Command\+Reg} = 0x01 $<$$<$ 1, 
\textbf{ Com\+I\+En\+Reg} = 0x02 $<$$<$ 1, 
\textbf{ Div\+I\+En\+Reg} = 0x03 $<$$<$ 1, 
\textbf{ Com\+Irq\+Reg} = 0x04 $<$$<$ 1, 
\newline
\textbf{ Div\+Irq\+Reg} = 0x05 $<$$<$ 1, 
\textbf{ Error\+Reg} = 0x06 $<$$<$ 1, 
\textbf{ Status1\+Reg} = 0x07 $<$$<$ 1, 
\textbf{ Status2\+Reg} = 0x08 $<$$<$ 1, 
\newline
\textbf{ F\+I\+F\+O\+Data\+Reg} = 0x09 $<$$<$ 1, 
\textbf{ F\+I\+F\+O\+Level\+Reg} = 0x0A $<$$<$ 1, 
\textbf{ Water\+Level\+Reg} = 0x0B $<$$<$ 1, 
\textbf{ Control\+Reg} = 0x0C $<$$<$ 1, 
\newline
\textbf{ Bit\+Framing\+Reg} = 0x0D $<$$<$ 1, 
\textbf{ Coll\+Reg} = 0x0E $<$$<$ 1, 
\textbf{ Mode\+Reg} = 0x11 $<$$<$ 1, 
\textbf{ Tx\+Mode\+Reg} = 0x12 $<$$<$ 1, 
\newline
\textbf{ Rx\+Mode\+Reg} = 0x13 $<$$<$ 1, 
\textbf{ Tx\+Control\+Reg} = 0x14 $<$$<$ 1, 
\textbf{ Tx\+A\+S\+K\+Reg} = 0x15 $<$$<$ 1, 
\textbf{ Tx\+Sel\+Reg} = 0x16 $<$$<$ 1, 
\newline
\textbf{ Rx\+Sel\+Reg} = 0x17 $<$$<$ 1, 
\textbf{ Rx\+Threshold\+Reg} = 0x18 $<$$<$ 1, 
\textbf{ Demod\+Reg} = 0x19 $<$$<$ 1, 
\textbf{ Mf\+Tx\+Reg} = 0x1C $<$$<$ 1, 
\newline
\textbf{ Mf\+Rx\+Reg} = 0x1D $<$$<$ 1, 
\textbf{ Serial\+Speed\+Reg} = 0x1F $<$$<$ 1, 
\textbf{ C\+R\+C\+Result\+RegH} = 0x21 $<$$<$ 1, 
\textbf{ C\+R\+C\+Result\+RegL} = 0x22 $<$$<$ 1, 
\newline
\textbf{ Mod\+Width\+Reg} = 0x24 $<$$<$ 1, 
\textbf{ R\+F\+Cfg\+Reg} = 0x26 $<$$<$ 1, 
\textbf{ Gs\+N\+Reg} = 0x27 $<$$<$ 1, 
\textbf{ C\+W\+Gs\+P\+Reg} = 0x28 $<$$<$ 1, 
\newline
\textbf{ Mod\+Gs\+P\+Reg} = 0x29 $<$$<$ 1, 
\textbf{ T\+Mode\+Reg} = 0x2A $<$$<$ 1, 
\textbf{ T\+Prescaler\+Reg} = 0x2B $<$$<$ 1, 
\textbf{ T\+Reload\+RegH} = 0x2C $<$$<$ 1, 
\newline
\textbf{ T\+Reload\+RegL} = 0x2D $<$$<$ 1, 
\textbf{ T\+Counter\+Value\+RegH} = 0x2E $<$$<$ 1, 
\textbf{ T\+Counter\+Value\+RegL} = 0x2F $<$$<$ 1, 
\textbf{ Test\+Sel1\+Reg} = 0x31 $<$$<$ 1, 
\newline
\textbf{ Test\+Sel2\+Reg} = 0x32 $<$$<$ 1, 
\textbf{ Test\+Pin\+En\+Reg} = 0x33 $<$$<$ 1, 
\textbf{ Test\+Pin\+Value\+Reg} = 0x34 $<$$<$ 1, 
\textbf{ Test\+Bus\+Reg} = 0x35 $<$$<$ 1, 
\newline
\textbf{ Auto\+Test\+Reg} = 0x36 $<$$<$ 1, 
\textbf{ Version\+Reg} = 0x37 $<$$<$ 1, 
\textbf{ Analog\+Test\+Reg} = 0x38 $<$$<$ 1, 
\textbf{ Test\+D\+A\+C1\+Reg} = 0x39 $<$$<$ 1, 
\newline
\textbf{ Test\+D\+A\+C2\+Reg} = 0x3A $<$$<$ 1, 
\textbf{ Test\+A\+D\+C\+Reg} = 0x3B $<$$<$ 1
 \}
\item 
enum \textbf{ P\+C\+D\+\_\+\+Command} \{ \newline
\textbf{ P\+C\+D\+\_\+\+Idle} = 0x00, 
\textbf{ P\+C\+D\+\_\+\+Mem} = 0x01, 
\textbf{ P\+C\+D\+\_\+\+Generate\+Random\+ID} = 0x02, 
\textbf{ P\+C\+D\+\_\+\+Calc\+C\+RC} = 0x03, 
\newline
\textbf{ P\+C\+D\+\_\+\+Transmit} = 0x04, 
\textbf{ P\+C\+D\+\_\+\+No\+Cmd\+Change} = 0x07, 
\textbf{ P\+C\+D\+\_\+\+Receive} = 0x08, 
\textbf{ P\+C\+D\+\_\+\+Transceive} = 0x0C, 
\newline
\textbf{ P\+C\+D\+\_\+\+M\+F\+Authent} = 0x0E, 
\textbf{ P\+C\+D\+\_\+\+Soft\+Reset} = 0x0F
 \}
\item 
enum \textbf{ P\+C\+D\+\_\+\+Rx\+Gain} \{ \newline
\textbf{ Rx\+Gain\+\_\+18dB} = 0x00 $<$$<$ 4, 
\textbf{ Rx\+Gain\+\_\+23dB} = 0x01 $<$$<$ 4, 
\textbf{ Rx\+Gain\+\_\+18d\+B\+\_\+2} = 0x02 $<$$<$ 4, 
\textbf{ Rx\+Gain\+\_\+23d\+B\+\_\+2} = 0x03 $<$$<$ 4, 
\newline
\textbf{ Rx\+Gain\+\_\+33dB} = 0x04 $<$$<$ 4, 
\textbf{ Rx\+Gain\+\_\+38dB} = 0x05 $<$$<$ 4, 
\textbf{ Rx\+Gain\+\_\+43dB} = 0x06 $<$$<$ 4, 
\textbf{ Rx\+Gain\+\_\+48dB} = 0x07 $<$$<$ 4, 
\newline
\textbf{ Rx\+Gain\+\_\+min} = 0x00 $<$$<$ 4, 
\textbf{ Rx\+Gain\+\_\+avg} = 0x04 $<$$<$ 4, 
\textbf{ Rx\+Gain\+\_\+max} = 0x07 $<$$<$ 4
 \}
\item 
enum \textbf{ P\+I\+C\+C\+\_\+\+Command} \{ \newline
\textbf{ P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+R\+E\+QA} = 0x26, 
\textbf{ P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+W\+U\+PA} = 0x52, 
\textbf{ P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+CT} = 0x88, 
\textbf{ P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+S\+E\+L\+\_\+\+C\+L1} = 0x93, 
\newline
\textbf{ P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+S\+E\+L\+\_\+\+C\+L2} = 0x95, 
\textbf{ P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+S\+E\+L\+\_\+\+C\+L3} = 0x97, 
\textbf{ P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+H\+L\+TA} = 0x50, 
\textbf{ P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+A\+U\+T\+H\+\_\+\+K\+E\+Y\+\_\+A} = 0x60, 
\newline
\textbf{ P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+A\+U\+T\+H\+\_\+\+K\+E\+Y\+\_\+B} = 0x61, 
\textbf{ P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+R\+E\+AD} = 0x30, 
\textbf{ P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+W\+R\+I\+TE} = 0x\+A0, 
\textbf{ P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+D\+E\+C\+R\+E\+M\+E\+NT} = 0x\+C0, 
\newline
\textbf{ P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+I\+N\+C\+R\+E\+M\+E\+NT} = 0x\+C1, 
\textbf{ P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+R\+E\+S\+T\+O\+RE} = 0x\+C2, 
\textbf{ P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+T\+R\+A\+N\+S\+F\+ER} = 0x\+B0, 
\textbf{ P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+U\+L\+\_\+\+W\+R\+I\+TE} = 0x\+A2
 \}
\item 
enum \textbf{ M\+I\+F\+A\+R\+E\+\_\+\+Misc} \{ \textbf{ M\+F\+\_\+\+A\+CK} = 0xA, 
\textbf{ M\+F\+\_\+\+K\+E\+Y\+\_\+\+S\+I\+ZE} = 6
 \}
\item 
enum \textbf{ P\+I\+C\+C\+\_\+\+Type} \{ \newline
\textbf{ P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+U\+N\+K\+N\+O\+WN} = 0, 
\textbf{ P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+I\+S\+O\+\_\+14443\+\_\+4} = 1, 
\textbf{ P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+I\+S\+O\+\_\+18092} = 2, 
\textbf{ P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+M\+I\+NI} = 3, 
\newline
\textbf{ P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+1K} = 4, 
\textbf{ P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+4K} = 5, 
\textbf{ P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+UL} = 6, 
\textbf{ P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+P\+L\+US} = 7, 
\newline
\textbf{ P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+T\+N\+P3\+X\+XX} = 8, 
\textbf{ P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+N\+O\+T\+\_\+\+C\+O\+M\+P\+L\+E\+TE} = 255
 \}
\item 
enum \textbf{ Status\+Code} \{ \newline
\textbf{ S\+T\+A\+T\+U\+S\+\_\+\+OK} = 1, 
\textbf{ S\+T\+A\+T\+U\+S\+\_\+\+E\+R\+R\+OR} = 2, 
\textbf{ S\+T\+A\+T\+U\+S\+\_\+\+C\+O\+L\+L\+I\+S\+I\+ON} = 3, 
\textbf{ S\+T\+A\+T\+U\+S\+\_\+\+T\+I\+M\+E\+O\+UT} = 4, 
\newline
\textbf{ S\+T\+A\+T\+U\+S\+\_\+\+N\+O\+\_\+\+R\+O\+OM} = 5, 
\textbf{ S\+T\+A\+T\+U\+S\+\_\+\+I\+N\+T\+E\+R\+N\+A\+L\+\_\+\+E\+R\+R\+OR} = 6, 
\textbf{ S\+T\+A\+T\+U\+S\+\_\+\+I\+N\+V\+A\+L\+ID} = 7, 
\textbf{ S\+T\+A\+T\+U\+S\+\_\+\+C\+R\+C\+\_\+\+W\+R\+O\+NG} = 8, 
\newline
\textbf{ S\+T\+A\+T\+U\+S\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+N\+A\+CK} = 9
 \}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ M\+F\+R\+C522} (byte chip\+Select\+Pin, byte reset\+Power\+Down\+Pin)
\item 
void \textbf{ set\+S\+P\+I\+Config} ()
\item 
void \textbf{ P\+C\+D\+\_\+\+Write\+Register} (byte reg, byte value)
\item 
void \textbf{ P\+C\+D\+\_\+\+Write\+Register} (byte reg, byte count, byte $\ast$values)
\item 
byte \textbf{ P\+C\+D\+\_\+\+Read\+Register} (byte reg)
\item 
void \textbf{ P\+C\+D\+\_\+\+Read\+Register} (byte reg, byte count, byte $\ast$values, byte rx\+Align=0)
\item 
void \textbf{ set\+Bit\+Mask} (unsigned char reg, unsigned char mask)
\item 
void \textbf{ P\+C\+D\+\_\+\+Set\+Register\+Bit\+Mask} (byte reg, byte mask)
\item 
void \textbf{ P\+C\+D\+\_\+\+Clear\+Register\+Bit\+Mask} (byte reg, byte mask)
\item 
byte \textbf{ P\+C\+D\+\_\+\+Calculate\+C\+RC} (byte $\ast$data, byte length, byte $\ast$result)
\item 
void \textbf{ P\+C\+D\+\_\+\+Init} ()
\item 
void \textbf{ P\+C\+D\+\_\+\+Reset} ()
\item 
void \textbf{ P\+C\+D\+\_\+\+Antenna\+On} ()
\item 
void \textbf{ P\+C\+D\+\_\+\+Antenna\+Off} ()
\item 
byte \textbf{ P\+C\+D\+\_\+\+Get\+Antenna\+Gain} ()
\item 
void \textbf{ P\+C\+D\+\_\+\+Set\+Antenna\+Gain} (byte mask)
\item 
byte \textbf{ P\+C\+D\+\_\+\+Transceive\+Data} (byte $\ast$send\+Data, byte send\+Len, byte $\ast$back\+Data, byte $\ast$back\+Len, byte $\ast$valid\+Bits=N\+U\+LL, byte rx\+Align=0, bool check\+C\+RC=false)
\item 
byte \textbf{ P\+C\+D\+\_\+\+Communicate\+With\+P\+I\+CC} (byte command, byte wait\+I\+Rq, byte $\ast$send\+Data, byte send\+Len, byte $\ast$back\+Data=N\+U\+LL, byte $\ast$back\+Len=N\+U\+LL, byte $\ast$valid\+Bits=N\+U\+LL, byte rx\+Align=0, bool check\+C\+RC=false)
\item 
byte \textbf{ P\+I\+C\+C\+\_\+\+RequestA} (byte $\ast$buffer\+A\+T\+QA, byte $\ast$buffer\+Size)
\item 
byte \textbf{ P\+I\+C\+C\+\_\+\+WakeupA} (byte $\ast$buffer\+A\+T\+QA, byte $\ast$buffer\+Size)
\item 
byte \textbf{ P\+I\+C\+C\+\_\+\+R\+E\+Q\+A\+\_\+or\+\_\+\+W\+U\+PA} (byte command, byte $\ast$buffer\+A\+T\+QA, byte $\ast$buffer\+Size)
\item 
byte \textbf{ P\+I\+C\+C\+\_\+\+Select} (\textbf{ Uid} $\ast$\textbf{ uid}, byte valid\+Bits=0)
\item 
byte \textbf{ P\+I\+C\+C\+\_\+\+HaltA} ()
\item 
byte \textbf{ P\+C\+D\+\_\+\+Authenticate} (byte command, byte block\+Addr, \textbf{ M\+I\+F\+A\+R\+E\+\_\+\+Key} $\ast$key, \textbf{ Uid} $\ast$\textbf{ uid})
\item 
void \textbf{ P\+C\+D\+\_\+\+Stop\+Crypto1} ()
\item 
byte \textbf{ M\+I\+F\+A\+R\+E\+\_\+\+Read} (byte block\+Addr, byte $\ast$buffer, byte $\ast$buffer\+Size)
\item 
byte \textbf{ M\+I\+F\+A\+R\+E\+\_\+\+Write} (byte block\+Addr, byte $\ast$buffer, byte buffer\+Size)
\item 
byte \textbf{ M\+I\+F\+A\+R\+E\+\_\+\+Decrement} (byte block\+Addr, long delta)
\item 
byte \textbf{ M\+I\+F\+A\+R\+E\+\_\+\+Increment} (byte block\+Addr, long delta)
\item 
byte \textbf{ M\+I\+F\+A\+R\+E\+\_\+\+Restore} (byte block\+Addr)
\item 
byte \textbf{ M\+I\+F\+A\+R\+E\+\_\+\+Transfer} (byte block\+Addr)
\item 
byte \textbf{ M\+I\+F\+A\+R\+E\+\_\+\+Ultralight\+\_\+\+Write} (byte page, byte $\ast$buffer, byte buffer\+Size)
\item 
byte \textbf{ M\+I\+F\+A\+R\+E\+\_\+\+Get\+Value} (byte block\+Addr, long $\ast$value)
\item 
byte \textbf{ M\+I\+F\+A\+R\+E\+\_\+\+Set\+Value} (byte block\+Addr, long value)
\item 
byte \textbf{ P\+C\+D\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+Transceive} (byte $\ast$send\+Data, byte send\+Len, bool accept\+Timeout=false)
\item 
const char $\ast$ \textbf{ Get\+Status\+Code\+Name} (byte code)
\item 
byte \textbf{ P\+I\+C\+C\+\_\+\+Get\+Type} (byte sak)
\item 
const char $\ast$ \textbf{ P\+I\+C\+C\+\_\+\+Get\+Type\+Name} (byte type)
\item 
void \textbf{ P\+I\+C\+C\+\_\+\+Dump\+To\+Serial} (\textbf{ Uid} $\ast$\textbf{ uid})
\item 
void \textbf{ P\+I\+C\+C\+\_\+\+Dump\+Mifare\+Classic\+To\+Serial} (\textbf{ Uid} $\ast$\textbf{ uid}, byte picc\+Type, \textbf{ M\+I\+F\+A\+R\+E\+\_\+\+Key} $\ast$key)
\item 
void \textbf{ P\+I\+C\+C\+\_\+\+Dump\+Mifare\+Classic\+Sector\+To\+Serial} (\textbf{ Uid} $\ast$\textbf{ uid}, \textbf{ M\+I\+F\+A\+R\+E\+\_\+\+Key} $\ast$key, byte sector)
\item 
void \textbf{ P\+I\+C\+C\+\_\+\+Dump\+Mifare\+Ultralight\+To\+Serial} ()
\item 
void \textbf{ M\+I\+F\+A\+R\+E\+\_\+\+Set\+Access\+Bits} (byte $\ast$access\+Bit\+Buffer, byte g0, byte g1, byte g2, byte g3)
\item 
bool \textbf{ M\+I\+F\+A\+R\+E\+\_\+\+Open\+Uid\+Backdoor} (bool log\+Errors)
\item 
bool \textbf{ M\+I\+F\+A\+R\+E\+\_\+\+Set\+Uid} (byte $\ast$new\+Uid, byte uid\+Size, bool log\+Errors)
\item 
bool \textbf{ M\+I\+F\+A\+R\+E\+\_\+\+Unbrick\+Uid\+Sector} (bool log\+Errors)
\item 
bool \textbf{ P\+I\+C\+C\+\_\+\+Is\+New\+Card\+Present} ()
\item 
bool \textbf{ P\+I\+C\+C\+\_\+\+Read\+Card\+Serial} ()
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\textbf{ Uid} \textbf{ uid}
\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const byte \textbf{ F\+I\+F\+O\+\_\+\+S\+I\+ZE} = 64
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
byte \textbf{ M\+I\+F\+A\+R\+E\+\_\+\+Two\+Step\+Helper} (byte command, byte block\+Addr, long data)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
byte \textbf{ \+\_\+chip\+Select\+Pin}
\item 
byte \textbf{ \+\_\+reset\+Power\+Down\+Pin}
\end{DoxyCompactItemize}


\subsection{Detailed Description}


Definition at line 86 of file M\+F\+R\+C522.\+h.



\subsection{Member Enumeration Documentation}
\mbox{\label{class_m_f_r_c522_a92c17a5b83cc4fde3cc3454c03b8eede}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!M\+I\+F\+A\+R\+E\+\_\+\+Misc@{M\+I\+F\+A\+R\+E\+\_\+\+Misc}}
\index{M\+I\+F\+A\+R\+E\+\_\+\+Misc@{M\+I\+F\+A\+R\+E\+\_\+\+Misc}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{M\+I\+F\+A\+R\+E\+\_\+\+Misc}
{\footnotesize\ttfamily enum \textbf{ M\+F\+R\+C522\+::\+M\+I\+F\+A\+R\+E\+\_\+\+Misc}}

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{M\+F\+\_\+\+A\+CK@{M\+F\+\_\+\+A\+CK}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!M\+F\+\_\+\+A\+CK@{M\+F\+\_\+\+A\+CK}}}\mbox{\label{class_m_f_r_c522_a92c17a5b83cc4fde3cc3454c03b8eedea3b5fce9bf15481d218872d4584743a1c}} 
M\+F\+\_\+\+A\+CK&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{M\+F\+\_\+\+K\+E\+Y\+\_\+\+S\+I\+ZE@{M\+F\+\_\+\+K\+E\+Y\+\_\+\+S\+I\+ZE}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!M\+F\+\_\+\+K\+E\+Y\+\_\+\+S\+I\+ZE@{M\+F\+\_\+\+K\+E\+Y\+\_\+\+S\+I\+ZE}}}\mbox{\label{class_m_f_r_c522_a92c17a5b83cc4fde3cc3454c03b8eedea410c51021b253b680b7ec518ccc818ce}} 
M\+F\+\_\+\+K\+E\+Y\+\_\+\+S\+I\+ZE&\\
\hline

\end{DoxyEnumFields}


Definition at line 221 of file M\+F\+R\+C522.\+h.


\begin{DoxyCode}
221                      \{
222         MF_ACK                  = 0xA,      \textcolor{comment}{// The MIFARE Classic uses a 4 bit ACK/NAK. Any other value
       than 0xA is NAK.}
223         MF_KEY_SIZE             = 6         \textcolor{comment}{// A Mifare Crypto1 key is 6 bytes.}
224     \};
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a973011639bbee6ad7035ae4dd49e2e07}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Command@{P\+C\+D\+\_\+\+Command}}
\index{P\+C\+D\+\_\+\+Command@{P\+C\+D\+\_\+\+Command}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+C\+D\+\_\+\+Command}
{\footnotesize\ttfamily enum \textbf{ M\+F\+R\+C522\+::\+P\+C\+D\+\_\+\+Command}}

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+C\+D\+\_\+\+Idle@{P\+C\+D\+\_\+\+Idle}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Idle@{P\+C\+D\+\_\+\+Idle}}}\mbox{\label{class_m_f_r_c522_a973011639bbee6ad7035ae4dd49e2e07afe5ffdce88fe7544cbc49f8947df9ad9}} 
P\+C\+D\+\_\+\+Idle&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+C\+D\+\_\+\+Mem@{P\+C\+D\+\_\+\+Mem}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Mem@{P\+C\+D\+\_\+\+Mem}}}\mbox{\label{class_m_f_r_c522_a973011639bbee6ad7035ae4dd49e2e07a2f3a9f820c74cb11fabdc00e20c7e2fe}} 
P\+C\+D\+\_\+\+Mem&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+C\+D\+\_\+\+Generate\+Random\+ID@{P\+C\+D\+\_\+\+Generate\+Random\+ID}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Generate\+Random\+ID@{P\+C\+D\+\_\+\+Generate\+Random\+ID}}}\mbox{\label{class_m_f_r_c522_a973011639bbee6ad7035ae4dd49e2e07a3b9535f3e1eb589c05ca9f22f380647a}} 
P\+C\+D\+\_\+\+Generate\+Random\+ID&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+C\+D\+\_\+\+Calc\+C\+RC@{P\+C\+D\+\_\+\+Calc\+C\+RC}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Calc\+C\+RC@{P\+C\+D\+\_\+\+Calc\+C\+RC}}}\mbox{\label{class_m_f_r_c522_a973011639bbee6ad7035ae4dd49e2e07a61d1786d5518a1ad71aac8413941f0ac}} 
P\+C\+D\+\_\+\+Calc\+C\+RC&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+C\+D\+\_\+\+Transmit@{P\+C\+D\+\_\+\+Transmit}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Transmit@{P\+C\+D\+\_\+\+Transmit}}}\mbox{\label{class_m_f_r_c522_a973011639bbee6ad7035ae4dd49e2e07af91e3fb8471c0953d69b83b1baf55ae1}} 
P\+C\+D\+\_\+\+Transmit&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+C\+D\+\_\+\+No\+Cmd\+Change@{P\+C\+D\+\_\+\+No\+Cmd\+Change}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+No\+Cmd\+Change@{P\+C\+D\+\_\+\+No\+Cmd\+Change}}}\mbox{\label{class_m_f_r_c522_a973011639bbee6ad7035ae4dd49e2e07a2d0df8c6384dd59ad6276510b4fe992d}} 
P\+C\+D\+\_\+\+No\+Cmd\+Change&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+C\+D\+\_\+\+Receive@{P\+C\+D\+\_\+\+Receive}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Receive@{P\+C\+D\+\_\+\+Receive}}}\mbox{\label{class_m_f_r_c522_a973011639bbee6ad7035ae4dd49e2e07a2ec760e26c27fff63bebee7e9cf844e7}} 
P\+C\+D\+\_\+\+Receive&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+C\+D\+\_\+\+Transceive@{P\+C\+D\+\_\+\+Transceive}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Transceive@{P\+C\+D\+\_\+\+Transceive}}}\mbox{\label{class_m_f_r_c522_a973011639bbee6ad7035ae4dd49e2e07af0b7178e7638038db6f8e7016892fafd}} 
P\+C\+D\+\_\+\+Transceive&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+C\+D\+\_\+\+M\+F\+Authent@{P\+C\+D\+\_\+\+M\+F\+Authent}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+M\+F\+Authent@{P\+C\+D\+\_\+\+M\+F\+Authent}}}\mbox{\label{class_m_f_r_c522_a973011639bbee6ad7035ae4dd49e2e07a903753278eed75d5d1af2390649ec0c2}} 
P\+C\+D\+\_\+\+M\+F\+Authent&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+C\+D\+\_\+\+Soft\+Reset@{P\+C\+D\+\_\+\+Soft\+Reset}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Soft\+Reset@{P\+C\+D\+\_\+\+Soft\+Reset}}}\mbox{\label{class_m_f_r_c522_a973011639bbee6ad7035ae4dd49e2e07a8f54a569867f812163c6a9bc3461d03a}} 
P\+C\+D\+\_\+\+Soft\+Reset&\\
\hline

\end{DoxyEnumFields}


Definition at line 165 of file M\+F\+R\+C522.\+h.


\begin{DoxyCode}
165                      \{
166         PCD_Idle                = 0x00,     \textcolor{comment}{// no action, cancels current command execution}
167         PCD_Mem                 = 0x01,     \textcolor{comment}{// stores 25 bytes into the internal buffer}
168         PCD_GenerateRandomID    = 0x02,     \textcolor{comment}{// generates a 10-byte random ID number}
169         PCD_CalcCRC             = 0x03,     \textcolor{comment}{// activates the CRC coprocessor or performs a self test}
170         PCD_Transmit            = 0x04,     \textcolor{comment}{// transmits data from the FIFO buffer}
171         PCD_NoCmdChange         = 0x07,     \textcolor{comment}{// no command change, can be used to modify the CommandReg
       register bits without affecting the command, for example, the PowerDown bit}
172         PCD_Receive             = 0x08,     \textcolor{comment}{// activates the receiver circuits}
173         PCD_Transceive          = 0x0C,     \textcolor{comment}{// transmits data from FIFO buffer to antenna and automatically
       activates the receiver after transmission}
174         PCD_MFAuthent           = 0x0E,     \textcolor{comment}{// performs the MIFARE standard authentication as a reader}
175         PCD_SoftReset           = 0x0F      \textcolor{comment}{// resets the MFRC522}
176     \};
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Register@{P\+C\+D\+\_\+\+Register}}
\index{P\+C\+D\+\_\+\+Register@{P\+C\+D\+\_\+\+Register}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+C\+D\+\_\+\+Register}
{\footnotesize\ttfamily enum \textbf{ M\+F\+R\+C522\+::\+P\+C\+D\+\_\+\+Register}}

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{Command\+Reg@{Command\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Command\+Reg@{Command\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a0ec37643fa721f476b0cd4359e3c7ef1}} 
Command\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Com\+I\+En\+Reg@{Com\+I\+En\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Com\+I\+En\+Reg@{Com\+I\+En\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181ad956725472615518dfb99f2d7dccc50e}} 
Com\+I\+En\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Div\+I\+En\+Reg@{Div\+I\+En\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Div\+I\+En\+Reg@{Div\+I\+En\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181afb4527cc3e364cce3fe3e62cdcde7da0}} 
Div\+I\+En\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Com\+Irq\+Reg@{Com\+Irq\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Com\+Irq\+Reg@{Com\+Irq\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a76b2a615444982e04566784bdb5c9841}} 
Com\+Irq\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Div\+Irq\+Reg@{Div\+Irq\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Div\+Irq\+Reg@{Div\+Irq\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a95e26d5ece97ae43c34d08797205a356}} 
Div\+Irq\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Error\+Reg@{Error\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Error\+Reg@{Error\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a240aa03a1d9542235b89cdef377a5796}} 
Error\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Status1\+Reg@{Status1\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Status1\+Reg@{Status1\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a9f8b10dda6868e74226ab7ccca8d5be0}} 
Status1\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Status2\+Reg@{Status2\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Status2\+Reg@{Status2\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a8fb1a8c28b7a860793831566373f172f}} 
Status2\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{F\+I\+F\+O\+Data\+Reg@{F\+I\+F\+O\+Data\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!F\+I\+F\+O\+Data\+Reg@{F\+I\+F\+O\+Data\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181afdbfd2f397b96d1043c808ec26e80328}} 
F\+I\+F\+O\+Data\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{F\+I\+F\+O\+Level\+Reg@{F\+I\+F\+O\+Level\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!F\+I\+F\+O\+Level\+Reg@{F\+I\+F\+O\+Level\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a35e5daf30358a0a271dadf50ba6bb4e7}} 
F\+I\+F\+O\+Level\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Water\+Level\+Reg@{Water\+Level\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Water\+Level\+Reg@{Water\+Level\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181aee5f7c4d0d34d93e5ac67a47e886b224}} 
Water\+Level\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Control\+Reg@{Control\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Control\+Reg@{Control\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a9d0df9e03ad6706004b003e20127a76a}} 
Control\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Bit\+Framing\+Reg@{Bit\+Framing\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Bit\+Framing\+Reg@{Bit\+Framing\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181aaf8beb5a739cd8bf94b8b5c8d2d109ce}} 
Bit\+Framing\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Coll\+Reg@{Coll\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Coll\+Reg@{Coll\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181afafb7ec88f79c9b1f195195497d0ca07}} 
Coll\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Mode\+Reg@{Mode\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Mode\+Reg@{Mode\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a2cd647ad1ac1327d2a632115cd9c4477}} 
Mode\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Tx\+Mode\+Reg@{Tx\+Mode\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Tx\+Mode\+Reg@{Tx\+Mode\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181ad4fe18ad01abc83d4559369226fe7992}} 
Tx\+Mode\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Rx\+Mode\+Reg@{Rx\+Mode\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Rx\+Mode\+Reg@{Rx\+Mode\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a7e0d6ae1fdd25be6d80d1b76b2274764}} 
Rx\+Mode\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Tx\+Control\+Reg@{Tx\+Control\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Tx\+Control\+Reg@{Tx\+Control\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a73dc12b03f05177a400263e5e2bcf0cc}} 
Tx\+Control\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Tx\+A\+S\+K\+Reg@{Tx\+A\+S\+K\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Tx\+A\+S\+K\+Reg@{Tx\+A\+S\+K\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181ac9de33ca066ca9481bd01d5642a0c879}} 
Tx\+A\+S\+K\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Tx\+Sel\+Reg@{Tx\+Sel\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Tx\+Sel\+Reg@{Tx\+Sel\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a6cf11e077148648aaec0492317be5177}} 
Tx\+Sel\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Rx\+Sel\+Reg@{Rx\+Sel\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Rx\+Sel\+Reg@{Rx\+Sel\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a669c0c9418d5437566b4b42da326c05f}} 
Rx\+Sel\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Rx\+Threshold\+Reg@{Rx\+Threshold\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Rx\+Threshold\+Reg@{Rx\+Threshold\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a50d7af7ddc6c606c2b3b9c07df2f22ab}} 
Rx\+Threshold\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Demod\+Reg@{Demod\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Demod\+Reg@{Demod\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a37b01e93fff19ca62364e8f4f797a5c4}} 
Demod\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Mf\+Tx\+Reg@{Mf\+Tx\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Mf\+Tx\+Reg@{Mf\+Tx\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a08eb51f4d08a41ceb4b34189bb712dc7}} 
Mf\+Tx\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Mf\+Rx\+Reg@{Mf\+Rx\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Mf\+Rx\+Reg@{Mf\+Rx\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a92fbf63612de021d242465d4685f1754}} 
Mf\+Rx\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Serial\+Speed\+Reg@{Serial\+Speed\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Serial\+Speed\+Reg@{Serial\+Speed\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a23529258de3c3f5655afa2849f547f68}} 
Serial\+Speed\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{C\+R\+C\+Result\+RegH@{C\+R\+C\+Result\+RegH}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!C\+R\+C\+Result\+RegH@{C\+R\+C\+Result\+RegH}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a430d34a355d45528d674ad839a187494}} 
C\+R\+C\+Result\+RegH&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{C\+R\+C\+Result\+RegL@{C\+R\+C\+Result\+RegL}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!C\+R\+C\+Result\+RegL@{C\+R\+C\+Result\+RegL}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a4be013336d7bab727dc0e7e150dcd03c}} 
C\+R\+C\+Result\+RegL&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Mod\+Width\+Reg@{Mod\+Width\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Mod\+Width\+Reg@{Mod\+Width\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181ad69a6a3d883ebfc993fc6fbdbc035508}} 
Mod\+Width\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{R\+F\+Cfg\+Reg@{R\+F\+Cfg\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!R\+F\+Cfg\+Reg@{R\+F\+Cfg\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a0c99eea491c71e9d2a02bf8a86988adf}} 
R\+F\+Cfg\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Gs\+N\+Reg@{Gs\+N\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Gs\+N\+Reg@{Gs\+N\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a2f81aa5f433fa51bb4b41cd8955de794}} 
Gs\+N\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{C\+W\+Gs\+P\+Reg@{C\+W\+Gs\+P\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!C\+W\+Gs\+P\+Reg@{C\+W\+Gs\+P\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a02925dc7a230fcf039c597bf8cfa113f}} 
C\+W\+Gs\+P\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Mod\+Gs\+P\+Reg@{Mod\+Gs\+P\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Mod\+Gs\+P\+Reg@{Mod\+Gs\+P\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181acf6ed89766ba2a4e6483b3209b1aa74e}} 
Mod\+Gs\+P\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{T\+Mode\+Reg@{T\+Mode\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!T\+Mode\+Reg@{T\+Mode\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a1ed52e7f88c8bf3fda91bf31bb62afe4}} 
T\+Mode\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{T\+Prescaler\+Reg@{T\+Prescaler\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!T\+Prescaler\+Reg@{T\+Prescaler\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a88c2ad7cdfb7178ea775c157f4ce5213}} 
T\+Prescaler\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{T\+Reload\+RegH@{T\+Reload\+RegH}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!T\+Reload\+RegH@{T\+Reload\+RegH}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181ac9a037a517ada62924c47d5e4b62a14c}} 
T\+Reload\+RegH&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{T\+Reload\+RegL@{T\+Reload\+RegL}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!T\+Reload\+RegL@{T\+Reload\+RegL}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181afa3348d82b026de8fecdd18d58e92e2a}} 
T\+Reload\+RegL&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{T\+Counter\+Value\+RegH@{T\+Counter\+Value\+RegH}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!T\+Counter\+Value\+RegH@{T\+Counter\+Value\+RegH}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181ab32cff60c4488866726d4a3930ad8995}} 
T\+Counter\+Value\+RegH&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{T\+Counter\+Value\+RegL@{T\+Counter\+Value\+RegL}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!T\+Counter\+Value\+RegL@{T\+Counter\+Value\+RegL}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181ad70c519d4928690a1d8e7835532ce146}} 
T\+Counter\+Value\+RegL&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Test\+Sel1\+Reg@{Test\+Sel1\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Test\+Sel1\+Reg@{Test\+Sel1\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a3fd81beec1ed6566ff1897aac235890f}} 
Test\+Sel1\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Test\+Sel2\+Reg@{Test\+Sel2\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Test\+Sel2\+Reg@{Test\+Sel2\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181ac1053bcb64682eba4a767caaea677807}} 
Test\+Sel2\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Test\+Pin\+En\+Reg@{Test\+Pin\+En\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Test\+Pin\+En\+Reg@{Test\+Pin\+En\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a62a7871c0d3452a8f642bbea0ca7cb34}} 
Test\+Pin\+En\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Test\+Pin\+Value\+Reg@{Test\+Pin\+Value\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Test\+Pin\+Value\+Reg@{Test\+Pin\+Value\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181aa5bb4445abb525ddf46c6efcb21e8811}} 
Test\+Pin\+Value\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Test\+Bus\+Reg@{Test\+Bus\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Test\+Bus\+Reg@{Test\+Bus\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a37bc0188996dc1ee5332d40961bffb4b}} 
Test\+Bus\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Auto\+Test\+Reg@{Auto\+Test\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Auto\+Test\+Reg@{Auto\+Test\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a9583618ad17a8a20b7a735c7677c8e56}} 
Auto\+Test\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Version\+Reg@{Version\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Version\+Reg@{Version\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a4281c25cf6743163ed2e2f903cf17ba9}} 
Version\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Analog\+Test\+Reg@{Analog\+Test\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Analog\+Test\+Reg@{Analog\+Test\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181af1d5966b064c10a672e0064d3ccc55c3}} 
Analog\+Test\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Test\+D\+A\+C1\+Reg@{Test\+D\+A\+C1\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Test\+D\+A\+C1\+Reg@{Test\+D\+A\+C1\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a25334abb5ff680a530e95e6fb0e48a5b}} 
Test\+D\+A\+C1\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Test\+D\+A\+C2\+Reg@{Test\+D\+A\+C2\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Test\+D\+A\+C2\+Reg@{Test\+D\+A\+C2\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a505b75aac860302b2959da7fe607e5eb}} 
Test\+D\+A\+C2\+Reg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Test\+A\+D\+C\+Reg@{Test\+A\+D\+C\+Reg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Test\+A\+D\+C\+Reg@{Test\+A\+D\+C\+Reg}}}\mbox{\label{class_m_f_r_c522_ae3b374c61bf50256289349fdb78fe181a1042587aeb71f82f884975ca54c8854a}} 
Test\+A\+D\+C\+Reg&\\
\hline

\end{DoxyEnumFields}


Definition at line 90 of file M\+F\+R\+C522.\+h.


\begin{DoxyCode}
90                       \{
91         \textcolor{comment}{// Page 0: Command and status}
92         \textcolor{comment}{//                        0x00          // reserved for future use}
93         CommandReg              = 0x01 << 1,    \textcolor{comment}{// starts and stops command execution}
94         ComIEnReg               = 0x02 << 1,    \textcolor{comment}{// enable and disable interrupt request control bits}
95         DivIEnReg               = 0x03 << 1,    \textcolor{comment}{// enable and disable interrupt request control bits}
96         ComIrqReg               = 0x04 << 1,    \textcolor{comment}{// interrupt request bits}
97         DivIrqReg               = 0x05 << 1,    \textcolor{comment}{// interrupt request bits}
98         ErrorReg                = 0x06 << 1,    \textcolor{comment}{// error bits showing the error status of the last command
       executed }
99         Status1Reg              = 0x07 << 1,    \textcolor{comment}{// communication status bits}
100         Status2Reg              = 0x08 << 1,    \textcolor{comment}{// receiver and transmitter status bits}
101         FIFODataReg             = 0x09 << 1,    \textcolor{comment}{// input and output of 64 byte FIFO buffer}
102         FIFOLevelReg            = 0x0A << 1,    \textcolor{comment}{// number of bytes stored in the FIFO buffer}
103         WaterLevelReg           = 0x0B << 1,    \textcolor{comment}{// level for FIFO underflow and overflow warning}
104         ControlReg              = 0x0C << 1,    \textcolor{comment}{// miscellaneous control registers}
105         BitFramingReg           = 0x0D << 1,    \textcolor{comment}{// adjustments for bit-oriented frames}
106         CollReg                 = 0x0E << 1,    \textcolor{comment}{// bit position of the first bit-collision detected on the
       RF interface}
107         \textcolor{comment}{//                        0x0F          // reserved for future use}
108         
109         \textcolor{comment}{// Page 1:Command}
110         \textcolor{comment}{//                        0x10          // reserved for future use}
111         ModeReg                 = 0x11 << 1,    \textcolor{comment}{// defines general modes for transmitting and receiving }
112         TxModeReg               = 0x12 << 1,    \textcolor{comment}{// defines transmission data rate and framing}
113         RxModeReg               = 0x13 << 1,    \textcolor{comment}{// defines reception data rate and framing}
114         TxControlReg            = 0x14 << 1,    \textcolor{comment}{// controls the logical behavior of the antenna driver pins
       TX1 and TX2}
115         TxASKReg                = 0x15 << 1,    \textcolor{comment}{// controls the setting of the transmission modulation}
116         TxSelReg                = 0x16 << 1,    \textcolor{comment}{// selects the internal sources for the antenna driver}
117         RxSelReg                = 0x17 << 1,    \textcolor{comment}{// selects internal receiver settings}
118         RxThresholdReg          = 0x18 << 1,    \textcolor{comment}{// selects thresholds for the bit decoder}
119         DemodReg                = 0x19 << 1,    \textcolor{comment}{// defines demodulator settings}
120         \textcolor{comment}{//                        0x1A          // reserved for future use}
121         \textcolor{comment}{//                        0x1B          // reserved for future use}
122         MfTxReg                 = 0x1C << 1,    \textcolor{comment}{// controls some MIFARE communication transmit parameters}
123         MfRxReg                 = 0x1D << 1,    \textcolor{comment}{// controls some MIFARE communication receive parameters}
124         \textcolor{comment}{//                        0x1E          // reserved for future use}
125         SerialSpeedReg          = 0x1F << 1,    \textcolor{comment}{// selects the speed of the serial UART interface}
126         
127         \textcolor{comment}{// Page 2: Configuration}
128         \textcolor{comment}{//                      0x20            // reserved for future use}
129         CRCResultRegH           = 0x21 << 1,    \textcolor{comment}{// shows the MSB and LSB values of the CRC calculation}
130         CRCResultRegL           = 0x22 << 1,
131         \textcolor{comment}{//                        0x23          // reserved for future use}
132         ModWidthReg             = 0x24 << 1,    \textcolor{comment}{// controls the ModWidth setting?}
133         \textcolor{comment}{//                        0x25          // reserved for future use}
134         RFCfgReg                = 0x26 << 1,    \textcolor{comment}{// configures the receiver gain}
135         GsNReg                  = 0x27 << 1,    \textcolor{comment}{// selects the conductance of the antenna driver pins TX1
       and TX2 for modulation }
136         CWGsPReg                = 0x28 << 1,    \textcolor{comment}{// defines the conductance of the p-driver output during
       periods of no modulation}
137         ModGsPReg               = 0x29 << 1,    \textcolor{comment}{// defines the conductance of the p-driver output during
       periods of modulation}
138         TModeReg                = 0x2A << 1,    \textcolor{comment}{// defines settings for the internal timer}
139         TPrescalerReg           = 0x2B << 1,    \textcolor{comment}{// the lower 8 bits of the TPrescaler value. The 4 high
       bits are in TModeReg.}
140         TReloadRegH             = 0x2C << 1,    \textcolor{comment}{// defines the 16-bit timer reload value}
141         TReloadRegL             = 0x2D << 1,
142         TCounterValueRegH       = 0x2E << 1,    \textcolor{comment}{// shows the 16-bit timer value}
143         TCounterValueRegL       = 0x2F << 1,
144         
145         \textcolor{comment}{// Page 3:Test Registers}
146         \textcolor{comment}{//                        0x30          // reserved for future use}
147         TestSel1Reg             = 0x31 << 1,    \textcolor{comment}{// general test signal configuration}
148         TestSel2Reg             = 0x32 << 1,    \textcolor{comment}{// general test signal configuration}
149         TestPinEnReg            = 0x33 << 1,    \textcolor{comment}{// enables pin output driver on pins D1 to D7}
150         TestPinValueReg         = 0x34 << 1,    \textcolor{comment}{// defines the values for D1 to D7 when it is used as an
       I/O bus}
151         TestBusReg              = 0x35 << 1,    \textcolor{comment}{// shows the status of the internal test bus}
152         AutoTestReg             = 0x36 << 1,    \textcolor{comment}{// controls the digital self test}
153         VersionReg              = 0x37 << 1,    \textcolor{comment}{// shows the software version}
154         AnalogTestReg           = 0x38 << 1,    \textcolor{comment}{// controls the pins AUX1 and AUX2}
155         TestDAC1Reg             = 0x39 << 1,    \textcolor{comment}{// defines the test value for TestDAC1}
156         TestDAC2Reg             = 0x3A << 1,    \textcolor{comment}{// defines the test value for TestDAC2}
157         TestADCReg              = 0x3B << 1     \textcolor{comment}{// shows the value of ADC I and Q channels}
158         \textcolor{comment}{//                        0x3C          // reserved for production tests}
159         \textcolor{comment}{//                        0x3D          // reserved for production tests}
160         \textcolor{comment}{//                        0x3E          // reserved for production tests}
161         \textcolor{comment}{//                        0x3F          // reserved for production tests}
162     \};
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_ab7e2bdb063a8ab5f8f29bd05e6867335}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Rx\+Gain@{P\+C\+D\+\_\+\+Rx\+Gain}}
\index{P\+C\+D\+\_\+\+Rx\+Gain@{P\+C\+D\+\_\+\+Rx\+Gain}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+C\+D\+\_\+\+Rx\+Gain}
{\footnotesize\ttfamily enum \textbf{ M\+F\+R\+C522\+::\+P\+C\+D\+\_\+\+Rx\+Gain}}

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{Rx\+Gain\+\_\+18dB@{Rx\+Gain\+\_\+18dB}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Rx\+Gain\+\_\+18dB@{Rx\+Gain\+\_\+18dB}}}\mbox{\label{class_m_f_r_c522_ab7e2bdb063a8ab5f8f29bd05e6867335a4d5e7f6b74ce3912ffdf3305ea263497}} 
Rx\+Gain\+\_\+18dB&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Rx\+Gain\+\_\+23dB@{Rx\+Gain\+\_\+23dB}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Rx\+Gain\+\_\+23dB@{Rx\+Gain\+\_\+23dB}}}\mbox{\label{class_m_f_r_c522_ab7e2bdb063a8ab5f8f29bd05e6867335aab1ac5ba97a5e07ff487f1996352a8e6}} 
Rx\+Gain\+\_\+23dB&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Rx\+Gain\+\_\+18d\+B\+\_\+2@{Rx\+Gain\+\_\+18d\+B\+\_\+2}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Rx\+Gain\+\_\+18d\+B\+\_\+2@{Rx\+Gain\+\_\+18d\+B\+\_\+2}}}\mbox{\label{class_m_f_r_c522_ab7e2bdb063a8ab5f8f29bd05e6867335ac918bee80fae5c763094684ae08bff82}} 
Rx\+Gain\+\_\+18d\+B\+\_\+2&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Rx\+Gain\+\_\+23d\+B\+\_\+2@{Rx\+Gain\+\_\+23d\+B\+\_\+2}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Rx\+Gain\+\_\+23d\+B\+\_\+2@{Rx\+Gain\+\_\+23d\+B\+\_\+2}}}\mbox{\label{class_m_f_r_c522_ab7e2bdb063a8ab5f8f29bd05e6867335ac3b5b39560b326ac91971a41ad167c15}} 
Rx\+Gain\+\_\+23d\+B\+\_\+2&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Rx\+Gain\+\_\+33dB@{Rx\+Gain\+\_\+33dB}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Rx\+Gain\+\_\+33dB@{Rx\+Gain\+\_\+33dB}}}\mbox{\label{class_m_f_r_c522_ab7e2bdb063a8ab5f8f29bd05e6867335a721f1c7082ea232324d8660844996158}} 
Rx\+Gain\+\_\+33dB&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Rx\+Gain\+\_\+38dB@{Rx\+Gain\+\_\+38dB}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Rx\+Gain\+\_\+38dB@{Rx\+Gain\+\_\+38dB}}}\mbox{\label{class_m_f_r_c522_ab7e2bdb063a8ab5f8f29bd05e6867335af2f57fe1d71de1d17204933084649368}} 
Rx\+Gain\+\_\+38dB&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Rx\+Gain\+\_\+43dB@{Rx\+Gain\+\_\+43dB}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Rx\+Gain\+\_\+43dB@{Rx\+Gain\+\_\+43dB}}}\mbox{\label{class_m_f_r_c522_ab7e2bdb063a8ab5f8f29bd05e6867335abc9602260b5733a23e0be7e0c03b1ec9}} 
Rx\+Gain\+\_\+43dB&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Rx\+Gain\+\_\+48dB@{Rx\+Gain\+\_\+48dB}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Rx\+Gain\+\_\+48dB@{Rx\+Gain\+\_\+48dB}}}\mbox{\label{class_m_f_r_c522_ab7e2bdb063a8ab5f8f29bd05e6867335a13227ab5e3143489b0888671d284301b}} 
Rx\+Gain\+\_\+48dB&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Rx\+Gain\+\_\+min@{Rx\+Gain\+\_\+min}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Rx\+Gain\+\_\+min@{Rx\+Gain\+\_\+min}}}\mbox{\label{class_m_f_r_c522_ab7e2bdb063a8ab5f8f29bd05e6867335a97ffca230ea898a78b5734ae0dd44506}} 
Rx\+Gain\+\_\+min&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Rx\+Gain\+\_\+avg@{Rx\+Gain\+\_\+avg}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Rx\+Gain\+\_\+avg@{Rx\+Gain\+\_\+avg}}}\mbox{\label{class_m_f_r_c522_ab7e2bdb063a8ab5f8f29bd05e6867335a2b5b3bd5efdc06adc7c5e190919f5568}} 
Rx\+Gain\+\_\+avg&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Rx\+Gain\+\_\+max@{Rx\+Gain\+\_\+max}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Rx\+Gain\+\_\+max@{Rx\+Gain\+\_\+max}}}\mbox{\label{class_m_f_r_c522_ab7e2bdb063a8ab5f8f29bd05e6867335a3c59e553655b4e44c10d7deef54576a0}} 
Rx\+Gain\+\_\+max&\\
\hline

\end{DoxyEnumFields}


Definition at line 180 of file M\+F\+R\+C522.\+h.


\begin{DoxyCode}
180                     \{
181         RxGain_18dB             = 0x00 << 4,    \textcolor{comment}{// 000b - 18 dB, minimum}
182         RxGain_23dB             = 0x01 << 4,    \textcolor{comment}{// 001b - 23 dB}
183         RxGain_18dB_2           = 0x02 << 4,    \textcolor{comment}{// 010b - 18 dB, it seems 010b is a duplicate for 000b}
184         RxGain_23dB_2           = 0x03 << 4,    \textcolor{comment}{// 011b - 23 dB, it seems 011b is a duplicate for 001b}
185         RxGain_33dB             = 0x04 << 4,    \textcolor{comment}{// 100b - 33 dB, average, and typical default}
186         RxGain_38dB             = 0x05 << 4,    \textcolor{comment}{// 101b - 38 dB}
187         RxGain_43dB             = 0x06 << 4,    \textcolor{comment}{// 110b - 43 dB}
188         RxGain_48dB             = 0x07 << 4,    \textcolor{comment}{// 111b - 48 dB, maximum}
189         RxGain_min              = 0x00 << 4,    \textcolor{comment}{// 000b - 18 dB, minimum, convenience for RxGain\_18dB}
190         RxGain_avg              = 0x04 << 4,    \textcolor{comment}{// 100b - 33 dB, average, convenience for RxGain\_33dB}
191         RxGain_max              = 0x07 << 4     \textcolor{comment}{// 111b - 48 dB, maximum, convenience for RxGain\_48dB}
192     \};
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a5d46a0e2b34b21f51f40ea95795b5e49}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+Command@{P\+I\+C\+C\+\_\+\+Command}}
\index{P\+I\+C\+C\+\_\+\+Command@{P\+I\+C\+C\+\_\+\+Command}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+I\+C\+C\+\_\+\+Command}
{\footnotesize\ttfamily enum \textbf{ M\+F\+R\+C522\+::\+P\+I\+C\+C\+\_\+\+Command}}

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+R\+E\+QA@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+R\+E\+QA}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+R\+E\+QA@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+R\+E\+QA}}}\mbox{\label{class_m_f_r_c522_a5d46a0e2b34b21f51f40ea95795b5e49aee3203a0a40028d3059861464198b688}} 
P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+R\+E\+QA&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+W\+U\+PA@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+W\+U\+PA}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+W\+U\+PA@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+W\+U\+PA}}}\mbox{\label{class_m_f_r_c522_a5d46a0e2b34b21f51f40ea95795b5e49a9b8fbd1c87d0a6bbe2ef78d192001b3a}} 
P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+W\+U\+PA&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+CT@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+CT}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+CT@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+CT}}}\mbox{\label{class_m_f_r_c522_a5d46a0e2b34b21f51f40ea95795b5e49ac532079d67a5325cc5b3505cccf6ac8b}} 
P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+CT&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+S\+E\+L\+\_\+\+C\+L1@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+S\+E\+L\+\_\+\+C\+L1}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+S\+E\+L\+\_\+\+C\+L1@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+S\+E\+L\+\_\+\+C\+L1}}}\mbox{\label{class_m_f_r_c522_a5d46a0e2b34b21f51f40ea95795b5e49aa9329ee8f72f61f5d73bb893b64c08d0}} 
P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+S\+E\+L\+\_\+\+C\+L1&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+S\+E\+L\+\_\+\+C\+L2@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+S\+E\+L\+\_\+\+C\+L2}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+S\+E\+L\+\_\+\+C\+L2@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+S\+E\+L\+\_\+\+C\+L2}}}\mbox{\label{class_m_f_r_c522_a5d46a0e2b34b21f51f40ea95795b5e49ab0399cde7122f0bb6dedb584254455c2}} 
P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+S\+E\+L\+\_\+\+C\+L2&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+S\+E\+L\+\_\+\+C\+L3@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+S\+E\+L\+\_\+\+C\+L3}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+S\+E\+L\+\_\+\+C\+L3@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+S\+E\+L\+\_\+\+C\+L3}}}\mbox{\label{class_m_f_r_c522_a5d46a0e2b34b21f51f40ea95795b5e49a291c265bc0a7b3f303b361582b95cc85}} 
P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+S\+E\+L\+\_\+\+C\+L3&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+H\+L\+TA@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+H\+L\+TA}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+H\+L\+TA@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+H\+L\+TA}}}\mbox{\label{class_m_f_r_c522_a5d46a0e2b34b21f51f40ea95795b5e49ad1e0cf89f52ca1b503297e59c600ca57}} 
P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+H\+L\+TA&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+A\+U\+T\+H\+\_\+\+K\+E\+Y\+\_\+A@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+A\+U\+T\+H\+\_\+\+K\+E\+Y\+\_\+A}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+A\+U\+T\+H\+\_\+\+K\+E\+Y\+\_\+A@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+A\+U\+T\+H\+\_\+\+K\+E\+Y\+\_\+A}}}\mbox{\label{class_m_f_r_c522_a5d46a0e2b34b21f51f40ea95795b5e49a7ab2b1b2d0f0d668dfb3ac53ec7f08d6}} 
P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+A\+U\+T\+H\+\_\+\+K\+E\+Y\+\_\+A&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+A\+U\+T\+H\+\_\+\+K\+E\+Y\+\_\+B@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+A\+U\+T\+H\+\_\+\+K\+E\+Y\+\_\+B}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+A\+U\+T\+H\+\_\+\+K\+E\+Y\+\_\+B@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+A\+U\+T\+H\+\_\+\+K\+E\+Y\+\_\+B}}}\mbox{\label{class_m_f_r_c522_a5d46a0e2b34b21f51f40ea95795b5e49a7b37f0b5fd5406b4cebe306608e5be3f}} 
P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+A\+U\+T\+H\+\_\+\+K\+E\+Y\+\_\+B&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+R\+E\+AD@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+R\+E\+AD}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+R\+E\+AD@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+R\+E\+AD}}}\mbox{\label{class_m_f_r_c522_a5d46a0e2b34b21f51f40ea95795b5e49a2ea95497e35adbc7acbc32c0cb8a574a}} 
P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+R\+E\+AD&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+W\+R\+I\+TE@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+W\+R\+I\+TE}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+W\+R\+I\+TE@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+W\+R\+I\+TE}}}\mbox{\label{class_m_f_r_c522_a5d46a0e2b34b21f51f40ea95795b5e49a02ccb020ccc6d49d563f0ed1489d8025}} 
P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+W\+R\+I\+TE&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+D\+E\+C\+R\+E\+M\+E\+NT@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+D\+E\+C\+R\+E\+M\+E\+NT}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+D\+E\+C\+R\+E\+M\+E\+NT@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+D\+E\+C\+R\+E\+M\+E\+NT}}}\mbox{\label{class_m_f_r_c522_a5d46a0e2b34b21f51f40ea95795b5e49a69b2bb1cd2dc0437d6d1fb11eb2796e7}} 
P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+D\+E\+C\+R\+E\+M\+E\+NT&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+I\+N\+C\+R\+E\+M\+E\+NT@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+I\+N\+C\+R\+E\+M\+E\+NT}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+I\+N\+C\+R\+E\+M\+E\+NT@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+I\+N\+C\+R\+E\+M\+E\+NT}}}\mbox{\label{class_m_f_r_c522_a5d46a0e2b34b21f51f40ea95795b5e49a454e12c2c815a861a0450d40273f98ef}} 
P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+I\+N\+C\+R\+E\+M\+E\+NT&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+R\+E\+S\+T\+O\+RE@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+R\+E\+S\+T\+O\+RE}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+R\+E\+S\+T\+O\+RE@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+R\+E\+S\+T\+O\+RE}}}\mbox{\label{class_m_f_r_c522_a5d46a0e2b34b21f51f40ea95795b5e49ab8ed49cb6ed6228acb0c911d60758486}} 
P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+R\+E\+S\+T\+O\+RE&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+T\+R\+A\+N\+S\+F\+ER@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+T\+R\+A\+N\+S\+F\+ER}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+T\+R\+A\+N\+S\+F\+ER@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+T\+R\+A\+N\+S\+F\+ER}}}\mbox{\label{class_m_f_r_c522_a5d46a0e2b34b21f51f40ea95795b5e49a5d2309094d9fa17125dc90394e5aeaa0}} 
P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+T\+R\+A\+N\+S\+F\+ER&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+U\+L\+\_\+\+W\+R\+I\+TE@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+U\+L\+\_\+\+W\+R\+I\+TE}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+U\+L\+\_\+\+W\+R\+I\+TE@{P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+U\+L\+\_\+\+W\+R\+I\+TE}}}\mbox{\label{class_m_f_r_c522_a5d46a0e2b34b21f51f40ea95795b5e49ae8aeabd1ddb73db2f04259c76eaccd8e}} 
P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+U\+L\+\_\+\+W\+R\+I\+TE&\\
\hline

\end{DoxyEnumFields}


Definition at line 195 of file M\+F\+R\+C522.\+h.


\begin{DoxyCode}
195                       \{
196         \textcolor{comment}{// The commands used by the PCD to manage communication with several PICCs (ISO 14443-3, Type A,
       section 6.4)}
197         PICC_CMD_REQA           = 0x26,     \textcolor{comment}{// REQuest command, Type A. Invites PICCs in state IDLE to go
       to READY and prepare for anticollision or selection. 7 bit frame.}
198         PICC_CMD_WUPA           = 0x52,     \textcolor{comment}{// Wake-UP command, Type A. Invites PICCs in state IDLE and
       HALT to go to READY(*) and prepare for anticollision or selection. 7 bit frame.}
199         PICC_CMD_CT             = 0x88,     \textcolor{comment}{// Cascade Tag. Not really a command, but used during anti
       collision.}
200         PICC_CMD_SEL_CL1        = 0x93,     \textcolor{comment}{// Anti collision/Select, Cascade Level 1}
201         PICC_CMD_SEL_CL2        = 0x95,     \textcolor{comment}{// Anti collision/Select, Cascade Level 1}
202         PICC_CMD_SEL_CL3        = 0x97,     \textcolor{comment}{// Anti collision/Select, Cascade Level 1}
203         PICC_CMD_HLTA           = 0x50,     \textcolor{comment}{// HaLT command, Type A. Instructs an ACTIVE PICC to go to
       state HALT.}
204         \textcolor{comment}{// The commands used for MIFARE Classic (from http://www.nxp.com/documents/data\_sheet/MF1S503x.pdf,
       Section 9)}
205         \textcolor{comment}{// Use PCD\_MFAuthent to authenticate access to a sector, then use these commands to
       read/write/modify the blocks on the sector.}
206         \textcolor{comment}{// The read/write commands can also be used for MIFARE Ultralight.}
207         PICC_CMD_MF_AUTH_KEY_A  = 0x60,     \textcolor{comment}{// Perform authentication with Key A}
208         PICC_CMD_MF_AUTH_KEY_B  = 0x61,     \textcolor{comment}{// Perform authentication with Key B}
209         PICC_CMD_MF_READ        = 0x30,     \textcolor{comment}{// Reads one 16 byte block from the authenticated sector of the
       PICC. Also used for MIFARE Ultralight.}
210         PICC_CMD_MF_WRITE       = 0xA0,     \textcolor{comment}{// Writes one 16 byte block to the authenticated sector of the
       PICC. Called "COMPATIBILITY WRITE" for MIFARE Ultralight.}
211         PICC_CMD_MF_DECREMENT   = 0xC0,     \textcolor{comment}{// Decrements the contents of a block and stores the result in
       the internal data register.}
212         PICC_CMD_MF_INCREMENT   = 0xC1,     \textcolor{comment}{// Increments the contents of a block and stores the result in
       the internal data register.}
213         PICC_CMD_MF_RESTORE     = 0xC2,     \textcolor{comment}{// Reads the contents of a block into the internal data
       register.}
214         PICC_CMD_MF_TRANSFER    = 0xB0,     \textcolor{comment}{// Writes the contents of the internal data register to a
       block.}
215         \textcolor{comment}{// The commands used for MIFARE Ultralight (from
       http://www.nxp.com/documents/data\_sheet/MF0ICU1.pdf, Section 8.6)}
216         \textcolor{comment}{// The PICC\_CMD\_MF\_READ and PICC\_CMD\_MF\_WRITE can also be used for MIFARE Ultralight.}
217         PICC_CMD_UL_WRITE       = 0xA2      \textcolor{comment}{// Writes one 4 byte page to the PICC.}
218     \};
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a3d8d44527557fe596a9ac486d49239de}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+Type@{P\+I\+C\+C\+\_\+\+Type}}
\index{P\+I\+C\+C\+\_\+\+Type@{P\+I\+C\+C\+\_\+\+Type}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+I\+C\+C\+\_\+\+Type}
{\footnotesize\ttfamily enum \textbf{ M\+F\+R\+C522\+::\+P\+I\+C\+C\+\_\+\+Type}}

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+U\+N\+K\+N\+O\+WN@{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+U\+N\+K\+N\+O\+WN}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+U\+N\+K\+N\+O\+WN@{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+U\+N\+K\+N\+O\+WN}}}\mbox{\label{class_m_f_r_c522_a3d8d44527557fe596a9ac486d49239deaceba425b4eb6fd85de456a04e1ce1565}} 
P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+U\+N\+K\+N\+O\+WN&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+I\+S\+O\+\_\+14443\+\_\+4@{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+I\+S\+O\+\_\+14443\+\_\+4}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+I\+S\+O\+\_\+14443\+\_\+4@{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+I\+S\+O\+\_\+14443\+\_\+4}}}\mbox{\label{class_m_f_r_c522_a3d8d44527557fe596a9ac486d49239dea5c8147b0f3970c9db0a177cb44592bc7}} 
P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+I\+S\+O\+\_\+14443\+\_\+4&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+I\+S\+O\+\_\+18092@{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+I\+S\+O\+\_\+18092}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+I\+S\+O\+\_\+18092@{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+I\+S\+O\+\_\+18092}}}\mbox{\label{class_m_f_r_c522_a3d8d44527557fe596a9ac486d49239dea6d211bf0d6e1bed8f7cdb375e9137360}} 
P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+I\+S\+O\+\_\+18092&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+M\+I\+NI@{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+M\+I\+NI}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+M\+I\+NI@{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+M\+I\+NI}}}\mbox{\label{class_m_f_r_c522_a3d8d44527557fe596a9ac486d49239dea58d34a16ef064d4679cae921ecc4b505}} 
P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+M\+I\+NI&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+1K@{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+1K}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+1K@{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+1K}}}\mbox{\label{class_m_f_r_c522_a3d8d44527557fe596a9ac486d49239dea948d034c12fd457923b65f929b1538fb}} 
P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+1K&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+4K@{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+4K}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+4K@{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+4K}}}\mbox{\label{class_m_f_r_c522_a3d8d44527557fe596a9ac486d49239dea7d2d0cfef1abe1c457fb72ebcf81fad4}} 
P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+4K&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+UL@{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+UL}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+UL@{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+UL}}}\mbox{\label{class_m_f_r_c522_a3d8d44527557fe596a9ac486d49239dea905f84b972470f7d80ed017817ae300c}} 
P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+UL&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+P\+L\+US@{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+P\+L\+US}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+P\+L\+US@{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+P\+L\+US}}}\mbox{\label{class_m_f_r_c522_a3d8d44527557fe596a9ac486d49239dea16d53e0355d6214dbe7faf7e37c99002}} 
P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+P\+L\+US&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+T\+N\+P3\+X\+XX@{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+T\+N\+P3\+X\+XX}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+T\+N\+P3\+X\+XX@{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+T\+N\+P3\+X\+XX}}}\mbox{\label{class_m_f_r_c522_a3d8d44527557fe596a9ac486d49239dea3efaeaa8963b24323f274bab4c1eaf8f}} 
P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+T\+N\+P3\+X\+XX&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+N\+O\+T\+\_\+\+C\+O\+M\+P\+L\+E\+TE@{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+N\+O\+T\+\_\+\+C\+O\+M\+P\+L\+E\+TE}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+N\+O\+T\+\_\+\+C\+O\+M\+P\+L\+E\+TE@{P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+N\+O\+T\+\_\+\+C\+O\+M\+P\+L\+E\+TE}}}\mbox{\label{class_m_f_r_c522_a3d8d44527557fe596a9ac486d49239dea06fbbb7628bd0c595c58b96547cb8960}} 
P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+N\+O\+T\+\_\+\+C\+O\+M\+P\+L\+E\+TE&\\
\hline

\end{DoxyEnumFields}


Definition at line 227 of file M\+F\+R\+C522.\+h.


\begin{DoxyCode}
227                    \{
228         PICC_TYPE_UNKNOWN       = 0,
229         PICC_TYPE_ISO_14443_4   = 1,    \textcolor{comment}{// PICC compliant with ISO/IEC 14443-4 }
230         PICC_TYPE_ISO_18092     = 2,    \textcolor{comment}{// PICC compliant with ISO/IEC 18092 (NFC)}
231         PICC_TYPE_MIFARE_MINI   = 3,    \textcolor{comment}{// MIFARE Classic protocol, 320 bytes}
232         PICC_TYPE_MIFARE_1K     = 4,    \textcolor{comment}{// MIFARE Classic protocol, 1KB}
233         PICC_TYPE_MIFARE_4K     = 5,    \textcolor{comment}{// MIFARE Classic protocol, 4KB}
234         PICC_TYPE_MIFARE_UL     = 6,    \textcolor{comment}{// MIFARE Ultralight or Ultralight C}
235         PICC_TYPE_MIFARE_PLUS   = 7,    \textcolor{comment}{// MIFARE Plus}
236         PICC_TYPE_TNP3XXX       = 8,    \textcolor{comment}{// Only mentioned in NXP AN 10833 MIFARE Type Identification
       Procedure}
237         PICC_TYPE_NOT_COMPLETE  = 255   \textcolor{comment}{// SAK indicates UID is not complete.}
238     \};
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_ac0da61f475014ccb8c77205287a09c27}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Status\+Code@{Status\+Code}}
\index{Status\+Code@{Status\+Code}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{Status\+Code}
{\footnotesize\ttfamily enum \textbf{ M\+F\+R\+C522\+::\+Status\+Code}}

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{S\+T\+A\+T\+U\+S\+\_\+\+OK@{S\+T\+A\+T\+U\+S\+\_\+\+OK}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!S\+T\+A\+T\+U\+S\+\_\+\+OK@{S\+T\+A\+T\+U\+S\+\_\+\+OK}}}\mbox{\label{class_m_f_r_c522_ac0da61f475014ccb8c77205287a09c27a3e34ac777020ad63ef7e346dfb813fe7}} 
S\+T\+A\+T\+U\+S\+\_\+\+OK&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{S\+T\+A\+T\+U\+S\+\_\+\+E\+R\+R\+OR@{S\+T\+A\+T\+U\+S\+\_\+\+E\+R\+R\+OR}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!S\+T\+A\+T\+U\+S\+\_\+\+E\+R\+R\+OR@{S\+T\+A\+T\+U\+S\+\_\+\+E\+R\+R\+OR}}}\mbox{\label{class_m_f_r_c522_ac0da61f475014ccb8c77205287a09c27aa3b0624b83ba5934292d671c73638a54}} 
S\+T\+A\+T\+U\+S\+\_\+\+E\+R\+R\+OR&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{S\+T\+A\+T\+U\+S\+\_\+\+C\+O\+L\+L\+I\+S\+I\+ON@{S\+T\+A\+T\+U\+S\+\_\+\+C\+O\+L\+L\+I\+S\+I\+ON}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!S\+T\+A\+T\+U\+S\+\_\+\+C\+O\+L\+L\+I\+S\+I\+ON@{S\+T\+A\+T\+U\+S\+\_\+\+C\+O\+L\+L\+I\+S\+I\+ON}}}\mbox{\label{class_m_f_r_c522_ac0da61f475014ccb8c77205287a09c27a2ad63357ec8c38f712ea6fd811056993}} 
S\+T\+A\+T\+U\+S\+\_\+\+C\+O\+L\+L\+I\+S\+I\+ON&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{S\+T\+A\+T\+U\+S\+\_\+\+T\+I\+M\+E\+O\+UT@{S\+T\+A\+T\+U\+S\+\_\+\+T\+I\+M\+E\+O\+UT}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!S\+T\+A\+T\+U\+S\+\_\+\+T\+I\+M\+E\+O\+UT@{S\+T\+A\+T\+U\+S\+\_\+\+T\+I\+M\+E\+O\+UT}}}\mbox{\label{class_m_f_r_c522_ac0da61f475014ccb8c77205287a09c27a1db4d2ed757f0a638e5018fb994071ae}} 
S\+T\+A\+T\+U\+S\+\_\+\+T\+I\+M\+E\+O\+UT&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{S\+T\+A\+T\+U\+S\+\_\+\+N\+O\+\_\+\+R\+O\+OM@{S\+T\+A\+T\+U\+S\+\_\+\+N\+O\+\_\+\+R\+O\+OM}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!S\+T\+A\+T\+U\+S\+\_\+\+N\+O\+\_\+\+R\+O\+OM@{S\+T\+A\+T\+U\+S\+\_\+\+N\+O\+\_\+\+R\+O\+OM}}}\mbox{\label{class_m_f_r_c522_ac0da61f475014ccb8c77205287a09c27a45ce24f67052f4813df3b0f4efaafea8}} 
S\+T\+A\+T\+U\+S\+\_\+\+N\+O\+\_\+\+R\+O\+OM&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{S\+T\+A\+T\+U\+S\+\_\+\+I\+N\+T\+E\+R\+N\+A\+L\+\_\+\+E\+R\+R\+OR@{S\+T\+A\+T\+U\+S\+\_\+\+I\+N\+T\+E\+R\+N\+A\+L\+\_\+\+E\+R\+R\+OR}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!S\+T\+A\+T\+U\+S\+\_\+\+I\+N\+T\+E\+R\+N\+A\+L\+\_\+\+E\+R\+R\+OR@{S\+T\+A\+T\+U\+S\+\_\+\+I\+N\+T\+E\+R\+N\+A\+L\+\_\+\+E\+R\+R\+OR}}}\mbox{\label{class_m_f_r_c522_ac0da61f475014ccb8c77205287a09c27a851307266f677fd58db61540ffe76855}} 
S\+T\+A\+T\+U\+S\+\_\+\+I\+N\+T\+E\+R\+N\+A\+L\+\_\+\+E\+R\+R\+OR&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{S\+T\+A\+T\+U\+S\+\_\+\+I\+N\+V\+A\+L\+ID@{S\+T\+A\+T\+U\+S\+\_\+\+I\+N\+V\+A\+L\+ID}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!S\+T\+A\+T\+U\+S\+\_\+\+I\+N\+V\+A\+L\+ID@{S\+T\+A\+T\+U\+S\+\_\+\+I\+N\+V\+A\+L\+ID}}}\mbox{\label{class_m_f_r_c522_ac0da61f475014ccb8c77205287a09c27a88d450f43a9d22ead5db926808599fb5}} 
S\+T\+A\+T\+U\+S\+\_\+\+I\+N\+V\+A\+L\+ID&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{S\+T\+A\+T\+U\+S\+\_\+\+C\+R\+C\+\_\+\+W\+R\+O\+NG@{S\+T\+A\+T\+U\+S\+\_\+\+C\+R\+C\+\_\+\+W\+R\+O\+NG}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!S\+T\+A\+T\+U\+S\+\_\+\+C\+R\+C\+\_\+\+W\+R\+O\+NG@{S\+T\+A\+T\+U\+S\+\_\+\+C\+R\+C\+\_\+\+W\+R\+O\+NG}}}\mbox{\label{class_m_f_r_c522_ac0da61f475014ccb8c77205287a09c27ac25a91c2efa2dc7638758321374f7566}} 
S\+T\+A\+T\+U\+S\+\_\+\+C\+R\+C\+\_\+\+W\+R\+O\+NG&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{S\+T\+A\+T\+U\+S\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+N\+A\+CK@{S\+T\+A\+T\+U\+S\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+N\+A\+CK}!M\+F\+R\+C522@{M\+F\+R\+C522}}\index{M\+F\+R\+C522@{M\+F\+R\+C522}!S\+T\+A\+T\+U\+S\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+N\+A\+CK@{S\+T\+A\+T\+U\+S\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+N\+A\+CK}}}\mbox{\label{class_m_f_r_c522_ac0da61f475014ccb8c77205287a09c27ad14f5e1a33047c90b50fa829cb669109}} 
S\+T\+A\+T\+U\+S\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+N\+A\+CK&\\
\hline

\end{DoxyEnumFields}


Definition at line 241 of file M\+F\+R\+C522.\+h.


\begin{DoxyCode}
241                     \{
242         STATUS_OK               = 1,    \textcolor{comment}{// Success}
243         STATUS_ERROR            = 2,    \textcolor{comment}{// Error in communication}
244         STATUS_COLLISION        = 3,    \textcolor{comment}{// Collission detected}
245         STATUS_TIMEOUT          = 4,    \textcolor{comment}{// Timeout in communication.}
246         STATUS_NO_ROOM          = 5,    \textcolor{comment}{// A buffer is not big enough.}
247         STATUS_INTERNAL_ERROR   = 6,    \textcolor{comment}{// Internal error in the code. Should not happen ;-)}
248         STATUS_INVALID          = 7,    \textcolor{comment}{// Invalid argument.}
249         STATUS_CRC_WRONG        = 8,    \textcolor{comment}{// The CRC\_A does not match}
250         STATUS_MIFARE_NACK      = 9     \textcolor{comment}{// A MIFARE PICC responded with NAK.}
251     \};
\end{DoxyCode}


\subsection{Constructor \& Destructor Documentation}
\mbox{\label{class_m_f_r_c522_a8b859e244e80970594bf333a0148ade1}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{M\+F\+R\+C522()}
{\footnotesize\ttfamily M\+F\+R\+C522\+::\+M\+F\+R\+C522 (\begin{DoxyParamCaption}\item[{byte}]{chip\+Select\+Pin,  }\item[{byte}]{reset\+Power\+Down\+Pin }\end{DoxyParamCaption})}

Constructor. Prepares the output pins. 
\begin{DoxyParams}{Parameters}
{\em chip\+Select\+Pin} & Arduino pin connected to \doxyref{M\+F\+R\+C522}{p.}{class_m_f_r_c522}\textquotesingle{}s S\+PI slave select input (Pin 24, N\+SS, active low) \\
\hline
{\em reset\+Power\+Down\+Pin} & Arduino pin connected to \doxyref{M\+F\+R\+C522}{p.}{class_m_f_r_c522}\textquotesingle{}s reset and power down input (Pin 6, N\+R\+S\+T\+PD, active low) \\
\hline
\end{DoxyParams}


Definition at line 18 of file M\+F\+R\+C522.\+cpp.


\begin{DoxyCode}
20                   \{
21     \textcolor{comment}{// Set the chipSelectPin as digital output, do not select the slave yet}
22     _chipSelectPin = chipSelectPin;
23     pinMode(_chipSelectPin, OUTPUT);
24     digitalWrite(_chipSelectPin, HIGH);
25     
26     \textcolor{comment}{// Set the resetPowerDownPin as digital output, do not reset or power down.}
27     _resetPowerDownPin = resetPowerDownPin;
28     pinMode(_resetPowerDownPin, OUTPUT);
29     digitalWrite(_resetPowerDownPin, LOW);
30     
31     \textcolor{comment}{// Set SPI bus to work with MFRC522 chip.}
32     \textcolor{comment}{//setSPIConfig();}
33 \} \textcolor{comment}{// End constructor}
\end{DoxyCode}


\subsection{Member Function Documentation}
\mbox{\label{class_m_f_r_c522_a63e898d6efcce838b17778403f7003a9}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!Get\+Status\+Code\+Name@{Get\+Status\+Code\+Name}}
\index{Get\+Status\+Code\+Name@{Get\+Status\+Code\+Name}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{Get\+Status\+Code\+Name()}
{\footnotesize\ttfamily const char $\ast$ M\+F\+R\+C522\+::\+Get\+Status\+Code\+Name (\begin{DoxyParamCaption}\item[{byte}]{code }\end{DoxyParamCaption})}

Returns a string pointer to a status code name. 
\begin{DoxyParams}{Parameters}
{\em code} & One of the Status\+Code enums. \\
\hline
\end{DoxyParams}


Definition at line 1077 of file M\+F\+R\+C522.\+cpp.


\begin{DoxyCode}
1078                                           \{
1079     \textcolor{keywordflow}{switch} (code) \{
1080         \textcolor{keywordflow}{case} STATUS_OK:             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Success."}; \textcolor{keywordflow}{break};
1081         \textcolor{keywordflow}{case} STATUS_ERROR:          \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Error in communication."}; \textcolor{keywordflow}{break};
1082         \textcolor{keywordflow}{case} STATUS_COLLISION:      \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Collission detected."}; \textcolor{keywordflow}{break};
1083         \textcolor{keywordflow}{case} STATUS_TIMEOUT:        \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Timeout in communication."}; \textcolor{keywordflow}{break};
1084         \textcolor{keywordflow}{case} STATUS_NO_ROOM:        \textcolor{keywordflow}{return} \textcolor{stringliteral}{"A buffer is not big enough."}; \textcolor{keywordflow}{break};
1085         \textcolor{keywordflow}{case} STATUS_INTERNAL_ERROR: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Internal error in the code. Should not happen."}; \textcolor{keywordflow}{break};
1086         \textcolor{keywordflow}{case} STATUS_INVALID:        \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Invalid argument."}; \textcolor{keywordflow}{break};
1087         \textcolor{keywordflow}{case} STATUS_CRC_WRONG:      \textcolor{keywordflow}{return} \textcolor{stringliteral}{"The CRC\_A does not match."}; \textcolor{keywordflow}{break};
1088         \textcolor{keywordflow}{case} STATUS_MIFARE_NACK:    \textcolor{keywordflow}{return} \textcolor{stringliteral}{"A MIFARE PICC responded with NAK."}; \textcolor{keywordflow}{break};
1089         \textcolor{keywordflow}{default}:
1090             \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Unknown error"};
1091             \textcolor{keywordflow}{break};
1092     \}
1093 \} \textcolor{comment}{// End GetStatusCodeName()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a1b4732c54686bd32e2dd79cf4b5279e6}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!M\+I\+F\+A\+R\+E\+\_\+\+Decrement@{M\+I\+F\+A\+R\+E\+\_\+\+Decrement}}
\index{M\+I\+F\+A\+R\+E\+\_\+\+Decrement@{M\+I\+F\+A\+R\+E\+\_\+\+Decrement}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{M\+I\+F\+A\+R\+E\+\_\+\+Decrement()}
{\footnotesize\ttfamily byte M\+F\+R\+C522\+::\+M\+I\+F\+A\+R\+E\+\_\+\+Decrement (\begin{DoxyParamCaption}\item[{byte}]{block\+Addr,  }\item[{long}]{delta }\end{DoxyParamCaption})}

M\+I\+F\+A\+RE Decrement subtracts the delta from the value of the addressed block, and stores the result in a volatile memory. For M\+I\+F\+A\+RE Classic only. The sector containing the block must be authenticated before calling this function. Only for blocks in \char`\"{}value block\char`\"{} mode, ie with access bits [C1 C2 C3] = [110] or [001]. Use \doxyref{M\+I\+F\+A\+R\+E\+\_\+\+Transfer()}{p.}{class_m_f_r_c522_a36299391c708a71c11c48a94c4e3f3c2} to store the result in a block.

\begin{DoxyReturn}{Returns}
S\+T\+A\+T\+U\+S\+\_\+\+OK on success, S\+T\+A\+T\+U\+S\+\_\+??? otherwise. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em block\+Addr} & The block (0-\/0xff) number. \\
\hline
{\em delta} & This number is subtracted from the value of block block\+Addr. \\
\hline
\end{DoxyParams}


Definition at line 877 of file M\+F\+R\+C522.\+cpp.


\begin{DoxyCode}
879                               \{
880     \textcolor{keywordflow}{return} MIFARE_TwoStepHelper(PICC_CMD_MF_DECREMENT, blockAddr, delta);
881 \} \textcolor{comment}{// End MIFARE\_Decrement()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a1116cb31c5a64c2be71e3b8649d7865b}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!M\+I\+F\+A\+R\+E\+\_\+\+Get\+Value@{M\+I\+F\+A\+R\+E\+\_\+\+Get\+Value}}
\index{M\+I\+F\+A\+R\+E\+\_\+\+Get\+Value@{M\+I\+F\+A\+R\+E\+\_\+\+Get\+Value}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{M\+I\+F\+A\+R\+E\+\_\+\+Get\+Value()}
{\footnotesize\ttfamily byte M\+F\+R\+C522\+::\+M\+I\+F\+A\+R\+E\+\_\+\+Get\+Value (\begin{DoxyParamCaption}\item[{byte}]{block\+Addr,  }\item[{long $\ast$}]{value }\end{DoxyParamCaption})}

Helper routine to read the current value from a Value Block.

Only for M\+I\+F\+A\+RE Classic and only for blocks in \char`\"{}value block\char`\"{} mode, that is\+: with access bits [C1 C2 C3] = [110] or [001]. The sector containing the block must be authenticated before calling this function.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em block\+Addr} & The block (0x00-\/0xff) number. \\
\hline
\mbox{\tt out}  & {\em value} & Current value of the Value Block. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
S\+T\+A\+T\+U\+S\+\_\+\+OK on success, S\+T\+A\+T\+U\+S\+\_\+??? otherwise. 
\end{DoxyReturn}


Definition at line 975 of file M\+F\+R\+C522.\+cpp.


\begin{DoxyCode}
975                                                          \{
976     byte status;
977     byte buffer[18];
978     byte size = \textcolor{keyword}{sizeof}(buffer);
979 
980     \textcolor{comment}{// Read the block}
981     status = MIFARE_Read(blockAddr, buffer, &size);
982     \textcolor{keywordflow}{if} (status == STATUS_OK) \{
983       \textcolor{comment}{// Extract the value}
984       *value = (long(buffer[3])<<24) | (\textcolor{keywordtype}{long}(buffer[2])<<16) | (\textcolor{keywordtype}{long}(buffer[1])<<8) | \textcolor{keywordtype}{long}(buffer[0]);
985     \}
986     \textcolor{keywordflow}{return} status;
987 \} \textcolor{comment}{// End MIFARE\_GetValue()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_aa45713c6d2c8dcf949874abd03f72327}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!M\+I\+F\+A\+R\+E\+\_\+\+Increment@{M\+I\+F\+A\+R\+E\+\_\+\+Increment}}
\index{M\+I\+F\+A\+R\+E\+\_\+\+Increment@{M\+I\+F\+A\+R\+E\+\_\+\+Increment}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{M\+I\+F\+A\+R\+E\+\_\+\+Increment()}
{\footnotesize\ttfamily byte M\+F\+R\+C522\+::\+M\+I\+F\+A\+R\+E\+\_\+\+Increment (\begin{DoxyParamCaption}\item[{byte}]{block\+Addr,  }\item[{long}]{delta }\end{DoxyParamCaption})}

M\+I\+F\+A\+RE Increment adds the delta to the value of the addressed block, and stores the result in a volatile memory. For M\+I\+F\+A\+RE Classic only. The sector containing the block must be authenticated before calling this function. Only for blocks in \char`\"{}value block\char`\"{} mode, ie with access bits [C1 C2 C3] = [110] or [001]. Use \doxyref{M\+I\+F\+A\+R\+E\+\_\+\+Transfer()}{p.}{class_m_f_r_c522_a36299391c708a71c11c48a94c4e3f3c2} to store the result in a block.

\begin{DoxyReturn}{Returns}
S\+T\+A\+T\+U\+S\+\_\+\+OK on success, S\+T\+A\+T\+U\+S\+\_\+??? otherwise. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em block\+Addr} & The block (0-\/0xff) number. \\
\hline
{\em delta} & This number is added to the value of block block\+Addr. \\
\hline
\end{DoxyParams}


Definition at line 891 of file M\+F\+R\+C522.\+cpp.


\begin{DoxyCode}
893                               \{
894     \textcolor{keywordflow}{return} MIFARE_TwoStepHelper(PICC_CMD_MF_INCREMENT, blockAddr, delta);
895 \} \textcolor{comment}{// End MIFARE\_Increment()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a925607adc9382720c222578bd236a9c8}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!M\+I\+F\+A\+R\+E\+\_\+\+Open\+Uid\+Backdoor@{M\+I\+F\+A\+R\+E\+\_\+\+Open\+Uid\+Backdoor}}
\index{M\+I\+F\+A\+R\+E\+\_\+\+Open\+Uid\+Backdoor@{M\+I\+F\+A\+R\+E\+\_\+\+Open\+Uid\+Backdoor}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{M\+I\+F\+A\+R\+E\+\_\+\+Open\+Uid\+Backdoor()}
{\footnotesize\ttfamily bool M\+F\+R\+C522\+::\+M\+I\+F\+A\+R\+E\+\_\+\+Open\+Uid\+Backdoor (\begin{DoxyParamCaption}\item[{bool}]{log\+Errors }\end{DoxyParamCaption})}

Performs the \char`\"{}magic sequence\char`\"{} needed to get Chinese U\+ID changeable Mifare cards to allow writing to sector 0, where the card U\+ID is stored.

Note that you do not need to have selected the card through R\+E\+QA or W\+U\+PA, this sequence works immediately when the card is in the reader vicinity. This means you can use this method even on \char`\"{}bricked\char`\"{} cards that your reader does not recognise anymore (see \doxyref{M\+F\+R\+C522\+::\+M\+I\+F\+A\+R\+E\+\_\+\+Unbrick\+Uid\+Sector}{p.}{class_m_f_r_c522_afcbb15d925cb3bea9f58595111fbca48}).

Of course with non-\/bricked devices, you\textquotesingle{}re free to select them before calling this function. 

Definition at line 1445 of file M\+F\+R\+C522.\+cpp.



Referenced by M\+I\+F\+A\+R\+E\+\_\+\+Set\+Uid(), and M\+I\+F\+A\+R\+E\+\_\+\+Unbrick\+Uid\+Sector().


\begin{DoxyCode}
1445                                                    \{
1446     \textcolor{comment}{// Magic sequence:}
1447     \textcolor{comment}{// > 50 00 57 CD (HALT + CRC)}
1448     \textcolor{comment}{// > 40 (7 bits only)}
1449     \textcolor{comment}{// < A (4 bits only)}
1450     \textcolor{comment}{// > 43}
1451     \textcolor{comment}{// < A (4 bits only)}
1452     \textcolor{comment}{// Then you can write to sector 0 without authenticating}
1453     
1454     PICC_HaltA(); \textcolor{comment}{// 50 00 57 CD}
1455     
1456     byte cmd = 0x40;
1457     byte validBits = 7; \textcolor{comment}{/* Our command is only 7 bits. After receiving card response,}
1458 \textcolor{comment}{                          this will contain amount of valid response bits. */}
1459     byte response[32]; \textcolor{comment}{// Card's response is written here}
1460     byte received;
1461     byte status = PCD_TransceiveData(&cmd, (byte)1, response, &received, &validBits, (byte)0, \textcolor{keyword}{false}); \textcolor{comment}{// 40}
1462     \textcolor{keywordflow}{if}( status != STATUS_OK ) \{
1463         \textcolor{keywordflow}{if}( logErrors ) \{
1464             Serial.println(\textcolor{stringliteral}{"Card did not respond to 0x40 after HALT command. Are you sure it is a UID
       changeable one?"});
1465             Serial.print(\textcolor{stringliteral}{"Error name: "});
1466             Serial.println(GetStatusCodeName(status));
1467         \}
1468         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1469     \}
1470     \textcolor{keywordflow}{if} ( received != 1 || response[0] != 0x0A ) \{
1471         \textcolor{keywordflow}{if} ( logErrors ) \{
1472             Serial.print(\textcolor{stringliteral}{"Got bad response on backdoor 0x40 command: "});
1473             Serial.print(response[0], HEX);
1474             Serial.print(\textcolor{stringliteral}{" ("});
1475             Serial.print(validBits);
1476             Serial.print(\textcolor{stringliteral}{" valid bits)\(\backslash\)r\(\backslash\)n"});
1477         \}
1478         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1479     \}
1480     
1481     cmd = 0x43;
1482     validBits = 8;
1483     status = PCD_TransceiveData(&cmd, (byte)1, response, &received, &validBits, (byte)0, \textcolor{keyword}{false}); \textcolor{comment}{// 43}
1484     \textcolor{keywordflow}{if}( status != STATUS_OK ) \{
1485         \textcolor{keywordflow}{if}( logErrors ) \{
1486             Serial.println(\textcolor{stringliteral}{"Error in communication at command 0x43, after successfully executing 0x40"});
1487             Serial.print(\textcolor{stringliteral}{"Error name: "});
1488             Serial.println(GetStatusCodeName(status));
1489         \}
1490         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1491     \}
1492     \textcolor{keywordflow}{if} ( received != 1 || response[0] != 0x0A ) \{
1493         \textcolor{keywordflow}{if} ( logErrors ) \{
1494             Serial.print(\textcolor{stringliteral}{"Got bad response on backdoor 0x43 command: "});
1495             Serial.print(response[0], HEX);
1496             Serial.print(\textcolor{stringliteral}{" ("});
1497             Serial.print(validBits);
1498             Serial.print(\textcolor{stringliteral}{" valid bits)\(\backslash\)r\(\backslash\)n"});
1499         \}
1500         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1501     \}
1502     
1503     \textcolor{comment}{// You can now write to sector 0 without authenticating!}
1504     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1505 \} \textcolor{comment}{// End MIFARE\_OpenUidBackdoor()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a05cdd51aa162e37de1a9439b75901e28}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!M\+I\+F\+A\+R\+E\+\_\+\+Read@{M\+I\+F\+A\+R\+E\+\_\+\+Read}}
\index{M\+I\+F\+A\+R\+E\+\_\+\+Read@{M\+I\+F\+A\+R\+E\+\_\+\+Read}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{M\+I\+F\+A\+R\+E\+\_\+\+Read()}
{\footnotesize\ttfamily byte M\+F\+R\+C522\+::\+M\+I\+F\+A\+R\+E\+\_\+\+Read (\begin{DoxyParamCaption}\item[{byte}]{block\+Addr,  }\item[{byte $\ast$}]{buffer,  }\item[{byte $\ast$}]{buffer\+Size }\end{DoxyParamCaption})}

Reads 16 bytes (+ 2 bytes C\+R\+C\+\_\+A) from the active P\+I\+CC.

For M\+I\+F\+A\+RE Classic the sector containing the block must be authenticated before calling this function.

For M\+I\+F\+A\+RE Ultralight only addresses 00h to 0\+Fh are decoded. The M\+F0\+I\+C\+U1 returns a N\+AK for higher addresses. The M\+F0\+I\+C\+U1 responds to the R\+E\+AD command by sending 16 bytes starting from the page address defined by the command argument. For example; if block\+Addr is 03h then pages 03h, 04h, 05h, 06h are returned. A roll-\/back is implemented\+: If block\+Addr is 0\+Eh, then the contents of pages 0\+Eh, 0\+Fh, 00h and 01h are returned.

The buffer must be at least 18 bytes because a C\+R\+C\+\_\+A is also returned. Checks the C\+R\+C\+\_\+A before returning S\+T\+A\+T\+U\+S\+\_\+\+OK.

\begin{DoxyReturn}{Returns}
S\+T\+A\+T\+U\+S\+\_\+\+OK on success, S\+T\+A\+T\+U\+S\+\_\+??? otherwise. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em block\+Addr} & M\+I\+F\+A\+RE Classic\+: The block (0-\/0xff) number. M\+I\+F\+A\+RE Ultralight\+: The first page to return data from. \\
\hline
{\em buffer} & The buffer to store the data in \\
\hline
{\em buffer\+Size} & Buffer size, at least 18 bytes. Also number of bytes returned if S\+T\+A\+T\+U\+S\+\_\+\+OK. \\
\hline
\end{DoxyParams}


Definition at line 774 of file M\+F\+R\+C522.\+cpp.



References S\+T\+A\+T\+U\+S\+\_\+\+N\+O\+\_\+\+R\+O\+OM.


\begin{DoxyCode}
777                           \{
778     byte result;
779     
780     \textcolor{comment}{// Sanity check}
781     \textcolor{keywordflow}{if} (buffer == NULL || *bufferSize < 18) \{
782         \textcolor{keywordflow}{return} STATUS_NO_ROOM;
783     \}
784 
785     \textcolor{comment}{// Build command buffer}
786     buffer[0] = PICC_CMD_MF_READ;
787     buffer[1] = blockAddr;
788     \textcolor{comment}{// Calculate CRC\_A}
789     result = PCD_CalculateCRC(buffer, 2, &buffer[2]);
790     \textcolor{keywordflow}{if} (result != STATUS_OK) \{
791         \textcolor{keywordflow}{return} result;
792     \}
793     
794     \textcolor{comment}{// Transmit the buffer and receive the response, validate CRC\_A.}
795     \textcolor{keywordflow}{return} PCD_TransceiveData(buffer, 4, buffer, bufferSize, NULL, 0, \textcolor{keyword}{true});
796 \} \textcolor{comment}{// End MIFARE\_Read()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_aa0f6201f92ae7babab4d37786a12d483}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!M\+I\+F\+A\+R\+E\+\_\+\+Restore@{M\+I\+F\+A\+R\+E\+\_\+\+Restore}}
\index{M\+I\+F\+A\+R\+E\+\_\+\+Restore@{M\+I\+F\+A\+R\+E\+\_\+\+Restore}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{M\+I\+F\+A\+R\+E\+\_\+\+Restore()}
{\footnotesize\ttfamily byte M\+F\+R\+C522\+::\+M\+I\+F\+A\+R\+E\+\_\+\+Restore (\begin{DoxyParamCaption}\item[{byte}]{block\+Addr }\end{DoxyParamCaption})}

M\+I\+F\+A\+RE Restore copies the value of the addressed block into a volatile memory. For M\+I\+F\+A\+RE Classic only. The sector containing the block must be authenticated before calling this function. Only for blocks in \char`\"{}value block\char`\"{} mode, ie with access bits [C1 C2 C3] = [110] or [001]. Use \doxyref{M\+I\+F\+A\+R\+E\+\_\+\+Transfer()}{p.}{class_m_f_r_c522_a36299391c708a71c11c48a94c4e3f3c2} to store the result in a block.

\begin{DoxyReturn}{Returns}
S\+T\+A\+T\+U\+S\+\_\+\+OK on success, S\+T\+A\+T\+U\+S\+\_\+??? otherwise. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em block\+Addr} & The block (0-\/0xff) number. \\
\hline
\end{DoxyParams}


Definition at line 905 of file M\+F\+R\+C522.\+cpp.


\begin{DoxyCode}
906                               \{
907     \textcolor{comment}{// The datasheet describes Restore as a two step operation, but does not explain what data to transfer
       in step 2.}
908     \textcolor{comment}{// Doing only a single step does not work, so I chose to transfer 0L in step two.}
909     \textcolor{keywordflow}{return} MIFARE_TwoStepHelper(PICC_CMD_MF_RESTORE, blockAddr, 0L);
910 \} \textcolor{comment}{// End MIFARE\_Restore()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_ab8c712963189654e9bc368be8783e2ab}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!M\+I\+F\+A\+R\+E\+\_\+\+Set\+Access\+Bits@{M\+I\+F\+A\+R\+E\+\_\+\+Set\+Access\+Bits}}
\index{M\+I\+F\+A\+R\+E\+\_\+\+Set\+Access\+Bits@{M\+I\+F\+A\+R\+E\+\_\+\+Set\+Access\+Bits}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{M\+I\+F\+A\+R\+E\+\_\+\+Set\+Access\+Bits()}
{\footnotesize\ttfamily void M\+F\+R\+C522\+::\+M\+I\+F\+A\+R\+E\+\_\+\+Set\+Access\+Bits (\begin{DoxyParamCaption}\item[{byte $\ast$}]{access\+Bit\+Buffer,  }\item[{byte}]{g0,  }\item[{byte}]{g1,  }\item[{byte}]{g2,  }\item[{byte}]{g3 }\end{DoxyParamCaption})}

Calculates the bit pattern needed for the specified access bits. In the [C1 C2 C3] tupples C1 is M\+SB (=4) and C3 is L\+SB (=1). 
\begin{DoxyParams}{Parameters}
{\em access\+Bit\+Buffer} & Pointer to byte 6, 7 and 8 in the sector trailer. Bytes [0..2] will be set. \\
\hline
{\em g0} & Access bits [C1 C2 C3] for block 0 (for sectors 0-\/31) or blocks 0-\/4 (for sectors 32-\/39) \\
\hline
{\em g1} & Access bits C1 C2 C3] for block 1 (for sectors 0-\/31) or blocks 5-\/9 (for sectors 32-\/39) \\
\hline
{\em g2} & Access bits C1 C2 C3] for block 2 (for sectors 0-\/31) or blocks 10-\/14 (for sectors 32-\/39) \\
\hline
{\em g3} & Access bits C1 C2 C3] for the sector trailer, block 3 (for sectors 0-\/31) or block 15 (for sectors 32-\/39) \\
\hline
\end{DoxyParams}


Definition at line 1419 of file M\+F\+R\+C522.\+cpp.


\begin{DoxyCode}
1424                                   \{
1425     byte c1 = ((g3 & 4) << 1) | ((g2 & 4) << 0) | ((g1 & 4) >> 1) | ((g0 & 4) >> 2);
1426     byte c2 = ((g3 & 2) << 2) | ((g2 & 2) << 1) | ((g1 & 2) << 0) | ((g0 & 2) >> 1);
1427     byte c3 = ((g3 & 1) << 3) | ((g2 & 1) << 2) | ((g1 & 1) << 1) | ((g0 & 1) << 0);
1428     
1429     accessBitBuffer[0] = (~c2 & 0xF) << 4 | (~c1 & 0xF);
1430     accessBitBuffer[1] =          c1 << 4 | (~c3 & 0xF);
1431     accessBitBuffer[2] =          c3 << 4 | c2;
1432 \} \textcolor{comment}{// End MIFARE\_SetAccessBits()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a2bdc18af4952ce99099607c84139b51c}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!M\+I\+F\+A\+R\+E\+\_\+\+Set\+Uid@{M\+I\+F\+A\+R\+E\+\_\+\+Set\+Uid}}
\index{M\+I\+F\+A\+R\+E\+\_\+\+Set\+Uid@{M\+I\+F\+A\+R\+E\+\_\+\+Set\+Uid}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{M\+I\+F\+A\+R\+E\+\_\+\+Set\+Uid()}
{\footnotesize\ttfamily bool M\+F\+R\+C522\+::\+M\+I\+F\+A\+R\+E\+\_\+\+Set\+Uid (\begin{DoxyParamCaption}\item[{byte $\ast$}]{new\+Uid,  }\item[{byte}]{uid\+Size,  }\item[{bool}]{log\+Errors }\end{DoxyParamCaption})}

Reads entire block 0, including all manufacturer data, and overwrites that block with the new U\+ID, a freshly calculated B\+CC, and the original manufacturer data.

It assumes a default K\+EY A of 0x\+F\+F\+F\+F\+F\+F\+F\+F\+F\+F\+FF. Make sure to have selected the card before this function is called. 

Definition at line 1515 of file M\+F\+R\+C522.\+cpp.



References M\+I\+F\+A\+R\+E\+\_\+\+Open\+Uid\+Backdoor(), P\+C\+D\+\_\+\+Stop\+Crypto1(), P\+I\+C\+C\+\_\+\+Is\+New\+Card\+Present(), and P\+I\+C\+C\+\_\+\+Read\+Card\+Serial().


\begin{DoxyCode}
1515                                                                       \{
1516     
1517     \textcolor{comment}{// UID + BCC byte can not be larger than 16 together}
1518     \textcolor{keywordflow}{if} ( !newUid || !uidSize || uidSize > 15) \{
1519         \textcolor{keywordflow}{if} ( logErrors ) \{
1520             Serial.println(\textcolor{stringliteral}{"New UID buffer empty, size 0, or size > 15 given"});
1521         \}
1522         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1523     \}
1524     
1525     \textcolor{comment}{// Authenticate for reading}
1526     MIFARE\_Key key = \{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\};
1527     byte status = PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_A, (byte)1, &key, &
      uid);
1528     \textcolor{keywordflow}{if} ( status != STATUS_OK ) \{
1529         
1530         \textcolor{keywordflow}{if} ( status == STATUS_TIMEOUT ) \{
1531             \textcolor{comment}{// We get a read timeout if no card is selected yet, so let's select one}
1532             
1533             \textcolor{comment}{// Wake the card up again if sleeping}
1534 \textcolor{comment}{//            byte atqa\_answer[2];}
1535 \textcolor{comment}{//            byte atqa\_size = 2;}
1536 \textcolor{comment}{//            PICC\_WakeupA(atqa\_answer, &atqa\_size);}
1537             
1538             \textcolor{keywordflow}{if} ( !PICC_IsNewCardPresent() || !PICC_ReadCardSerial() ) \{
1539                 Serial.println(\textcolor{stringliteral}{"No card was previously selected, and none are available. Failed to set UID.
      "});
1540                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1541             \}
1542             
1543             status = PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_A, (byte)1, &key, &
      uid);
1544             \textcolor{keywordflow}{if} ( status != STATUS_OK ) \{
1545                 \textcolor{comment}{// We tried, time to give up}
1546                 \textcolor{keywordflow}{if} ( logErrors ) \{
1547                     Serial.println(\textcolor{stringliteral}{"Failed to authenticate to card for reading, could not set UID: "});
1548                     Serial.println(GetStatusCodeName(status));
1549                 \}
1550                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1551             \}
1552         \}
1553         \textcolor{keywordflow}{else} \{
1554             \textcolor{keywordflow}{if} ( logErrors ) \{
1555                 Serial.print(\textcolor{stringliteral}{"PCD\_Authenticate() failed: "});
1556                 Serial.println(GetStatusCodeName(status));
1557             \}
1558             \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1559         \}
1560     \}
1561     
1562     \textcolor{comment}{// Read block 0}
1563     byte block0\_buffer[18];
1564     byte byteCount = \textcolor{keyword}{sizeof}(block0\_buffer);
1565     status = MIFARE_Read((byte)0, block0\_buffer, &byteCount);
1566     \textcolor{keywordflow}{if} ( status != STATUS_OK ) \{
1567         \textcolor{keywordflow}{if} ( logErrors ) \{
1568             Serial.print(\textcolor{stringliteral}{"MIFARE\_Read() failed: "});
1569             Serial.println(GetStatusCodeName(status));
1570             Serial.println(\textcolor{stringliteral}{"Are you sure your KEY A for sector 0 is 0xFFFFFFFFFFFF?"});
1571         \}
1572         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1573     \}
1574     
1575     \textcolor{comment}{// Write new UID to the data we just read, and calculate BCC byte}
1576     byte bcc = 0;
1577     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < uidSize; i++ ) \{
1578         block0\_buffer[i] = newUid[i];
1579         bcc ^= newUid[i];
1580     \}
1581     
1582     \textcolor{comment}{// Write BCC byte to buffer}
1583     block0\_buffer[uidSize] = bcc;
1584     
1585     \textcolor{comment}{// Stop encrypted traffic so we can send raw bytes}
1586     PCD_StopCrypto1();
1587     
1588     \textcolor{comment}{// Activate UID backdoor}
1589     \textcolor{keywordflow}{if} ( !MIFARE_OpenUidBackdoor(logErrors) ) \{
1590         \textcolor{keywordflow}{if} ( logErrors ) \{
1591             Serial.println(\textcolor{stringliteral}{"Activating the UID backdoor failed."});
1592         \}
1593         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1594     \}
1595     
1596     \textcolor{comment}{// Write modified block 0 back to card}
1597     status = MIFARE_Write((byte)0, block0\_buffer, (byte)16);
1598     \textcolor{keywordflow}{if} (status != STATUS_OK) \{
1599         \textcolor{keywordflow}{if} ( logErrors ) \{
1600             Serial.print(\textcolor{stringliteral}{"MIFARE\_Write() failed: "});
1601             Serial.println(GetStatusCodeName(status));
1602         \}
1603         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1604     \}
1605     
1606     \textcolor{comment}{// Wake the card up again}
1607     byte atqa\_answer[2];
1608     byte atqa\_size = 2;
1609     PICC_WakeupA(atqa\_answer, &atqa\_size);
1610     
1611     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1612 \}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a9ae3cc71bcfb52455349683d3685a919}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!M\+I\+F\+A\+R\+E\+\_\+\+Set\+Value@{M\+I\+F\+A\+R\+E\+\_\+\+Set\+Value}}
\index{M\+I\+F\+A\+R\+E\+\_\+\+Set\+Value@{M\+I\+F\+A\+R\+E\+\_\+\+Set\+Value}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{M\+I\+F\+A\+R\+E\+\_\+\+Set\+Value()}
{\footnotesize\ttfamily byte M\+F\+R\+C522\+::\+M\+I\+F\+A\+R\+E\+\_\+\+Set\+Value (\begin{DoxyParamCaption}\item[{byte}]{block\+Addr,  }\item[{long}]{value }\end{DoxyParamCaption})}

Helper routine to write a specific value into a Value Block.

Only for M\+I\+F\+A\+RE Classic and only for blocks in \char`\"{}value block\char`\"{} mode, that is\+: with access bits [C1 C2 C3] = [110] or [001]. The sector containing the block must be authenticated before calling this function.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em block\+Addr} & The block (0x00-\/0xff) number. \\
\hline
\mbox{\tt in}  & {\em value} & New value of the Value Block. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
S\+T\+A\+T\+U\+S\+\_\+\+OK on success, S\+T\+A\+T\+U\+S\+\_\+??? otherwise. 
\end{DoxyReturn}


Definition at line 1000 of file M\+F\+R\+C522.\+cpp.


\begin{DoxyCode}
1000                                                         \{
1001     byte buffer[18];
1002 
1003     \textcolor{comment}{// Translate the long into 4 bytes; repeated 2x in value block}
1004     buffer[0] = buffer[ 8] = (value & 0xFF);
1005     buffer[1] = buffer[ 9] = (value & 0xFF00) >> 8;
1006     buffer[2] = buffer[10] = (value & 0xFF0000) >> 16;
1007     buffer[3] = buffer[11] = (value & 0xFF000000) >> 24;
1008     \textcolor{comment}{// Inverse 4 bytes also found in value block}
1009     buffer[4] = ~buffer[0];
1010     buffer[5] = ~buffer[1];
1011     buffer[6] = ~buffer[2];
1012     buffer[7] = ~buffer[3];
1013     \textcolor{comment}{// Address 2x with inverse address 2x}
1014     buffer[12] = buffer[14] = blockAddr;
1015     buffer[13] = buffer[15] = ~blockAddr;
1016 
1017     \textcolor{comment}{// Write the whole data block}
1018     \textcolor{keywordflow}{return} MIFARE_Write(blockAddr, buffer, 16);
1019 \} \textcolor{comment}{// End MIFARE\_SetValue()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a36299391c708a71c11c48a94c4e3f3c2}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!M\+I\+F\+A\+R\+E\+\_\+\+Transfer@{M\+I\+F\+A\+R\+E\+\_\+\+Transfer}}
\index{M\+I\+F\+A\+R\+E\+\_\+\+Transfer@{M\+I\+F\+A\+R\+E\+\_\+\+Transfer}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{M\+I\+F\+A\+R\+E\+\_\+\+Transfer()}
{\footnotesize\ttfamily byte M\+F\+R\+C522\+::\+M\+I\+F\+A\+R\+E\+\_\+\+Transfer (\begin{DoxyParamCaption}\item[{byte}]{block\+Addr }\end{DoxyParamCaption})}

M\+I\+F\+A\+RE Transfer writes the value stored in the volatile memory into one M\+I\+F\+A\+RE Classic block. For M\+I\+F\+A\+RE Classic only. The sector containing the block must be authenticated before calling this function. Only for blocks in \char`\"{}value block\char`\"{} mode, ie with access bits [C1 C2 C3] = [110] or [001].

\begin{DoxyReturn}{Returns}
S\+T\+A\+T\+U\+S\+\_\+\+OK on success, S\+T\+A\+T\+U\+S\+\_\+??? otherwise. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em block\+Addr} & The block (0-\/0xff) number. \\
\hline
\end{DoxyParams}


Definition at line 948 of file M\+F\+R\+C522.\+cpp.



References S\+T\+A\+T\+U\+S\+\_\+\+OK.


\begin{DoxyCode}
949                               \{
950     byte result;
951     byte cmdBuffer[2]; \textcolor{comment}{// We only need room for 2 bytes.}
952 
953     \textcolor{comment}{// Tell the PICC we want to transfer the result into block blockAddr.}
954     cmdBuffer[0] = PICC_CMD_MF_TRANSFER;
955     cmdBuffer[1] = blockAddr;
956     result = PCD_MIFARE_Transceive( cmdBuffer, 2); \textcolor{comment}{// Adds CRC\_A and checks that the response is MF\_ACK.}
957     \textcolor{keywordflow}{if} (result != STATUS_OK) \{
958         \textcolor{keywordflow}{return} result;
959     \}
960     \textcolor{keywordflow}{return} STATUS_OK;
961 \} \textcolor{comment}{// End MIFARE\_Transfer()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a539a88f943326b5941aecf06433d9cac}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!M\+I\+F\+A\+R\+E\+\_\+\+Two\+Step\+Helper@{M\+I\+F\+A\+R\+E\+\_\+\+Two\+Step\+Helper}}
\index{M\+I\+F\+A\+R\+E\+\_\+\+Two\+Step\+Helper@{M\+I\+F\+A\+R\+E\+\_\+\+Two\+Step\+Helper}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{M\+I\+F\+A\+R\+E\+\_\+\+Two\+Step\+Helper()}
{\footnotesize\ttfamily byte M\+F\+R\+C522\+::\+M\+I\+F\+A\+R\+E\+\_\+\+Two\+Step\+Helper (\begin{DoxyParamCaption}\item[{byte}]{command,  }\item[{byte}]{block\+Addr,  }\item[{long}]{data }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}

Helper function for the two-\/step M\+I\+F\+A\+RE Classic protocol operations Decrement, Increment and Restore.

\begin{DoxyReturn}{Returns}
S\+T\+A\+T\+U\+S\+\_\+\+OK on success, S\+T\+A\+T\+U\+S\+\_\+??? otherwise. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em command} & The command to use \\
\hline
{\em block\+Addr} & The block (0-\/0xff) number. \\
\hline
{\em data} & The data to transfer in step 2 \\
\hline
\end{DoxyParams}


Definition at line 917 of file M\+F\+R\+C522.\+cpp.



References S\+T\+A\+T\+U\+S\+\_\+\+OK.


\begin{DoxyCode}
920                                       \{
921     byte result;
922     byte cmdBuffer[2]; \textcolor{comment}{// We only need room for 2 bytes.}
923 
924     \textcolor{comment}{// Step 1: Tell the PICC the command and block address}
925     cmdBuffer[0] = command;
926     cmdBuffer[1] = blockAddr;
927     result = PCD_MIFARE_Transceive( cmdBuffer, 2); \textcolor{comment}{// Adds CRC\_A and checks that the response is MF\_ACK.}
928     \textcolor{keywordflow}{if} (result != STATUS_OK) \{
929         \textcolor{keywordflow}{return} result;
930     \}
931 
932     \textcolor{comment}{// Step 2: Transfer the data}
933     result = PCD_MIFARE_Transceive( (byte *)&data, 4, \textcolor{keyword}{true}); \textcolor{comment}{// Adds CRC\_A and accept timeout as success.}
934     \textcolor{keywordflow}{if} (result != STATUS_OK) \{
935         \textcolor{keywordflow}{return} result;
936     \}
937 
938     \textcolor{keywordflow}{return} STATUS_OK;
939 \} \textcolor{comment}{// End MIFARE\_TwoStepHelper()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_aba2c50d4660897d136cf839940299e07}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!M\+I\+F\+A\+R\+E\+\_\+\+Ultralight\+\_\+\+Write@{M\+I\+F\+A\+R\+E\+\_\+\+Ultralight\+\_\+\+Write}}
\index{M\+I\+F\+A\+R\+E\+\_\+\+Ultralight\+\_\+\+Write@{M\+I\+F\+A\+R\+E\+\_\+\+Ultralight\+\_\+\+Write}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{M\+I\+F\+A\+R\+E\+\_\+\+Ultralight\+\_\+\+Write()}
{\footnotesize\ttfamily byte M\+F\+R\+C522\+::\+M\+I\+F\+A\+R\+E\+\_\+\+Ultralight\+\_\+\+Write (\begin{DoxyParamCaption}\item[{byte}]{page,  }\item[{byte $\ast$}]{buffer,  }\item[{byte}]{buffer\+Size }\end{DoxyParamCaption})}

Writes a 4 byte page to the active M\+I\+F\+A\+RE Ultralight P\+I\+CC.

\begin{DoxyReturn}{Returns}
S\+T\+A\+T\+U\+S\+\_\+\+OK on success, S\+T\+A\+T\+U\+S\+\_\+??? otherwise. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em page} & The page (2-\/15) to write to. \\
\hline
{\em buffer} & The 4 bytes to write to the P\+I\+CC \\
\hline
{\em buffer\+Size} & Buffer size, must be at least 4 bytes. Exactly 4 bytes are written. \\
\hline
\end{DoxyParams}


Definition at line 844 of file M\+F\+R\+C522.\+cpp.



References S\+T\+A\+T\+U\+S\+\_\+\+I\+N\+V\+A\+L\+ID, and S\+T\+A\+T\+U\+S\+\_\+\+OK.


\begin{DoxyCode}
847                                       \{
848     byte result;
849 
850     \textcolor{comment}{// Sanity check}
851     \textcolor{keywordflow}{if} (buffer == NULL || bufferSize < 4) \{
852         \textcolor{keywordflow}{return} STATUS_INVALID;
853     \}
854 
855     \textcolor{comment}{// Build commmand buffer}
856     byte cmdBuffer[6];
857     cmdBuffer[0] = PICC_CMD_UL_WRITE;
858     cmdBuffer[1] = page;
859     memcpy(&cmdBuffer[2], buffer, 4);
860     
861     \textcolor{comment}{// Perform the write}
862     result = PCD_MIFARE_Transceive(cmdBuffer, 6); \textcolor{comment}{// Adds CRC\_A and checks that the response is MF\_ACK.}
863     \textcolor{keywordflow}{if} (result != STATUS_OK) \{
864         \textcolor{keywordflow}{return} result;
865     \}
866     \textcolor{keywordflow}{return} STATUS_OK;
867 \} \textcolor{comment}{// End MIFARE\_Ultralight\_Write()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_afcbb15d925cb3bea9f58595111fbca48}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!M\+I\+F\+A\+R\+E\+\_\+\+Unbrick\+Uid\+Sector@{M\+I\+F\+A\+R\+E\+\_\+\+Unbrick\+Uid\+Sector}}
\index{M\+I\+F\+A\+R\+E\+\_\+\+Unbrick\+Uid\+Sector@{M\+I\+F\+A\+R\+E\+\_\+\+Unbrick\+Uid\+Sector}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{M\+I\+F\+A\+R\+E\+\_\+\+Unbrick\+Uid\+Sector()}
{\footnotesize\ttfamily bool M\+F\+R\+C522\+::\+M\+I\+F\+A\+R\+E\+\_\+\+Unbrick\+Uid\+Sector (\begin{DoxyParamCaption}\item[{bool}]{log\+Errors }\end{DoxyParamCaption})}

Resets entire sector 0 to zeroes, so the card can be read again by readers. 

Definition at line 1617 of file M\+F\+R\+C522.\+cpp.



References M\+I\+F\+A\+R\+E\+\_\+\+Open\+Uid\+Backdoor().


\begin{DoxyCode}
1617                                                     \{
1618     MIFARE_OpenUidBackdoor( logErrors );
1619     
1620     byte block0\_buffer[] = \{0x01, 0x02, 0x03, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
      0x00, 0x00, 0x00\};
1621     
1622     \textcolor{comment}{// Write modified block 0 back to card}
1623     byte status = MIFARE_Write((byte)0, block0\_buffer, (byte)16);
1624     \textcolor{keywordflow}{if} (status != STATUS_OK) \{
1625         \textcolor{keywordflow}{if} ( logErrors ) \{
1626             Serial.print(\textcolor{stringliteral}{"MIFARE\_Write() failed: "});
1627             Serial.println(GetStatusCodeName(status));
1628         \}
1629         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1630     \}
1631 \}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a6f3c1ba843a2484314c72daf2e7734f0}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!M\+I\+F\+A\+R\+E\+\_\+\+Write@{M\+I\+F\+A\+R\+E\+\_\+\+Write}}
\index{M\+I\+F\+A\+R\+E\+\_\+\+Write@{M\+I\+F\+A\+R\+E\+\_\+\+Write}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{M\+I\+F\+A\+R\+E\+\_\+\+Write()}
{\footnotesize\ttfamily byte M\+F\+R\+C522\+::\+M\+I\+F\+A\+R\+E\+\_\+\+Write (\begin{DoxyParamCaption}\item[{byte}]{block\+Addr,  }\item[{byte $\ast$}]{buffer,  }\item[{byte}]{buffer\+Size }\end{DoxyParamCaption})}

Writes 16 bytes to the active P\+I\+CC.

For M\+I\+F\+A\+RE Classic the sector containing the block must be authenticated before calling this function.

For M\+I\+F\+A\+RE Ultralight the opretaion is called \char`\"{}\+C\+O\+M\+P\+A\+T\+I\+B\+I\+L\+I\+T\+Y W\+R\+I\+T\+E\char`\"{}. Even though 16 bytes are transferred to the Ultralight P\+I\+CC, only the least significant 4 bytes (bytes 0 to 3) are written to the specified address. It is recommended to set the remaining bytes 04h to 0\+Fh to all logic 0.
\begin{DoxyItemize}
\item \begin{DoxyReturn}{Returns}
S\+T\+A\+T\+U\+S\+\_\+\+OK on success, S\+T\+A\+T\+U\+S\+\_\+??? otherwise. 
\end{DoxyReturn}

\end{DoxyItemize}
\begin{DoxyParams}{Parameters}
{\em block\+Addr} & M\+I\+F\+A\+RE Classic\+: The block (0-\/0xff) number. M\+I\+F\+A\+RE Ultralight\+: The page (2-\/15) to write to. \\
\hline
{\em buffer} & The 16 bytes to write to the P\+I\+CC \\
\hline
{\em buffer\+Size} & Buffer size, must be at least 16 bytes. Exactly 16 bytes are written. \\
\hline
\end{DoxyParams}


Definition at line 809 of file M\+F\+R\+C522.\+cpp.



References S\+T\+A\+T\+U\+S\+\_\+\+I\+N\+V\+A\+L\+ID, and S\+T\+A\+T\+U\+S\+\_\+\+OK.


\begin{DoxyCode}
812                           \{
813     byte result;
814 
815     \textcolor{comment}{// Sanity check}
816     \textcolor{keywordflow}{if} (buffer == NULL || bufferSize < 16) \{
817         \textcolor{keywordflow}{return} STATUS_INVALID;
818     \}
819 
820     \textcolor{comment}{// Mifare Classic protocol requires two communications to perform a write.}
821     \textcolor{comment}{// Step 1: Tell the PICC we want to write to block blockAddr.}
822     byte cmdBuffer[2];
823     cmdBuffer[0] = PICC_CMD_MF_WRITE;
824     cmdBuffer[1] = blockAddr;
825     result = PCD_MIFARE_Transceive(cmdBuffer, 2); \textcolor{comment}{// Adds CRC\_A and checks that the response is MF\_ACK.}
826     \textcolor{keywordflow}{if} (result != STATUS_OK) \{
827         \textcolor{keywordflow}{return} result;
828     \}
829 
830     \textcolor{comment}{// Step 2: Transfer the data}
831     result = PCD_MIFARE_Transceive( buffer, bufferSize); \textcolor{comment}{// Adds CRC\_A and checks that the response is
       MF\_ACK.}
832     \textcolor{keywordflow}{if} (result != STATUS_OK) \{
833         \textcolor{keywordflow}{return} result;
834     \}
835 
836     \textcolor{keywordflow}{return} STATUS_OK;
837 \} \textcolor{comment}{// End MIFARE\_Write()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a2098ebe85700109b20c5026643f1dad7}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Antenna\+Off@{P\+C\+D\+\_\+\+Antenna\+Off}}
\index{P\+C\+D\+\_\+\+Antenna\+Off@{P\+C\+D\+\_\+\+Antenna\+Off}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+C\+D\+\_\+\+Antenna\+Off()}
{\footnotesize\ttfamily void M\+F\+R\+C522\+::\+P\+C\+D\+\_\+\+Antenna\+Off (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Turns the antenna off by disabling pins T\+X1 and T\+X2. 

Definition at line 250 of file M\+F\+R\+C522.\+cpp.


\begin{DoxyCode}
250                              \{
251     PCD_ClearRegisterBitMask(RFCfgReg, 0x03);
252 \} \textcolor{comment}{// End PCD\_AntennaOff()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a044be037a5f172e9cea7d8ce1dcf32e0}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Antenna\+On@{P\+C\+D\+\_\+\+Antenna\+On}}
\index{P\+C\+D\+\_\+\+Antenna\+On@{P\+C\+D\+\_\+\+Antenna\+On}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+C\+D\+\_\+\+Antenna\+On()}
{\footnotesize\ttfamily void M\+F\+R\+C522\+::\+P\+C\+D\+\_\+\+Antenna\+On (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Turns the antenna on by enabling pins T\+X1 and T\+X2. After a reset these pins disabled. 

Definition at line 240 of file M\+F\+R\+C522.\+cpp.



Referenced by P\+C\+D\+\_\+\+Init().


\begin{DoxyCode}
240                             \{
241     byte value = PCD_ReadRegister(TxControlReg);
242     \textcolor{keywordflow}{if} ((value & 0x03) != 0x03) \{
243         PCD_WriteRegister(TxControlReg, value | 0x03);
244     \}
245 \} \textcolor{comment}{// End PCD\_AntennaOn()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a26469f6295cd9796e0bb781c48036971}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Authenticate@{P\+C\+D\+\_\+\+Authenticate}}
\index{P\+C\+D\+\_\+\+Authenticate@{P\+C\+D\+\_\+\+Authenticate}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+C\+D\+\_\+\+Authenticate()}
{\footnotesize\ttfamily byte M\+F\+R\+C522\+::\+P\+C\+D\+\_\+\+Authenticate (\begin{DoxyParamCaption}\item[{byte}]{command,  }\item[{byte}]{block\+Addr,  }\item[{\textbf{ M\+I\+F\+A\+R\+E\+\_\+\+Key} $\ast$}]{key,  }\item[{\textbf{ Uid} $\ast$}]{uid }\end{DoxyParamCaption})}

Executes the \doxyref{M\+F\+R\+C522}{p.}{class_m_f_r_c522} M\+F\+Authent command. This command manages M\+I\+F\+A\+RE authentication to enable a secure communication to any M\+I\+F\+A\+RE Mini, M\+I\+F\+A\+RE 1K and M\+I\+F\+A\+RE 4K card. The authentication is described in the \doxyref{M\+F\+R\+C522}{p.}{class_m_f_r_c522} datasheet section 10.\+3.\+1.\+9 and {\tt http\+://www.\+nxp.\+com/documents/data\+\_\+sheet/\+M\+F1\+S503x.\+pdf} section 10.\+1. For use with M\+I\+F\+A\+RE Classic P\+I\+C\+Cs. The P\+I\+CC must be selected -\/ ie in state A\+C\+T\+I\+V\+E($\ast$) -\/ before calling this function. Remember to call \doxyref{P\+C\+D\+\_\+\+Stop\+Crypto1()}{p.}{class_m_f_r_c522_a24d3ab7b2170fdfa3f0121a7256f12d9} after communicating with the authenticated P\+I\+CC -\/ otherwise no new communications can start.

All keys are set to F\+F\+F\+F\+F\+F\+F\+F\+F\+F\+F\+Fh at chip delivery.

\begin{DoxyReturn}{Returns}
S\+T\+A\+T\+U\+S\+\_\+\+OK on success, S\+T\+A\+T\+U\+S\+\_\+??? otherwise. Probably S\+T\+A\+T\+U\+S\+\_\+\+T\+I\+M\+E\+O\+UT if you supply the wrong key. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em command} & P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+A\+U\+T\+H\+\_\+\+K\+E\+Y\+\_\+A or P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+A\+U\+T\+H\+\_\+\+K\+E\+Y\+\_\+B \\
\hline
{\em block\+Addr} & The block number. See numbering in the comments in the .h file. \\
\hline
{\em key} & Pointer to the Crypteo1 key to use (6 bytes) \\
\hline
{\em uid} & Pointer to \doxyref{Uid}{p.}{struct_m_f_r_c522_1_1_uid} struct. The first 4 bytes of the U\+ID is used. \\
\hline
\end{DoxyParams}


Definition at line 727 of file M\+F\+R\+C522.\+cpp.


\begin{DoxyCode}
731                                   \{
732     byte waitIRq = 0x10;        \textcolor{comment}{// IdleIRq}
733     
734     \textcolor{comment}{// Build command buffer}
735     byte sendData[12];
736     sendData[0] = command;
737     sendData[1] = blockAddr;
738     \textcolor{keywordflow}{for} (byte i = 0; i < MF_KEY_SIZE; i++) \{    \textcolor{comment}{// 6 key bytes}
739         sendData[2+i] = key->keyByte[i];
740     \}
741     \textcolor{keywordflow}{for} (byte i = 0; i < 4; i++) \{              \textcolor{comment}{// The first 4 bytes of the UID}
742         sendData[8+i] = uid->uidByte[i];
743     \}
744     
745     \textcolor{comment}{// Start the authentication.}
746     \textcolor{keywordflow}{return} PCD_CommunicateWithPICC(PCD_MFAuthent, waitIRq, &sendData[0], \textcolor{keyword}{sizeof}(sendData));
747 \} \textcolor{comment}{// End PCD\_Authenticate()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a96adb3a83724709c622cc50d5518cbc3}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Calculate\+C\+RC@{P\+C\+D\+\_\+\+Calculate\+C\+RC}}
\index{P\+C\+D\+\_\+\+Calculate\+C\+RC@{P\+C\+D\+\_\+\+Calculate\+C\+RC}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+C\+D\+\_\+\+Calculate\+C\+R\+C()}
{\footnotesize\ttfamily byte M\+F\+R\+C522\+::\+P\+C\+D\+\_\+\+Calculate\+C\+RC (\begin{DoxyParamCaption}\item[{byte $\ast$}]{data,  }\item[{byte}]{length,  }\item[{byte $\ast$}]{result }\end{DoxyParamCaption})}

Use the C\+RC coprocessor in the \doxyref{M\+F\+R\+C522}{p.}{class_m_f_r_c522} to calculate a C\+R\+C\+\_\+A.

\begin{DoxyReturn}{Returns}
S\+T\+A\+T\+U\+S\+\_\+\+OK on success, S\+T\+A\+T\+U\+S\+\_\+??? otherwise. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em data} & In\+: Pointer to the data to transfer to the F\+I\+FO for C\+RC calculation. \\
\hline
{\em length} & In\+: The number of bytes to transfer. \\
\hline
{\em result} & Out\+: Pointer to result buffer. Result is written to result[0..1], low byte first. \\
\hline
\end{DoxyParams}


Definition at line 160 of file M\+F\+R\+C522.\+cpp.



References S\+T\+A\+T\+U\+S\+\_\+\+OK, and S\+T\+A\+T\+U\+S\+\_\+\+T\+I\+M\+E\+O\+UT.


\begin{DoxyCode}
163                        \{
164     PCD_WriteRegister(CommandReg, PCD_Idle);            \textcolor{comment}{// Stop any active command.}
165     PCD_WriteRegister(DivIrqReg, 0x04);                 \textcolor{comment}{// Clear the CRCIRq interrupt request bit}
166     PCD_SetRegisterBitMask(FIFOLevelReg, 0x80);     \textcolor{comment}{// FlushBuffer = 1, FIFO initialization}
167     PCD_WriteRegister(FIFODataReg, length, data);       \textcolor{comment}{// Write data to the FIFO}
168     PCD_WriteRegister(CommandReg, PCD_CalcCRC);     \textcolor{comment}{// Start the calculation}
169     
170     \textcolor{comment}{// Wait for the CRC calculation to complete. Each iteration of the while-loop takes 17.73�s.}
171     word i = 5000;
172     byte n;
173     \textcolor{keywordflow}{while} (1) \{
174         n = PCD_ReadRegister(DivIrqReg);    \textcolor{comment}{// DivIrqReg[7..0] bits are: Set2 reserved reserved MfinActIRq 
        reserved CRCIRq reserved reserved}
175         \textcolor{keywordflow}{if} (n & 0x04) \{                     \textcolor{comment}{// CRCIRq bit set - calculation done}
176             \textcolor{keywordflow}{break};
177         \}
178         \textcolor{keywordflow}{if} (--i == 0) \{                     \textcolor{comment}{// The emergency break. We will eventually terminate on this
       one after 89ms. Communication with the MFRC522 might be down.}
179             \textcolor{keywordflow}{return} STATUS_TIMEOUT;
180         \}
181     \}
182     PCD_WriteRegister(CommandReg, PCD_Idle);            \textcolor{comment}{// Stop calculating CRC for new content in the
       FIFO.}
183     
184     \textcolor{comment}{// Transfer the result from the registers to the result buffer}
185     result[0] = PCD_ReadRegister(CRCResultRegL);
186     result[1] = PCD_ReadRegister(CRCResultRegH);
187     \textcolor{keywordflow}{return} STATUS_OK;
188 \} \textcolor{comment}{// End PCD\_CalculateCRC()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a45d4f1b7cdc9eccd9d394d4f5058c503}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Clear\+Register\+Bit\+Mask@{P\+C\+D\+\_\+\+Clear\+Register\+Bit\+Mask}}
\index{P\+C\+D\+\_\+\+Clear\+Register\+Bit\+Mask@{P\+C\+D\+\_\+\+Clear\+Register\+Bit\+Mask}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+C\+D\+\_\+\+Clear\+Register\+Bit\+Mask()}
{\footnotesize\ttfamily void M\+F\+R\+C522\+::\+P\+C\+D\+\_\+\+Clear\+Register\+Bit\+Mask (\begin{DoxyParamCaption}\item[{byte}]{reg,  }\item[{byte}]{mask }\end{DoxyParamCaption})}

Clears the bits given in mask from register reg. 
\begin{DoxyParams}{Parameters}
{\em reg} & The register to update. One of the P\+C\+D\+\_\+\+Register enums. \\
\hline
{\em mask} & The bits to clear. \\
\hline
\end{DoxyParams}


Definition at line 146 of file M\+F\+R\+C522.\+cpp.


\begin{DoxyCode}
148                                         \{
149     byte tmp;
150     tmp = PCD_ReadRegister(reg);
151     PCD_WriteRegister(reg, tmp & (~mask));      \textcolor{comment}{// clear bit mask}
152 \} \textcolor{comment}{// End PCD\_ClearRegisterBitMask()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a731cc27ae35b1bba2d2c9d2af28b5c23}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Communicate\+With\+P\+I\+CC@{P\+C\+D\+\_\+\+Communicate\+With\+P\+I\+CC}}
\index{P\+C\+D\+\_\+\+Communicate\+With\+P\+I\+CC@{P\+C\+D\+\_\+\+Communicate\+With\+P\+I\+CC}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+C\+D\+\_\+\+Communicate\+With\+P\+I\+C\+C()}
{\footnotesize\ttfamily byte M\+F\+R\+C522\+::\+P\+C\+D\+\_\+\+Communicate\+With\+P\+I\+CC (\begin{DoxyParamCaption}\item[{byte}]{command,  }\item[{byte}]{wait\+I\+Rq,  }\item[{byte $\ast$}]{send\+Data,  }\item[{byte}]{send\+Len,  }\item[{byte $\ast$}]{back\+Data = {\ttfamily NULL},  }\item[{byte $\ast$}]{back\+Len = {\ttfamily NULL},  }\item[{byte $\ast$}]{valid\+Bits = {\ttfamily NULL},  }\item[{byte}]{rx\+Align = {\ttfamily 0},  }\item[{bool}]{check\+C\+RC = {\ttfamily false} }\end{DoxyParamCaption})}

Transfers data to the \doxyref{M\+F\+R\+C522}{p.}{class_m_f_r_c522} F\+I\+FO, executes a commend, waits for completion and transfers data back from the F\+I\+FO. C\+RC validation can only be done if back\+Data and back\+Len are specified.

\begin{DoxyReturn}{Returns}
S\+T\+A\+T\+U\+S\+\_\+\+OK on success, S\+T\+A\+T\+U\+S\+\_\+??? otherwise. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em command} & The command to execute. One of the P\+C\+D\+\_\+\+Command enums. \\
\hline
{\em wait\+I\+Rq} & The bits in the Com\+Irq\+Reg register that signals successful completion of the command. \\
\hline
{\em send\+Data} & Pointer to the data to transfer to the F\+I\+FO. \\
\hline
{\em send\+Len} & Number of bytes to transfer to the F\+I\+FO. \\
\hline
{\em back\+Data} & N\+U\+LL or pointer to buffer if data should be read back after executing the command. \\
\hline
{\em back\+Len} & In\+: Max number of bytes to write to $\ast$back\+Data. Out\+: The number of bytes returned. \\
\hline
{\em valid\+Bits} & In/\+Out\+: The number of valid bits in the last byte. 0 for 8 valid bits. \\
\hline
{\em rx\+Align} & In\+: Defines the bit position in back\+Data[0] for the first bit received. Default 0. \\
\hline
{\em check\+C\+RC} & In\+: True =$>$ The last two bytes of the response is assumed to be a C\+R\+C\+\_\+A that must be validated. \\
\hline
\end{DoxyParams}


Definition at line 305 of file M\+F\+R\+C522.\+cpp.



References S\+T\+A\+T\+U\+S\+\_\+\+C\+O\+L\+L\+I\+S\+I\+ON, S\+T\+A\+T\+U\+S\+\_\+\+C\+R\+C\+\_\+\+W\+R\+O\+NG, S\+T\+A\+T\+U\+S\+\_\+\+E\+R\+R\+OR, S\+T\+A\+T\+U\+S\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+N\+A\+CK, S\+T\+A\+T\+U\+S\+\_\+\+N\+O\+\_\+\+R\+O\+OM, S\+T\+A\+T\+U\+S\+\_\+\+OK, and S\+T\+A\+T\+U\+S\+\_\+\+T\+I\+M\+E\+O\+UT.


\begin{DoxyCode}
314                                        \{
315     byte n, \_validBits;
316     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i;
317 
318     \textcolor{comment}{// Prepare values for BitFramingReg}
319     byte txLastBits = validBits ? *validBits : 0;
320     byte bitFraming = (rxAlign << 4) + txLastBits;      \textcolor{comment}{// RxAlign = BitFramingReg[6..4]. TxLastBits =
       BitFramingReg[2..0]}
321     
322     PCD_WriteRegister(CommandReg, PCD_Idle);            \textcolor{comment}{// Stop any active command.}
323     PCD_WriteRegister(ComIrqReg, 0x7F);                 \textcolor{comment}{// Clear all seven interrupt request bits}
324     PCD_SetRegisterBitMask(FIFOLevelReg, 0x80);     \textcolor{comment}{// FlushBuffer = 1, FIFO initialization}
325     PCD_WriteRegister(FIFODataReg, sendLen, sendData);  \textcolor{comment}{// Write sendData to the FIFO}
326     PCD_WriteRegister(BitFramingReg, bitFraming);       \textcolor{comment}{// Bit adjustments}
327     PCD_WriteRegister(CommandReg, command);         \textcolor{comment}{// Execute the command}
328     \textcolor{keywordflow}{if} (command == PCD_Transceive)  \{
329         PCD_SetRegisterBitMask(BitFramingReg, 0x80);    \textcolor{comment}{// StartSend=1, transmission of data starts}
330     \}
331     
332     \textcolor{comment}{// Wait for the command to complete.}
333     \textcolor{comment}{// In PCD\_Init() we set the TAuto flag in TModeReg. This means the timer automatically starts when the
       PCD stops transmitting.}
334     \textcolor{comment}{// Each iteration of the do-while-loop takes 17.86�s.}
335     i = 2000;
336     \textcolor{keywordflow}{while} (1) \{
337         n = PCD_ReadRegister(ComIrqReg);    \textcolor{comment}{// ComIrqReg[7..0] bits are: Set1 TxIRq RxIRq IdleIRq  
       HiAlertIRq LoAlertIRq ErrIRq TimerIRq}
338         \textcolor{keywordflow}{if} (n & waitIRq) \{                  \textcolor{comment}{// One of the interrupts that signal success has been set.}
339             \textcolor{keywordflow}{break};
340         \}
341         \textcolor{keywordflow}{if} (n & 0x01) \{                     \textcolor{comment}{// Timer interrupt - nothing received in 25ms}
342             \textcolor{keywordflow}{return} STATUS_TIMEOUT;
343         \}
344         \textcolor{keywordflow}{if} (--i == 0) \{                     \textcolor{comment}{// The emergency break. If all other condions fail we will
       eventually terminate on this one after 35.7ms. Communication with the MFRC522 might be down.}
345             \textcolor{keywordflow}{return} STATUS_TIMEOUT;
346         \}
347     \}
348     
349     \textcolor{comment}{// Stop now if any errors except collisions were detected.}
350     byte errorRegValue = PCD_ReadRegister(ErrorReg); \textcolor{comment}{// ErrorReg[7..0] bits are: WrErr TempErr reserved
       BufferOvfl   CollErr CRCErr ParityErr ProtocolErr}
351     \textcolor{keywordflow}{if} (errorRegValue & 0x13) \{  \textcolor{comment}{// BufferOvfl ParityErr ProtocolErr}
352         \textcolor{keywordflow}{return} STATUS_ERROR;
353     \}   
354 
355     \textcolor{comment}{// If the caller wants data back, get it from the MFRC522.}
356     \textcolor{keywordflow}{if} (backData && backLen) \{
357         n = PCD_ReadRegister(FIFOLevelReg);                     \textcolor{comment}{// Number of bytes in the FIFO}
358         \textcolor{keywordflow}{if} (n > *backLen) \{
359             \textcolor{keywordflow}{return} STATUS_NO_ROOM;
360         \}
361         *backLen = n;                                               \textcolor{comment}{// Number of bytes returned}
362         PCD_ReadRegister(FIFODataReg, n, backData, rxAlign);        \textcolor{comment}{// Get received data from FIFO}
363         \_validBits = PCD_ReadRegister(ControlReg) & 0x07;   \textcolor{comment}{// RxLastBits[2:0] indicates the number of
       valid bits in the last received byte. If this value is 000b, the whole byte is valid.}
364         \textcolor{keywordflow}{if} (validBits) \{
365             *validBits = \_validBits;
366         \}
367     \}
368     
369     \textcolor{comment}{// Tell about collisions}
370     \textcolor{keywordflow}{if} (errorRegValue & 0x08) \{ \textcolor{comment}{// CollErr}
371         \textcolor{keywordflow}{return} STATUS_COLLISION;
372     \}
373     
374     \textcolor{comment}{// Perform CRC\_A validation if requested.}
375     \textcolor{keywordflow}{if} (backData && backLen && checkCRC) \{
376         \textcolor{comment}{// In this case a MIFARE Classic NAK is not OK.}
377         \textcolor{keywordflow}{if} (*backLen == 1 && \_validBits == 4) \{
378             \textcolor{keywordflow}{return} STATUS_MIFARE_NACK;
379         \}
380         \textcolor{comment}{// We need at least the CRC\_A value and all 8 bits of the last byte must be received.}
381         \textcolor{keywordflow}{if} (*backLen < 2 || \_validBits != 0) \{
382             \textcolor{keywordflow}{return} STATUS_CRC_WRONG;
383         \}
384         \textcolor{comment}{// Verify CRC\_A - do our own calculation and store the control in controlBuffer.}
385         byte controlBuffer[2]; 
386         n = PCD_CalculateCRC(&backData[0], *backLen - 2, &controlBuffer[0]);
387         \textcolor{keywordflow}{if} (n != STATUS_OK) \{
388             \textcolor{keywordflow}{return} n;
389         \}
390         \textcolor{keywordflow}{if} ((backData[*backLen - 2] != controlBuffer[0]) || (backData[*backLen - 1] != controlBuffer[1])) \{
391             \textcolor{keywordflow}{return} STATUS_CRC_WRONG;
392         \}
393     \}
394     
395     \textcolor{keywordflow}{return} STATUS_OK;
396 \} \textcolor{comment}{// End PCD\_CommunicateWithPICC()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_aa02ae994a9ebf146475f46fc538cef28}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Get\+Antenna\+Gain@{P\+C\+D\+\_\+\+Get\+Antenna\+Gain}}
\index{P\+C\+D\+\_\+\+Get\+Antenna\+Gain@{P\+C\+D\+\_\+\+Get\+Antenna\+Gain}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+C\+D\+\_\+\+Get\+Antenna\+Gain()}
{\footnotesize\ttfamily byte M\+F\+R\+C522\+::\+P\+C\+D\+\_\+\+Get\+Antenna\+Gain (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Get the current \doxyref{M\+F\+R\+C522}{p.}{class_m_f_r_c522} Receiver Gain (Rx\+Gain[2\+:0]) value. See 9.\+3.\+3.\+6 / table 98 in {\tt http\+://www.\+nxp.\+com/documents/data\+\_\+sheet/\+M\+F\+R\+C522.\+pdf} N\+O\+TE\+: Return value scrubbed with (0x07$<$$<$4)=01110000b as R\+C\+Ffg\+Reg may use reserved bits.

\begin{DoxyReturn}{Returns}
Value of the Rx\+Gain, scrubbed to the 3 bits used. 
\end{DoxyReturn}


Definition at line 261 of file M\+F\+R\+C522.\+cpp.


\begin{DoxyCode}
261                                  \{
262     \textcolor{keywordflow}{return} PCD_ReadRegister(RFCfgReg) & (0x07<<4);
263 \} \textcolor{comment}{// End PCD\_GetAntennaGain()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_ad681e424fc68a57941bea5702cee05eb}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Init@{P\+C\+D\+\_\+\+Init}}
\index{P\+C\+D\+\_\+\+Init@{P\+C\+D\+\_\+\+Init}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+C\+D\+\_\+\+Init()}
{\footnotesize\ttfamily void M\+F\+R\+C522\+::\+P\+C\+D\+\_\+\+Init (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Initializes the \doxyref{M\+F\+R\+C522}{p.}{class_m_f_r_c522} chip. 

Definition at line 198 of file M\+F\+R\+C522.\+cpp.



References P\+C\+D\+\_\+\+Antenna\+On(), and P\+C\+D\+\_\+\+Reset().


\begin{DoxyCode}
198                        \{
199     \textcolor{keywordflow}{if} (digitalRead(_resetPowerDownPin) == LOW) \{ \textcolor{comment}{//The MFRC522 chip is in power down mode.}
200         digitalWrite(_resetPowerDownPin, HIGH); \textcolor{comment}{// Exit power down mode. This triggers a hard reset.}
201         \textcolor{comment}{// Section 8.8.2 in the datasheet says the oscillator start-up time is the start up time of the
       crystal + 37,74�s. Let us be generous: 50ms.}
202         delay(50);
203     \}
204     \textcolor{keywordflow}{else} \{ \textcolor{comment}{// Perform a soft reset}
205         PCD_Reset();
206     \}
207     
208     \textcolor{comment}{// When communicating with a PICC we need a timeout if something goes wrong.}
209     \textcolor{comment}{// f\_timer = 13.56 MHz / (2*TPreScaler+1) where TPreScaler = [TPrescaler\_Hi:TPrescaler\_Lo].}
210     \textcolor{comment}{// TPrescaler\_Hi are the four low bits in TModeReg. TPrescaler\_Lo is TPrescalerReg.}
211     PCD_WriteRegister(TModeReg, 0x80);          \textcolor{comment}{// TAuto=1; timer starts automatically at the end of the
       transmission in all communication modes at all speeds}
212     PCD_WriteRegister(TPrescalerReg, 0xA9); \textcolor{comment}{// TPreScaler = TModeReg[3..0]:TPrescalerReg, ie 0x0A9 = 169 =>
       f\_timer=40kHz, ie a timer period of 25�s.}
213     PCD_WriteRegister(TReloadRegH, 0x03);       \textcolor{comment}{// Reload timer with 0x3E8 = 1000, ie 25ms before timeout.}
214     PCD_WriteRegister(TReloadRegL, 0xE8);
215     
216     PCD_WriteRegister(TxASKReg, 0x40);      \textcolor{comment}{// Default 0x00. Force a 100 % ASK modulation independent of
       the ModGsPReg register setting}
217     PCD_WriteRegister(ModeReg, 0x3D);       \textcolor{comment}{// Default 0x3F. Set the preset value for the CRC coprocessor
       for the CalcCRC command to 0x6363 (ISO 14443-3 part 6.2.4)}
218     PCD_AntennaOn();                        \textcolor{comment}{// Enable the antenna driver pins TX1 and TX2 (they were
       disabled by the reset)}
219 \} \textcolor{comment}{// End PCD\_Init()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a638bcf89cd6356cfbc755004a2e62b1c}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+Transceive@{P\+C\+D\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+Transceive}}
\index{P\+C\+D\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+Transceive@{P\+C\+D\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+Transceive}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+C\+D\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+Transceive()}
{\footnotesize\ttfamily byte M\+F\+R\+C522\+::\+P\+C\+D\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+Transceive (\begin{DoxyParamCaption}\item[{byte $\ast$}]{send\+Data,  }\item[{byte}]{send\+Len,  }\item[{bool}]{accept\+Timeout = {\ttfamily false} }\end{DoxyParamCaption})}

Wrapper for M\+I\+F\+A\+RE protocol communication. Adds C\+R\+C\+\_\+A, executes the Transceive command and checks that the response is M\+F\+\_\+\+A\+CK or a timeout.

\begin{DoxyReturn}{Returns}
S\+T\+A\+T\+U\+S\+\_\+\+OK on success, S\+T\+A\+T\+U\+S\+\_\+??? otherwise. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em send\+Data} & Pointer to the data to transfer to the F\+I\+FO. Do N\+OT include the C\+R\+C\+\_\+A. \\
\hline
{\em send\+Len} & Number of bytes in send\+Data. \\
\hline
{\em accept\+Timeout} & True =$>$ A timeout is also success \\
\hline
\end{DoxyParams}


Definition at line 1032 of file M\+F\+R\+C522.\+cpp.



References S\+T\+A\+T\+U\+S\+\_\+\+E\+R\+R\+OR, S\+T\+A\+T\+U\+S\+\_\+\+I\+N\+V\+A\+L\+ID, S\+T\+A\+T\+U\+S\+\_\+\+M\+I\+F\+A\+R\+E\+\_\+\+N\+A\+CK, and S\+T\+A\+T\+U\+S\+\_\+\+OK.


\begin{DoxyCode}
1035                                       \{
1036     byte result;
1037     byte cmdBuffer[18]; \textcolor{comment}{// We need room for 16 bytes data and 2 bytes CRC\_A.}
1038 
1039     \textcolor{comment}{// Sanity check}
1040     \textcolor{keywordflow}{if} (sendData == NULL || sendLen > 16) \{
1041         \textcolor{keywordflow}{return} STATUS_INVALID;
1042     \}
1043     
1044     \textcolor{comment}{// Copy sendData[] to cmdBuffer[] and add CRC\_A}
1045     memcpy(cmdBuffer, sendData, sendLen);
1046     result = PCD_CalculateCRC(cmdBuffer, sendLen, &cmdBuffer[sendLen]);
1047     \textcolor{keywordflow}{if} (result != STATUS_OK) \{ 
1048         \textcolor{keywordflow}{return} result;
1049     \}
1050     sendLen += 2;
1051     
1052     \textcolor{comment}{// Transceive the data, store the reply in cmdBuffer[]}
1053     byte waitIRq = 0x30;        \textcolor{comment}{// RxIRq and IdleIRq}
1054     byte cmdBufferSize = \textcolor{keyword}{sizeof}(cmdBuffer);
1055     byte validBits = 0;
1056     result = PCD_CommunicateWithPICC(PCD_Transceive, waitIRq, cmdBuffer, sendLen, cmdBuffer, &cmdBufferSize
      , &validBits);
1057     \textcolor{keywordflow}{if} (acceptTimeout && result == STATUS_TIMEOUT) \{
1058         \textcolor{keywordflow}{return} STATUS_OK;
1059     \}
1060     \textcolor{keywordflow}{if} (result != STATUS_OK) \{
1061         \textcolor{keywordflow}{return} result;
1062     \}
1063     \textcolor{comment}{// The PICC must reply with a 4 bit ACK}
1064     \textcolor{keywordflow}{if} (cmdBufferSize != 1 || validBits != 4) \{
1065         \textcolor{keywordflow}{return} STATUS_ERROR;
1066     \}
1067     \textcolor{keywordflow}{if} (cmdBuffer[0] != MF_ACK) \{
1068         \textcolor{keywordflow}{return} STATUS_MIFARE_NACK;
1069     \}
1070     \textcolor{keywordflow}{return} STATUS_OK;
1071 \} \textcolor{comment}{// End PCD\_MIFARE\_Transceive()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a4d81572f8b9ed0ffb1f59270cdffc310}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Read\+Register@{P\+C\+D\+\_\+\+Read\+Register}}
\index{P\+C\+D\+\_\+\+Read\+Register@{P\+C\+D\+\_\+\+Read\+Register}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+C\+D\+\_\+\+Read\+Register()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily byte M\+F\+R\+C522\+::\+P\+C\+D\+\_\+\+Read\+Register (\begin{DoxyParamCaption}\item[{byte}]{reg }\end{DoxyParamCaption})}

Reads a byte from the specified register in the \doxyref{M\+F\+R\+C522}{p.}{class_m_f_r_c522} chip. The interface is described in the datasheet section 8.\+1.\+2. 
\begin{DoxyParams}{Parameters}
{\em reg} & The register to read from. One of the P\+C\+D\+\_\+\+Register enums. \\
\hline
\end{DoxyParams}


Definition at line 83 of file M\+F\+R\+C522.\+cpp.


\begin{DoxyCode}
84                                   \{
85     byte value;
86     digitalWrite(_chipSelectPin, LOW);          \textcolor{comment}{// Select slave}
87     SPI.transfer(0x80 | (reg & 0x7E));          \textcolor{comment}{// MSB == 1 is for reading. LSB is not used in address.
       Datasheet section 8.1.2.3.}
88     value = SPI.transfer(0);                    \textcolor{comment}{// Read the value back. Send 0 to stop reading.}
89     digitalWrite(_chipSelectPin, HIGH);         \textcolor{comment}{// Release slave again}
90     \textcolor{keywordflow}{return} value;
91 \} \textcolor{comment}{// End PCD\_ReadRegister()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_ad5960b7bc42a9a3ebfa7ccf390ffc356}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Read\+Register@{P\+C\+D\+\_\+\+Read\+Register}}
\index{P\+C\+D\+\_\+\+Read\+Register@{P\+C\+D\+\_\+\+Read\+Register}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+C\+D\+\_\+\+Read\+Register()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void M\+F\+R\+C522\+::\+P\+C\+D\+\_\+\+Read\+Register (\begin{DoxyParamCaption}\item[{byte}]{reg,  }\item[{byte}]{count,  }\item[{byte $\ast$}]{values,  }\item[{byte}]{rx\+Align = {\ttfamily 0} }\end{DoxyParamCaption})}

Reads a number of bytes from the specified register in the \doxyref{M\+F\+R\+C522}{p.}{class_m_f_r_c522} chip. The interface is described in the datasheet section 8.\+1.\+2. 
\begin{DoxyParams}{Parameters}
{\em reg} & The register to read from. One of the P\+C\+D\+\_\+\+Register enums. \\
\hline
{\em count} & The number of bytes to read \\
\hline
{\em values} & Byte array to store the values in. \\
\hline
{\em rx\+Align} & Only bit positions rx\+Align..7 in values[0] are updated. \\
\hline
\end{DoxyParams}


Definition at line 97 of file M\+F\+R\+C522.\+cpp.


\begin{DoxyCode}
101                                   \{
102     \textcolor{keywordflow}{if} (count == 0) \{
103         \textcolor{keywordflow}{return};
104     \}
105     \textcolor{comment}{//Serial.print("Reading ");     Serial.print(count); Serial.println(" bytes from register.");}
106     byte address = 0x80 | (reg & 0x7E);     \textcolor{comment}{// MSB == 1 is for reading. LSB is not used in address.
       Datasheet section 8.1.2.3.}
107     byte index = 0;                         \textcolor{comment}{// Index in values array.}
108     digitalWrite(_chipSelectPin, LOW);      \textcolor{comment}{// Select slave}
109     count--;                                \textcolor{comment}{// One read is performed outside of the loop}
110     SPI.transfer(address);                  \textcolor{comment}{// Tell MFRC522 which address we want to read}
111     \textcolor{keywordflow}{while} (index < count) \{
112         \textcolor{keywordflow}{if} (index == 0 && rxAlign) \{ \textcolor{comment}{// Only update bit positions rxAlign..7 in values[0]}
113             \textcolor{comment}{// Create bit mask for bit positions rxAlign..7}
114             byte mask = 0;
115             \textcolor{keywordflow}{for} (byte i = rxAlign; i <= 7; i++) \{
116                 mask |= (1 << i);
117             \}
118             \textcolor{comment}{// Read value and tell that we want to read the same address again.}
119             byte value = SPI.transfer(address); 
120             \textcolor{comment}{// Apply mask to both current value of values[0] and the new data in value.}
121             values[0] = (values[index] & ~mask) | (value & mask);
122         \}
123         \textcolor{keywordflow}{else} \{ \textcolor{comment}{// Normal case}
124             values[index] = SPI.transfer(address);  \textcolor{comment}{// Read value and tell that we want to read the same
       address again.}
125         \}
126         index++;
127     \}
128     values[index] = SPI.transfer(0);            \textcolor{comment}{// Read the final byte. Send 0 to stop reading.}
129     digitalWrite(_chipSelectPin, HIGH);         \textcolor{comment}{// Release slave again}
130 \} \textcolor{comment}{// End PCD\_ReadRegister()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a9886678ea0a65021bf602cfb110caa15}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Reset@{P\+C\+D\+\_\+\+Reset}}
\index{P\+C\+D\+\_\+\+Reset@{P\+C\+D\+\_\+\+Reset}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+C\+D\+\_\+\+Reset()}
{\footnotesize\ttfamily void M\+F\+R\+C522\+::\+P\+C\+D\+\_\+\+Reset (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Performs a soft reset on the \doxyref{M\+F\+R\+C522}{p.}{class_m_f_r_c522} chip and waits for it to be ready again. 

Definition at line 224 of file M\+F\+R\+C522.\+cpp.



Referenced by P\+C\+D\+\_\+\+Init().


\begin{DoxyCode}
224                         \{
225     PCD_WriteRegister(CommandReg, PCD_SoftReset);   \textcolor{comment}{// Issue the SoftReset command.}
226     \textcolor{comment}{// The datasheet does not mention how long the SoftRest command takes to complete.}
227     \textcolor{comment}{// But the MFRC522 might have been in soft power-down mode (triggered by bit 4 of CommandReg) }
228     \textcolor{comment}{// Section 8.8.2 in the datasheet says the oscillator start-up time is the start up time of the crystal
       + 37,74�s. Let us be generous: 50ms.}
229     delay(50);
230     \textcolor{comment}{// Wait for the PowerDown bit in CommandReg to be cleared}
231     \textcolor{keywordflow}{while} (PCD_ReadRegister(CommandReg) & (1<<4)) \{
232         \textcolor{comment}{// PCD still restarting - unlikely after waiting 50ms, but better safe than sorry.}
233     \}
234 \} \textcolor{comment}{// End PCD\_Reset()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a5ce84dd855f2ae297dd00fafaf62ef78}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Set\+Antenna\+Gain@{P\+C\+D\+\_\+\+Set\+Antenna\+Gain}}
\index{P\+C\+D\+\_\+\+Set\+Antenna\+Gain@{P\+C\+D\+\_\+\+Set\+Antenna\+Gain}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+C\+D\+\_\+\+Set\+Antenna\+Gain()}
{\footnotesize\ttfamily void M\+F\+R\+C522\+::\+P\+C\+D\+\_\+\+Set\+Antenna\+Gain (\begin{DoxyParamCaption}\item[{byte}]{mask }\end{DoxyParamCaption})}

Set the \doxyref{M\+F\+R\+C522}{p.}{class_m_f_r_c522} Receiver Gain (Rx\+Gain) to value specified by given mask. See 9.\+3.\+3.\+6 / table 98 in {\tt http\+://www.\+nxp.\+com/documents/data\+\_\+sheet/\+M\+F\+R\+C522.\+pdf} N\+O\+TE\+: Given mask is scrubbed with (0x07$<$$<$4)=01110000b as R\+C\+Ffg\+Reg may use reserved bits. 

Definition at line 270 of file M\+F\+R\+C522.\+cpp.


\begin{DoxyCode}
270                                           \{
271     \textcolor{keywordflow}{if} (PCD_GetAntennaGain() != mask) \{                     \textcolor{comment}{// only bother if there is a change}
272         PCD_ClearRegisterBitMask(RFCfgReg, (0x07<<4));      \textcolor{comment}{// clear needed to allow 000 pattern}
273         PCD_SetRegisterBitMask(RFCfgReg, mask & (0x07<<4)); \textcolor{comment}{// only set RxGain[2:0] bits}
274     \}
275 \} \textcolor{comment}{// End PCD\_SetAntennaGain()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_adef7552eb0089496522153e7bad19d63}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Set\+Register\+Bit\+Mask@{P\+C\+D\+\_\+\+Set\+Register\+Bit\+Mask}}
\index{P\+C\+D\+\_\+\+Set\+Register\+Bit\+Mask@{P\+C\+D\+\_\+\+Set\+Register\+Bit\+Mask}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+C\+D\+\_\+\+Set\+Register\+Bit\+Mask()}
{\footnotesize\ttfamily void M\+F\+R\+C522\+::\+P\+C\+D\+\_\+\+Set\+Register\+Bit\+Mask (\begin{DoxyParamCaption}\item[{byte}]{reg,  }\item[{byte}]{mask }\end{DoxyParamCaption})}

Sets the bits given in mask in register reg. 
\begin{DoxyParams}{Parameters}
{\em reg} & The register to update. One of the P\+C\+D\+\_\+\+Register enums. \\
\hline
{\em mask} & The bits to set. \\
\hline
\end{DoxyParams}


Definition at line 135 of file M\+F\+R\+C522.\+cpp.


\begin{DoxyCode}
137                                       \{ 
138     byte tmp;
139     tmp = PCD_ReadRegister(reg);
140     PCD_WriteRegister(reg, tmp | mask);         \textcolor{comment}{// set bit mask}
141 \} \textcolor{comment}{// End PCD\_SetRegisterBitMask()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a24d3ab7b2170fdfa3f0121a7256f12d9}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Stop\+Crypto1@{P\+C\+D\+\_\+\+Stop\+Crypto1}}
\index{P\+C\+D\+\_\+\+Stop\+Crypto1@{P\+C\+D\+\_\+\+Stop\+Crypto1}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+C\+D\+\_\+\+Stop\+Crypto1()}
{\footnotesize\ttfamily void M\+F\+R\+C522\+::\+P\+C\+D\+\_\+\+Stop\+Crypto1 (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Used to exit the P\+CD from its authenticated state. Remember to call this function after communicating with an authenticated P\+I\+CC -\/ otherwise no new communications can start. 

Definition at line 753 of file M\+F\+R\+C522.\+cpp.



Referenced by M\+I\+F\+A\+R\+E\+\_\+\+Set\+Uid(), and P\+I\+C\+C\+\_\+\+Dump\+Mifare\+Classic\+To\+Serial().


\begin{DoxyCode}
753                               \{
754     \textcolor{comment}{// Clear MFCrypto1On bit}
755     PCD_ClearRegisterBitMask(Status2Reg, 0x08); \textcolor{comment}{// Status2Reg[7..0] bits are: TempSensClear I2CForceHS
       reserved reserved   MFCrypto1On ModemState[2:0]}
756 \} \textcolor{comment}{// End PCD\_StopCrypto1()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a4d967509ca687fca2dbfd0d867b38d8d}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Transceive\+Data@{P\+C\+D\+\_\+\+Transceive\+Data}}
\index{P\+C\+D\+\_\+\+Transceive\+Data@{P\+C\+D\+\_\+\+Transceive\+Data}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+C\+D\+\_\+\+Transceive\+Data()}
{\footnotesize\ttfamily byte M\+F\+R\+C522\+::\+P\+C\+D\+\_\+\+Transceive\+Data (\begin{DoxyParamCaption}\item[{byte $\ast$}]{send\+Data,  }\item[{byte}]{send\+Len,  }\item[{byte $\ast$}]{back\+Data,  }\item[{byte $\ast$}]{back\+Len,  }\item[{byte $\ast$}]{valid\+Bits = {\ttfamily NULL},  }\item[{byte}]{rx\+Align = {\ttfamily 0},  }\item[{bool}]{check\+C\+RC = {\ttfamily false} }\end{DoxyParamCaption})}

Executes the Transceive command. C\+RC validation can only be done if back\+Data and back\+Len are specified.

\begin{DoxyReturn}{Returns}
S\+T\+A\+T\+U\+S\+\_\+\+OK on success, S\+T\+A\+T\+U\+S\+\_\+??? otherwise. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em send\+Data} & Pointer to the data to transfer to the F\+I\+FO. \\
\hline
{\em send\+Len} & Number of bytes to transfer to the F\+I\+FO. \\
\hline
{\em back\+Data} & N\+U\+LL or pointer to buffer if data should be read back after executing the command. \\
\hline
{\em back\+Len} & In\+: Max number of bytes to write to $\ast$back\+Data. Out\+: The number of bytes returned. \\
\hline
{\em valid\+Bits} & In/\+Out\+: The number of valid bits in the last byte. 0 for 8 valid bits. Default N\+U\+LL. \\
\hline
{\em rx\+Align} & In\+: Defines the bit position in back\+Data[0] for the first bit received. Default 0. \\
\hline
{\em check\+C\+RC} & In\+: True =$>$ The last two bytes of the response is assumed to be a C\+R\+C\+\_\+A that must be validated. \\
\hline
\end{DoxyParams}


Definition at line 287 of file M\+F\+R\+C522.\+cpp.


\begin{DoxyCode}
294                                    \{
295     byte waitIRq = 0x30;        \textcolor{comment}{// RxIRq and IdleIRq}
296     \textcolor{keywordflow}{return} PCD_CommunicateWithPICC(PCD_Transceive, waitIRq, sendData, sendLen, backData, backLen, validBits
      , rxAlign, checkCRC);
297 \} \textcolor{comment}{// End PCD\_TransceiveData()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_aa97f1faf2a4c82b911d7c3ed2535bb59}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Write\+Register@{P\+C\+D\+\_\+\+Write\+Register}}
\index{P\+C\+D\+\_\+\+Write\+Register@{P\+C\+D\+\_\+\+Write\+Register}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+C\+D\+\_\+\+Write\+Register()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void M\+F\+R\+C522\+::\+P\+C\+D\+\_\+\+Write\+Register (\begin{DoxyParamCaption}\item[{byte}]{reg,  }\item[{byte}]{value }\end{DoxyParamCaption})}

Writes a byte to the specified register in the \doxyref{M\+F\+R\+C522}{p.}{class_m_f_r_c522} chip. The interface is described in the datasheet section 8.\+1.\+2. 
\begin{DoxyParams}{Parameters}
{\em reg} & The register to write to. One of the P\+C\+D\+\_\+\+Register enums. \\
\hline
{\em value} & The value to write. \\
\hline
\end{DoxyParams}


Definition at line 54 of file M\+F\+R\+C522.\+cpp.


\begin{DoxyCode}
56                                   \{
57     digitalWrite(_chipSelectPin, LOW);      \textcolor{comment}{// Select slave}
58     SPI.transfer(reg & 0x7E);                   \textcolor{comment}{// MSB == 0 is for writing. LSB is not used in address.
       Datasheet section 8.1.2.3.}
59     SPI.transfer(value);
60     digitalWrite(_chipSelectPin, HIGH);     \textcolor{comment}{// Release slave again}
61 \} \textcolor{comment}{// End PCD\_WriteRegister()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a2141779996fc50861aafb89f9d12a163}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+C\+D\+\_\+\+Write\+Register@{P\+C\+D\+\_\+\+Write\+Register}}
\index{P\+C\+D\+\_\+\+Write\+Register@{P\+C\+D\+\_\+\+Write\+Register}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+C\+D\+\_\+\+Write\+Register()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void M\+F\+R\+C522\+::\+P\+C\+D\+\_\+\+Write\+Register (\begin{DoxyParamCaption}\item[{byte}]{reg,  }\item[{byte}]{count,  }\item[{byte $\ast$}]{values }\end{DoxyParamCaption})}

Writes a number of bytes to the specified register in the \doxyref{M\+F\+R\+C522}{p.}{class_m_f_r_c522} chip. The interface is described in the datasheet section 8.\+1.\+2. 
\begin{DoxyParams}{Parameters}
{\em reg} & The register to write to. One of the P\+C\+D\+\_\+\+Register enums. \\
\hline
{\em count} & The number of bytes to write to the register \\
\hline
{\em values} & The values to write. Byte array. \\
\hline
\end{DoxyParams}


Definition at line 67 of file M\+F\+R\+C522.\+cpp.


\begin{DoxyCode}
70                                   \{
71     digitalWrite(_chipSelectPin, LOW);      \textcolor{comment}{// Select slave}
72     SPI.transfer(reg & 0x7E);               \textcolor{comment}{// MSB == 0 is for writing. LSB is not used in address.
       Datasheet section 8.1.2.3.}
73     \textcolor{keywordflow}{for} (byte index = 0; index < count; index++) \{
74         SPI.transfer(values[index]);
75     \}
76     digitalWrite(_chipSelectPin, HIGH);     \textcolor{comment}{// Release slave again}
77 \} \textcolor{comment}{// End PCD\_WriteRegister()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a20c559f09927a7c5f91295f6158e4342}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+Dump\+Mifare\+Classic\+Sector\+To\+Serial@{P\+I\+C\+C\+\_\+\+Dump\+Mifare\+Classic\+Sector\+To\+Serial}}
\index{P\+I\+C\+C\+\_\+\+Dump\+Mifare\+Classic\+Sector\+To\+Serial@{P\+I\+C\+C\+\_\+\+Dump\+Mifare\+Classic\+Sector\+To\+Serial}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+I\+C\+C\+\_\+\+Dump\+Mifare\+Classic\+Sector\+To\+Serial()}
{\footnotesize\ttfamily void M\+F\+R\+C522\+::\+P\+I\+C\+C\+\_\+\+Dump\+Mifare\+Classic\+Sector\+To\+Serial (\begin{DoxyParamCaption}\item[{\textbf{ Uid} $\ast$}]{uid,  }\item[{\textbf{ M\+I\+F\+A\+R\+E\+\_\+\+Key} $\ast$}]{key,  }\item[{byte}]{sector }\end{DoxyParamCaption})}

Dumps memory contents of a sector of a M\+I\+F\+A\+RE Classic P\+I\+CC. Uses \doxyref{P\+C\+D\+\_\+\+Authenticate()}{p.}{class_m_f_r_c522_a26469f6295cd9796e0bb781c48036971}, \doxyref{M\+I\+F\+A\+R\+E\+\_\+\+Read()}{p.}{class_m_f_r_c522_a05cdd51aa162e37de1a9439b75901e28} and P\+C\+D\+\_\+\+Stop\+Crypto1. Always uses P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+M\+F\+\_\+\+A\+U\+T\+H\+\_\+\+K\+E\+Y\+\_\+A because only Key A can always read the sector trailer access bits. 
\begin{DoxyParams}{Parameters}
{\em uid} & Pointer to \doxyref{Uid}{p.}{struct_m_f_r_c522_1_1_uid} struct returned from a successful \doxyref{P\+I\+C\+C\+\_\+\+Select()}{p.}{class_m_f_r_c522_ab40449ac80501db28d25889612bb2db0}. \\
\hline
{\em key} & Key A for the sector. \\
\hline
{\em sector} & The sector to dump, 0..39. \\
\hline
\end{DoxyParams}


Definition at line 1249 of file M\+F\+R\+C522.\+cpp.


\begin{DoxyCode}
1252                                                       \{
1253     byte status;
1254     byte firstBlock;        \textcolor{comment}{// Address of lowest address to dump actually last block dumped)}
1255     byte no\_of\_blocks;      \textcolor{comment}{// Number of blocks in sector}
1256     \textcolor{keywordtype}{bool} isSectorTrailer;   \textcolor{comment}{// Set to true while handling the "last" (ie highest address) in the sector.}
1257 
1258     \textcolor{comment}{// The access bits are stored in a peculiar fashion.}
1259     \textcolor{comment}{// There are four groups:}
1260     \textcolor{comment}{//      g[3]    Access bits for the sector trailer, block 3 (for sectors 0-31) or block 15 (for sectors
       32-39)}
1261     \textcolor{comment}{//      g[2]    Access bits for block 2 (for sectors 0-31) or blocks 10-14 (for sectors 32-39)}
1262     \textcolor{comment}{//      g[1]    Access bits for block 1 (for sectors 0-31) or blocks 5-9 (for sectors 32-39)}
1263     \textcolor{comment}{//      g[0]    Access bits for block 0 (for sectors 0-31) or blocks 0-4 (for sectors 32-39)}
1264     \textcolor{comment}{// Each group has access bits [C1 C2 C3]. In this code C1 is MSB and C3 is LSB.}
1265     \textcolor{comment}{// The four CX bits are stored together in a nible cx and an inverted nible cx\_.}
1266     byte c1, c2, c3;        \textcolor{comment}{// Nibbles}
1267     byte c1\_, c2\_, c3\_;     \textcolor{comment}{// Inverted nibbles}
1268     \textcolor{keywordtype}{bool} invertedError;     \textcolor{comment}{// True if one of the inverted nibbles did not match}
1269     byte g[4];              \textcolor{comment}{// Access bits for each of the four groups.}
1270     byte group;             \textcolor{comment}{// 0-3 - active group for access bits}
1271     \textcolor{keywordtype}{bool} firstInGroup;      \textcolor{comment}{// True for the first block dumped in the group}
1272 
1273     \textcolor{comment}{// Determine position and size of sector.}
1274     \textcolor{keywordflow}{if} (sector < 32) \{ \textcolor{comment}{// Sectors 0..31 has 4 blocks each}
1275         no\_of\_blocks = 4;
1276         firstBlock = sector * no\_of\_blocks;
1277     \}
1278     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (sector < 40) \{ \textcolor{comment}{// Sectors 32-39 has 16 blocks each}
1279         no\_of\_blocks = 16;
1280         firstBlock = 128 + (sector - 32) * no\_of\_blocks;
1281     \}
1282     \textcolor{keywordflow}{else} \{ \textcolor{comment}{// Illegal input, no MIFARE Classic PICC has more than 40 sectors.}
1283         \textcolor{keywordflow}{return};
1284     \}
1285         
1286     \textcolor{comment}{// Dump blocks, highest address first.}
1287     byte byteCount;
1288     byte buffer[18];
1289     byte blockAddr;
1290     isSectorTrailer = \textcolor{keyword}{true};
1291     \textcolor{keywordflow}{for} (int8\_t blockOffset = no\_of\_blocks - 1; blockOffset >= 0; blockOffset--) \{
1292         blockAddr = firstBlock + blockOffset;
1293         \textcolor{comment}{// Sector number - only on first line}
1294         \textcolor{keywordflow}{if} (isSectorTrailer) \{
1295             Serial.print(sector < 10 ? \textcolor{stringliteral}{"   "} : \textcolor{stringliteral}{"  "}); \textcolor{comment}{// Pad with spaces}
1296             Serial.print(sector);
1297             Serial.print(\textcolor{stringliteral}{"   "});
1298         \}
1299         \textcolor{keywordflow}{else} \{
1300             Serial.print(\textcolor{stringliteral}{"       "});
1301         \}
1302         \textcolor{comment}{// Block number}
1303         Serial.print(blockAddr < 10 ? \textcolor{stringliteral}{"   "} : (blockAddr < 100 ? \textcolor{stringliteral}{"  "}    : \textcolor{stringliteral}{" "})); \textcolor{comment}{// Pad with spaces}
1304         Serial.print(blockAddr);
1305         Serial.print(\textcolor{stringliteral}{"  "});
1306         \textcolor{comment}{// Establish encrypted communications before reading the first block}
1307         \textcolor{keywordflow}{if} (isSectorTrailer) \{
1308             status = PCD_Authenticate(PICC_CMD_MF_AUTH_KEY_A, firstBlock, key, 
      uid);
1309             \textcolor{keywordflow}{if} (status != STATUS_OK) \{
1310                 Serial.print(\textcolor{stringliteral}{"PCD\_Authenticate() failed: "});
1311                 Serial.println(GetStatusCodeName(status));
1312                 \textcolor{keywordflow}{return};
1313             \}
1314         \}
1315         \textcolor{comment}{// Read block}
1316         byteCount = \textcolor{keyword}{sizeof}(buffer);
1317         status = MIFARE_Read(blockAddr, buffer, &byteCount);
1318         \textcolor{keywordflow}{if} (status != STATUS_OK) \{
1319             Serial.print(\textcolor{stringliteral}{"MIFARE\_Read() failed: "});
1320             Serial.println(GetStatusCodeName(status));
1321             \textcolor{keywordflow}{continue};
1322         \}
1323         \textcolor{comment}{// Dump data}
1324         \textcolor{keywordflow}{for} (byte index = 0; index < 16; index++) \{
1325             Serial.print(buffer[index] < 0x10 ? \textcolor{stringliteral}{" 0"} : \textcolor{stringliteral}{" "});
1326             Serial.print(buffer[index], HEX);
1327             \textcolor{keywordflow}{if} ((index % 4) == 3) \{
1328                 Serial.print(\textcolor{stringliteral}{" "});
1329             \}
1330         \}
1331         \textcolor{comment}{// Parse sector trailer data}
1332         \textcolor{keywordflow}{if} (isSectorTrailer) \{
1333             c1  = buffer[7] >> 4;
1334             c2  = buffer[8] & 0xF;
1335             c3  = buffer[8] >> 4;
1336             c1\_ = buffer[6] & 0xF;
1337             c2\_ = buffer[6] >> 4;
1338             c3\_ = buffer[7] & 0xF;
1339             invertedError = (c1 != (~c1\_ & 0xF)) || (c2 != (~c2\_ & 0xF)) || (c3 != (~c3\_ & 0xF));
1340             g[0] = ((c1 & 1) << 2) | ((c2 & 1) << 1) | ((c3 & 1) << 0);
1341             g[1] = ((c1 & 2) << 1) | ((c2 & 2) << 0) | ((c3 & 2) >> 1);
1342             g[2] = ((c1 & 4) << 0) | ((c2 & 4) >> 1) | ((c3 & 4) >> 2);
1343             g[3] = ((c1 & 8) >> 1) | ((c2 & 8) >> 2) | ((c3 & 8) >> 3);
1344             isSectorTrailer = \textcolor{keyword}{false};
1345         \}
1346 
1347         \textcolor{comment}{// Which access group is this block in?}
1348         \textcolor{keywordflow}{if} (no\_of\_blocks == 4) \{
1349             group = blockOffset;
1350             firstInGroup = \textcolor{keyword}{true};
1351         \}
1352         \textcolor{keywordflow}{else} \{
1353             group = blockOffset / 5;
1354             firstInGroup = (group == 3) || (group != (blockOffset + 1) / 5);
1355         \}
1356         
1357         \textcolor{keywordflow}{if} (firstInGroup) \{
1358             \textcolor{comment}{// Print access bits}
1359             Serial.print(\textcolor{stringliteral}{" [ "});
1360             Serial.print((g[group] >> 2) & 1, DEC); Serial.print(\textcolor{stringliteral}{" "});
1361             Serial.print((g[group] >> 1) & 1, DEC); Serial.print(\textcolor{stringliteral}{" "});
1362             Serial.print((g[group] >> 0) & 1, DEC);
1363             Serial.print(\textcolor{stringliteral}{" ] "});
1364             \textcolor{keywordflow}{if} (invertedError) \{
1365                 Serial.print(\textcolor{stringliteral}{" Inverted access bits did not match! "});
1366             \}
1367         \}
1368         
1369         \textcolor{keywordflow}{if} (group != 3 && (g[group] == 1 || g[group] == 6)) \{ \textcolor{comment}{// Not a sector trailer, a value block}
1370             \textcolor{keywordtype}{long} value = (long(buffer[3])<<24) | (\textcolor{keywordtype}{long}(buffer[2])<<16) | (\textcolor{keywordtype}{long}(buffer[1])<<8) | \textcolor{keywordtype}{long}(buffer
      [0]);
1371             Serial.print(\textcolor{stringliteral}{" Value=0x"}); Serial.print(value, HEX);
1372             Serial.print(\textcolor{stringliteral}{" Adr=0x"}); Serial.print(buffer[12], HEX);
1373         \}
1374         Serial.println();
1375     \}
1376     
1377     \textcolor{keywordflow}{return};
1378 \} \textcolor{comment}{// End PICC\_DumpMifareClassicSectorToSerial()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_aa45876e611a99b9b6d8ae2d4117d3976}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+Dump\+Mifare\+Classic\+To\+Serial@{P\+I\+C\+C\+\_\+\+Dump\+Mifare\+Classic\+To\+Serial}}
\index{P\+I\+C\+C\+\_\+\+Dump\+Mifare\+Classic\+To\+Serial@{P\+I\+C\+C\+\_\+\+Dump\+Mifare\+Classic\+To\+Serial}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+I\+C\+C\+\_\+\+Dump\+Mifare\+Classic\+To\+Serial()}
{\footnotesize\ttfamily void M\+F\+R\+C522\+::\+P\+I\+C\+C\+\_\+\+Dump\+Mifare\+Classic\+To\+Serial (\begin{DoxyParamCaption}\item[{\textbf{ Uid} $\ast$}]{uid,  }\item[{byte}]{picc\+Type,  }\item[{\textbf{ M\+I\+F\+A\+R\+E\+\_\+\+Key} $\ast$}]{key }\end{DoxyParamCaption})}

Dumps memory contents of a M\+I\+F\+A\+RE Classic P\+I\+CC. On success the P\+I\+CC is halted after dumping the data. 
\begin{DoxyParams}{Parameters}
{\em uid} & Pointer to \doxyref{Uid}{p.}{struct_m_f_r_c522_1_1_uid} struct returned from a successful \doxyref{P\+I\+C\+C\+\_\+\+Select()}{p.}{class_m_f_r_c522_ab40449ac80501db28d25889612bb2db0}. \\
\hline
{\em picc\+Type} & One of the P\+I\+C\+C\+\_\+\+Type enums. \\
\hline
{\em key} & Key A used for all sectors. \\
\hline
\end{DoxyParams}


Definition at line 1208 of file M\+F\+R\+C522.\+cpp.



References P\+C\+D\+\_\+\+Stop\+Crypto1().


\begin{DoxyCode}
1211                                               \{
1212     byte no\_of\_sectors = 0;
1213     \textcolor{keywordflow}{switch} (piccType) \{
1214         \textcolor{keywordflow}{case} PICC_TYPE_MIFARE_MINI:
1215             \textcolor{comment}{// Has 5 sectors * 4 blocks/sector * 16 bytes/block = 320 bytes.}
1216             no\_of\_sectors = 5;
1217             \textcolor{keywordflow}{break};
1218             
1219         \textcolor{keywordflow}{case} PICC_TYPE_MIFARE_1K:
1220             \textcolor{comment}{// Has 16 sectors * 4 blocks/sector * 16 bytes/block = 1024 bytes.}
1221             no\_of\_sectors = 16;
1222             \textcolor{keywordflow}{break};
1223             
1224         \textcolor{keywordflow}{case} PICC_TYPE_MIFARE_4K:
1225             \textcolor{comment}{// Has (32 sectors * 4 blocks/sector + 8 sectors * 16 blocks/sector) * 16 bytes/block = 4096
       bytes.}
1226             no\_of\_sectors = 40;
1227             \textcolor{keywordflow}{break};
1228             
1229         \textcolor{keywordflow}{default}: \textcolor{comment}{// Should not happen. Ignore.}
1230             \textcolor{keywordflow}{break}; 
1231     \}
1232     
1233     \textcolor{comment}{// Dump sectors, highest address first.}
1234     \textcolor{keywordflow}{if} (no\_of\_sectors) \{
1235         Serial.println(\textcolor{stringliteral}{"Sector Block   0  1  2  3   4  5  6  7   8  9 10 11  12 13 14 15  AccessBits"});
1236         \textcolor{keywordflow}{for} (int8\_t i = no\_of\_sectors - 1; i >= 0; i--) \{
1237             PICC_DumpMifareClassicSectorToSerial(uid, key, i);
1238         \}
1239     \}
1240     PICC_HaltA(); \textcolor{comment}{// Halt the PICC before stopping the encrypted session.}
1241     PCD_StopCrypto1();
1242 \} \textcolor{comment}{// End PICC\_DumpMifareClassicToSerial()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_ac148d28877dd577606a28e9e7e4b6809}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+Dump\+Mifare\+Ultralight\+To\+Serial@{P\+I\+C\+C\+\_\+\+Dump\+Mifare\+Ultralight\+To\+Serial}}
\index{P\+I\+C\+C\+\_\+\+Dump\+Mifare\+Ultralight\+To\+Serial@{P\+I\+C\+C\+\_\+\+Dump\+Mifare\+Ultralight\+To\+Serial}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+I\+C\+C\+\_\+\+Dump\+Mifare\+Ultralight\+To\+Serial()}
{\footnotesize\ttfamily void M\+F\+R\+C522\+::\+P\+I\+C\+C\+\_\+\+Dump\+Mifare\+Ultralight\+To\+Serial (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Dumps memory contents of a M\+I\+F\+A\+RE Ultralight P\+I\+CC. 

Definition at line 1383 of file M\+F\+R\+C522.\+cpp.


\begin{DoxyCode}
1383                                                 \{
1384     byte status;
1385     byte byteCount;
1386     byte buffer[18];
1387     byte i;
1388 
1389     Serial.println(\textcolor{stringliteral}{"Page  0  1  2  3"});
1390     \textcolor{comment}{// Try the mpages of the original Ultralight. Ultralight C has more pages.}
1391     \textcolor{keywordflow}{for} (byte page = 0; page < 16; page +=4) \{ \textcolor{comment}{// Read returns data for 4 pages at a time.}
1392         \textcolor{comment}{// Read pages}
1393         byteCount = \textcolor{keyword}{sizeof}(buffer);
1394         status = MIFARE_Read(page, buffer, &byteCount);
1395         \textcolor{keywordflow}{if} (status != STATUS_OK) \{
1396             Serial.print(\textcolor{stringliteral}{"MIFARE\_Read() failed: "});
1397             Serial.println(GetStatusCodeName(status));
1398             \textcolor{keywordflow}{break};
1399         \}
1400         \textcolor{comment}{// Dump data}
1401         \textcolor{keywordflow}{for} (byte offset = 0; offset < 4; offset++) \{
1402             i = page + offset;
1403             Serial.print(i < 10 ? \textcolor{stringliteral}{"  "} : \textcolor{stringliteral}{" "}); \textcolor{comment}{// Pad with spaces}
1404             Serial.print(i);
1405             Serial.print(\textcolor{stringliteral}{"  "});
1406             \textcolor{keywordflow}{for} (byte index = 0; index < 4; index++) \{
1407                 i = 4 * offset + index;
1408                 Serial.print(buffer[i] < 0x10 ? \textcolor{stringliteral}{" 0"} : \textcolor{stringliteral}{" "});
1409                 Serial.print(buffer[i], HEX);
1410             \}
1411             Serial.println();
1412         \}
1413     \}
1414 \} \textcolor{comment}{// End PICC\_DumpMifareUltralightToSerial()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a6f324d43c6fbbd0e260b171747186037}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+Dump\+To\+Serial@{P\+I\+C\+C\+\_\+\+Dump\+To\+Serial}}
\index{P\+I\+C\+C\+\_\+\+Dump\+To\+Serial@{P\+I\+C\+C\+\_\+\+Dump\+To\+Serial}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+I\+C\+C\+\_\+\+Dump\+To\+Serial()}
{\footnotesize\ttfamily void M\+F\+R\+C522\+::\+P\+I\+C\+C\+\_\+\+Dump\+To\+Serial (\begin{DoxyParamCaption}\item[{\textbf{ Uid} $\ast$}]{uid }\end{DoxyParamCaption})}

Dumps debug info about the selected P\+I\+CC to Serial. On success the P\+I\+CC is halted after dumping the data. For M\+I\+F\+A\+RE Classic the factory default key of 0x\+F\+F\+F\+F\+F\+F\+F\+F\+F\+F\+FF is tried. 
\begin{DoxyParams}{Parameters}
{\em uid} & Pointer to \doxyref{Uid}{p.}{struct_m_f_r_c522_1_1_uid} struct returned from a successful \doxyref{P\+I\+C\+C\+\_\+\+Select()}{p.}{class_m_f_r_c522_ab40449ac80501db28d25889612bb2db0}. \\
\hline
\end{DoxyParams}


Definition at line 1154 of file M\+F\+R\+C522.\+cpp.


\begin{DoxyCode}
1155                                   \{
1156     MIFARE\_Key key;
1157     
1158     \textcolor{comment}{// UID}
1159     Serial.print(\textcolor{stringliteral}{"Card UID:"});
1160     \textcolor{keywordflow}{for} (byte i = 0; i < uid->size; i++) \{
1161         Serial.print(uid->uidByte[i] < 0x10 ? \textcolor{stringliteral}{" 0"} : \textcolor{stringliteral}{" "});
1162         Serial.print(uid->uidByte[i], HEX);
1163     \} 
1164     Serial.println();
1165 
1166     \textcolor{comment}{// PICC type}
1167     byte piccType = PICC_GetType(uid->sak);
1168     Serial.print(\textcolor{stringliteral}{"PICC type: "});
1169     Serial.println(PICC_GetTypeName(piccType));
1170     
1171     \textcolor{comment}{// Dump contents}
1172     \textcolor{keywordflow}{switch} (piccType) \{
1173         \textcolor{keywordflow}{case} PICC_TYPE_MIFARE_MINI:
1174         \textcolor{keywordflow}{case} PICC_TYPE_MIFARE_1K:
1175         \textcolor{keywordflow}{case} PICC_TYPE_MIFARE_4K:
1176             \textcolor{comment}{// All keys are set to FFFFFFFFFFFFh at chip delivery from the factory.}
1177             \textcolor{keywordflow}{for} (byte i = 0; i < 6; i++) \{
1178                 key.keyByte[i] = 0xFF;
1179             \}
1180             PICC_DumpMifareClassicToSerial(uid, piccType, &key);
1181             \textcolor{keywordflow}{break};
1182             
1183         \textcolor{keywordflow}{case} PICC_TYPE_MIFARE_UL:
1184             PICC_DumpMifareUltralightToSerial();
1185             \textcolor{keywordflow}{break};
1186             
1187         \textcolor{keywordflow}{case} PICC_TYPE_ISO_14443_4: 
1188         \textcolor{keywordflow}{case} PICC_TYPE_ISO_18092:
1189         \textcolor{keywordflow}{case} PICC_TYPE_MIFARE_PLUS:
1190         \textcolor{keywordflow}{case} PICC_TYPE_TNP3XXX:
1191             Serial.println(\textcolor{stringliteral}{"Dumping memory contents not implemented for that PICC type."});
1192             \textcolor{keywordflow}{break};
1193             
1194         \textcolor{keywordflow}{case} PICC_TYPE_UNKNOWN:
1195         \textcolor{keywordflow}{case} PICC_TYPE_NOT_COMPLETE:
1196         \textcolor{keywordflow}{default}:
1197             \textcolor{keywordflow}{break}; \textcolor{comment}{// No memory dump here}
1198     \}
1199 
1200     Serial.println();
1201     PICC_HaltA(); \textcolor{comment}{// Already done if it was a MIFARE Classic PICC.}
1202 \} \textcolor{comment}{// End PICC\_DumpToSerial()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a1217f49a195799e3c55b388f9d378ab3}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+Get\+Type@{P\+I\+C\+C\+\_\+\+Get\+Type}}
\index{P\+I\+C\+C\+\_\+\+Get\+Type@{P\+I\+C\+C\+\_\+\+Get\+Type}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+I\+C\+C\+\_\+\+Get\+Type()}
{\footnotesize\ttfamily byte M\+F\+R\+C522\+::\+P\+I\+C\+C\+\_\+\+Get\+Type (\begin{DoxyParamCaption}\item[{byte}]{sak }\end{DoxyParamCaption})}

Translates the S\+AK (Select Acknowledge) to a P\+I\+CC type.

\begin{DoxyReturn}{Returns}
P\+I\+C\+C\+\_\+\+Type 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em sak} & The S\+AK byte returned from \doxyref{P\+I\+C\+C\+\_\+\+Select()}{p.}{class_m_f_r_c522_ab40449ac80501db28d25889612bb2db0}. \\
\hline
\end{DoxyParams}


Definition at line 1100 of file M\+F\+R\+C522.\+cpp.



References P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+I\+S\+O\+\_\+14443\+\_\+4, P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+I\+S\+O\+\_\+18092, P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+N\+O\+T\+\_\+\+C\+O\+M\+P\+L\+E\+TE, and P\+I\+C\+C\+\_\+\+T\+Y\+P\+E\+\_\+\+U\+N\+K\+N\+O\+WN.


\begin{DoxyCode}
1101                               \{
1102     \textcolor{keywordflow}{if} (sak & 0x04) \{ \textcolor{comment}{// UID not complete}
1103         \textcolor{keywordflow}{return} PICC_TYPE_NOT_COMPLETE;
1104     \}
1105     
1106     \textcolor{keywordflow}{switch} (sak) \{
1107         \textcolor{keywordflow}{case} 0x09:  \textcolor{keywordflow}{return} PICC_TYPE_MIFARE_MINI;   \textcolor{keywordflow}{break};
1108         \textcolor{keywordflow}{case} 0x08:  \textcolor{keywordflow}{return} PICC_TYPE_MIFARE_1K;     \textcolor{keywordflow}{break};
1109         \textcolor{keywordflow}{case} 0x18:  \textcolor{keywordflow}{return} PICC_TYPE_MIFARE_4K;     \textcolor{keywordflow}{break};
1110         \textcolor{keywordflow}{case} 0x00:  \textcolor{keywordflow}{return} PICC_TYPE_MIFARE_UL;     \textcolor{keywordflow}{break};
1111         \textcolor{keywordflow}{case} 0x10:
1112         \textcolor{keywordflow}{case} 0x11:  \textcolor{keywordflow}{return} PICC_TYPE_MIFARE_PLUS;   \textcolor{keywordflow}{break};
1113         \textcolor{keywordflow}{case} 0x01:  \textcolor{keywordflow}{return} PICC_TYPE_TNP3XXX;       \textcolor{keywordflow}{break};
1114         \textcolor{keywordflow}{default}:    \textcolor{keywordflow}{break};
1115     \}
1116     
1117     \textcolor{keywordflow}{if} (sak & 0x20) \{
1118         \textcolor{keywordflow}{return} PICC_TYPE_ISO_14443_4;
1119     \}
1120     
1121     \textcolor{keywordflow}{if} (sak & 0x40) \{
1122         \textcolor{keywordflow}{return} PICC_TYPE_ISO_18092;
1123     \}
1124     
1125     \textcolor{keywordflow}{return} PICC_TYPE_UNKNOWN;
1126 \} \textcolor{comment}{// End PICC\_GetType()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_aca99128b3a8a192473d0b715a48b9f97}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+Get\+Type\+Name@{P\+I\+C\+C\+\_\+\+Get\+Type\+Name}}
\index{P\+I\+C\+C\+\_\+\+Get\+Type\+Name@{P\+I\+C\+C\+\_\+\+Get\+Type\+Name}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+I\+C\+C\+\_\+\+Get\+Type\+Name()}
{\footnotesize\ttfamily const char $\ast$ M\+F\+R\+C522\+::\+P\+I\+C\+C\+\_\+\+Get\+Type\+Name (\begin{DoxyParamCaption}\item[{byte}]{picc\+Type }\end{DoxyParamCaption})}

Returns a string pointer to the P\+I\+CC type name. 
\begin{DoxyParams}{Parameters}
{\em picc\+Type} & One of the P\+I\+C\+C\+\_\+\+Type enums. \\
\hline
\end{DoxyParams}


Definition at line 1132 of file M\+F\+R\+C522.\+cpp.


\begin{DoxyCode}
1133                                           \{
1134     \textcolor{keywordflow}{switch} (piccType) \{
1135         \textcolor{keywordflow}{case} PICC_TYPE_ISO_14443_4:     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"PICC compliant with ISO/IEC 14443-4"};       \textcolor{keywordflow}{break};
1136         \textcolor{keywordflow}{case} PICC_TYPE_ISO_18092:       \textcolor{keywordflow}{return} \textcolor{stringliteral}{"PICC compliant with ISO/IEC 18092 (NFC)"};   \textcolor{keywordflow}{break};
1137         \textcolor{keywordflow}{case} PICC_TYPE_MIFARE_MINI:     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"MIFARE Mini, 320 bytes"};                    \textcolor{keywordflow}{break};
1138         \textcolor{keywordflow}{case} PICC_TYPE_MIFARE_1K:       \textcolor{keywordflow}{return} \textcolor{stringliteral}{"MIFARE 1KB"};                                \textcolor{keywordflow}{break};
1139         \textcolor{keywordflow}{case} PICC_TYPE_MIFARE_4K:       \textcolor{keywordflow}{return} \textcolor{stringliteral}{"MIFARE 4KB"};                                \textcolor{keywordflow}{break};
1140         \textcolor{keywordflow}{case} PICC_TYPE_MIFARE_UL:       \textcolor{keywordflow}{return} \textcolor{stringliteral}{"MIFARE Ultralight or Ultralight C"};         \textcolor{keywordflow}{break};
1141         \textcolor{keywordflow}{case} PICC_TYPE_MIFARE_PLUS:     \textcolor{keywordflow}{return} \textcolor{stringliteral}{"MIFARE Plus"};                               \textcolor{keywordflow}{break};
1142         \textcolor{keywordflow}{case} PICC_TYPE_TNP3XXX:         \textcolor{keywordflow}{return} \textcolor{stringliteral}{"MIFARE TNP3XXX"};                            \textcolor{keywordflow}{break};
1143         \textcolor{keywordflow}{case} PICC_TYPE_NOT_COMPLETE:    \textcolor{keywordflow}{return} \textcolor{stringliteral}{"SAK indicates UID is not complete."};        \textcolor{keywordflow}{break};
1144         \textcolor{keywordflow}{case} PICC_TYPE_UNKNOWN:
1145         \textcolor{keywordflow}{default}:                        \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Unknown type"};                              \textcolor{keywordflow}{break};
1146     \}
1147 \} \textcolor{comment}{// End PICC\_GetTypeName()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_aaa152b63193d852bf2edcfae3044bea4}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+HaltA@{P\+I\+C\+C\+\_\+\+HaltA}}
\index{P\+I\+C\+C\+\_\+\+HaltA@{P\+I\+C\+C\+\_\+\+HaltA}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+I\+C\+C\+\_\+\+Halt\+A()}
{\footnotesize\ttfamily byte M\+F\+R\+C522\+::\+P\+I\+C\+C\+\_\+\+HaltA (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Instructs a P\+I\+CC in state A\+C\+T\+I\+V\+E($\ast$) to go to state H\+A\+LT.

\begin{DoxyReturn}{Returns}
S\+T\+A\+T\+U\+S\+\_\+\+OK on success, S\+T\+A\+T\+U\+S\+\_\+??? otherwise. 
\end{DoxyReturn}


Definition at line 682 of file M\+F\+R\+C522.\+cpp.



References S\+T\+A\+T\+U\+S\+\_\+\+E\+R\+R\+OR, and S\+T\+A\+T\+U\+S\+\_\+\+OK.


\begin{DoxyCode}
682                          \{
683     byte result;
684     byte buffer[4]; 
685 
686     \textcolor{comment}{// Build command buffer}
687     buffer[0] = PICC_CMD_HLTA;
688     buffer[1] = 0;
689     \textcolor{comment}{// Calculate CRC\_A}
690     result = PCD_CalculateCRC(buffer, 2, &buffer[2]);
691     \textcolor{keywordflow}{if} (result != STATUS_OK) \{
692         \textcolor{keywordflow}{return} result;
693     \}
694 
695     \textcolor{comment}{// Send the command.}
696     \textcolor{comment}{// The standard says:}
697     \textcolor{comment}{//      If the PICC responds with any modulation during a period of 1 ms after the end of the frame
       containing the}
698     \textcolor{comment}{//      HLTA command, this response shall be interpreted as 'not acknowledge'.}
699     \textcolor{comment}{// We interpret that this way: Only STATUS\_TIMEOUT is an success.}
700     result = PCD_TransceiveData(buffer, \textcolor{keyword}{sizeof}(buffer), NULL, 0);
701     \textcolor{keywordflow}{if} (result == STATUS_TIMEOUT) \{
702         \textcolor{keywordflow}{return} STATUS_OK;
703     \}
704     \textcolor{keywordflow}{if} (result == STATUS_OK) \{ \textcolor{comment}{// That is ironically NOT ok in this case ;-)}
705         \textcolor{keywordflow}{return} STATUS_ERROR;
706     \}
707     \textcolor{keywordflow}{return} result;
708 \} \textcolor{comment}{// End PICC\_HaltA()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a3adca9d3b455c680ebcde3b74c4e567b}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+Is\+New\+Card\+Present@{P\+I\+C\+C\+\_\+\+Is\+New\+Card\+Present}}
\index{P\+I\+C\+C\+\_\+\+Is\+New\+Card\+Present@{P\+I\+C\+C\+\_\+\+Is\+New\+Card\+Present}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+I\+C\+C\+\_\+\+Is\+New\+Card\+Present()}
{\footnotesize\ttfamily bool M\+F\+R\+C522\+::\+P\+I\+C\+C\+\_\+\+Is\+New\+Card\+Present (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Returns true if a P\+I\+CC responds to P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+R\+E\+QA. Only \char`\"{}new\char`\"{} cards in state I\+D\+LE are invited. Sleeping cards in state H\+A\+LT are ignored.

\begin{DoxyReturn}{Returns}
bool 
\end{DoxyReturn}


Definition at line 1643 of file M\+F\+R\+C522.\+cpp.



Referenced by M\+I\+F\+A\+R\+E\+\_\+\+Set\+Uid().


\begin{DoxyCode}
1643                                     \{
1644     byte bufferATQA[2];
1645     byte bufferSize = \textcolor{keyword}{sizeof}(bufferATQA);
1646     byte result = PICC_RequestA(bufferATQA, &bufferSize);
1647     \textcolor{keywordflow}{return} (result == STATUS_OK || result == STATUS_COLLISION);
1648 \} \textcolor{comment}{// End PICC\_IsNewCardPresent()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_aab1218c71cec9cc17ee3ac8a683df106}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+Read\+Card\+Serial@{P\+I\+C\+C\+\_\+\+Read\+Card\+Serial}}
\index{P\+I\+C\+C\+\_\+\+Read\+Card\+Serial@{P\+I\+C\+C\+\_\+\+Read\+Card\+Serial}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+I\+C\+C\+\_\+\+Read\+Card\+Serial()}
{\footnotesize\ttfamily bool M\+F\+R\+C522\+::\+P\+I\+C\+C\+\_\+\+Read\+Card\+Serial (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Simple wrapper around P\+I\+C\+C\+\_\+\+Select. Returns true if a U\+ID could be read. Remember to call \doxyref{P\+I\+C\+C\+\_\+\+Is\+New\+Card\+Present()}{p.}{class_m_f_r_c522_a3adca9d3b455c680ebcde3b74c4e567b}, \doxyref{P\+I\+C\+C\+\_\+\+Request\+A()}{p.}{class_m_f_r_c522_a6db371f6ca95e8ea22445124c79012cc} or \doxyref{P\+I\+C\+C\+\_\+\+Wakeup\+A()}{p.}{class_m_f_r_c522_a009dfa9138c6f999af82d7fc5b17a272} first. The read U\+ID is available in the class variable uid.

\begin{DoxyReturn}{Returns}
bool 
\end{DoxyReturn}


Definition at line 1658 of file M\+F\+R\+C522.\+cpp.



Referenced by M\+I\+F\+A\+R\+E\+\_\+\+Set\+Uid().


\begin{DoxyCode}
1658                                   \{
1659     byte result = PICC_Select(&uid);
1660     \textcolor{keywordflow}{return} (result == STATUS_OK);
1661 \} \textcolor{comment}{// End PICC\_ReadCardSerial()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a43d475b7d21f31bd1104e81ea5e3d1c9}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+R\+E\+Q\+A\+\_\+or\+\_\+\+W\+U\+PA@{P\+I\+C\+C\+\_\+\+R\+E\+Q\+A\+\_\+or\+\_\+\+W\+U\+PA}}
\index{P\+I\+C\+C\+\_\+\+R\+E\+Q\+A\+\_\+or\+\_\+\+W\+U\+PA@{P\+I\+C\+C\+\_\+\+R\+E\+Q\+A\+\_\+or\+\_\+\+W\+U\+PA}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+I\+C\+C\+\_\+\+R\+E\+Q\+A\+\_\+or\+\_\+\+W\+U\+P\+A()}
{\footnotesize\ttfamily byte M\+F\+R\+C522\+::\+P\+I\+C\+C\+\_\+\+R\+E\+Q\+A\+\_\+or\+\_\+\+W\+U\+PA (\begin{DoxyParamCaption}\item[{byte}]{command,  }\item[{byte $\ast$}]{buffer\+A\+T\+QA,  }\item[{byte $\ast$}]{buffer\+Size }\end{DoxyParamCaption})}

Transmits R\+E\+QA or W\+U\+PA commands. Beware\+: When two P\+I\+C\+Cs are in the field at the same time I often get S\+T\+A\+T\+U\+S\+\_\+\+T\+I\+M\+E\+O\+UT -\/ probably due do bad antenna design.

\begin{DoxyReturn}{Returns}
S\+T\+A\+T\+U\+S\+\_\+\+OK on success, S\+T\+A\+T\+U\+S\+\_\+??? otherwise. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em command} & The command to send -\/ P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+R\+E\+QA or P\+I\+C\+C\+\_\+\+C\+M\+D\+\_\+\+W\+U\+PA \\
\hline
{\em buffer\+A\+T\+QA} & The buffer to store the A\+T\+QA (Answer to request) in \\
\hline
{\em buffer\+Size} & Buffer size, at least two bytes. Also number of bytes returned if S\+T\+A\+T\+U\+S\+\_\+\+OK. \\
\hline
\end{DoxyParams}


Definition at line 428 of file M\+F\+R\+C522.\+cpp.



References S\+T\+A\+T\+U\+S\+\_\+\+E\+R\+R\+OR, S\+T\+A\+T\+U\+S\+\_\+\+N\+O\+\_\+\+R\+O\+OM, and S\+T\+A\+T\+U\+S\+\_\+\+OK.


\begin{DoxyCode}
431                                  \{
432     byte validBits;
433     byte status;
434     
435     \textcolor{keywordflow}{if} (bufferATQA == NULL || *bufferSize < 2) \{    \textcolor{comment}{// The ATQA response is 2 bytes long.}
436         \textcolor{keywordflow}{return} STATUS_NO_ROOM;
437     \}
438     PCD_ClearRegisterBitMask(CollReg, 0x80);            \textcolor{comment}{// ValuesAfterColl=1 => Bits received after
       collision are cleared.}
439     validBits = 7;                                      \textcolor{comment}{// For REQA and WUPA we need the short frame format
       - transmit only 7 bits of the last (and only) byte. TxLastBits = BitFramingReg[2..0]}
440     status = PCD_TransceiveData(&command, 1, bufferATQA, bufferSize, &validBits);
441     \textcolor{keywordflow}{if} (status != STATUS_OK) \{
442         \textcolor{keywordflow}{return} status;
443     \}
444     \textcolor{keywordflow}{if} (*bufferSize != 2 || validBits != 0) \{       \textcolor{comment}{// ATQA must be exactly 16 bits.}
445         \textcolor{keywordflow}{return} STATUS_ERROR;
446     \}
447     \textcolor{keywordflow}{return} STATUS_OK;
448 \} \textcolor{comment}{// End PICC\_REQA\_or\_WUPA()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a6db371f6ca95e8ea22445124c79012cc}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+RequestA@{P\+I\+C\+C\+\_\+\+RequestA}}
\index{P\+I\+C\+C\+\_\+\+RequestA@{P\+I\+C\+C\+\_\+\+RequestA}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+I\+C\+C\+\_\+\+Request\+A()}
{\footnotesize\ttfamily byte M\+F\+R\+C522\+::\+P\+I\+C\+C\+\_\+\+RequestA (\begin{DoxyParamCaption}\item[{byte $\ast$}]{buffer\+A\+T\+QA,  }\item[{byte $\ast$}]{buffer\+Size }\end{DoxyParamCaption})}

Transmits a R\+E\+Quest command, Type A. Invites P\+I\+C\+Cs in state I\+D\+LE to go to R\+E\+A\+DY and prepare for anticollision or selection. 7 bit frame. Beware\+: When two P\+I\+C\+Cs are in the field at the same time I often get S\+T\+A\+T\+U\+S\+\_\+\+T\+I\+M\+E\+O\+UT -\/ probably due do bad antenna design.

\begin{DoxyReturn}{Returns}
S\+T\+A\+T\+U\+S\+\_\+\+OK on success, S\+T\+A\+T\+U\+S\+\_\+??? otherwise. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em buffer\+A\+T\+QA} & The buffer to store the A\+T\+QA (Answer to request) in \\
\hline
{\em buffer\+Size} & Buffer size, at least two bytes. Also number of bytes returned if S\+T\+A\+T\+U\+S\+\_\+\+OK. \\
\hline
\end{DoxyParams}


Definition at line 404 of file M\+F\+R\+C522.\+cpp.


\begin{DoxyCode}
406                               \{
407     \textcolor{keywordflow}{return} PICC_REQA_or_WUPA(PICC_CMD_REQA, bufferATQA, bufferSize);
408 \} \textcolor{comment}{// End PICC\_RequestA()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_ab40449ac80501db28d25889612bb2db0}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+Select@{P\+I\+C\+C\+\_\+\+Select}}
\index{P\+I\+C\+C\+\_\+\+Select@{P\+I\+C\+C\+\_\+\+Select}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+I\+C\+C\+\_\+\+Select()}
{\footnotesize\ttfamily byte M\+F\+R\+C522\+::\+P\+I\+C\+C\+\_\+\+Select (\begin{DoxyParamCaption}\item[{\textbf{ Uid} $\ast$}]{uid,  }\item[{byte}]{valid\+Bits = {\ttfamily 0} }\end{DoxyParamCaption})}

Transmits S\+E\+L\+E\+C\+T/\+A\+N\+T\+I\+C\+O\+L\+L\+I\+S\+I\+ON commands to select a single P\+I\+CC. Before calling this function the P\+I\+C\+Cs must be placed in the R\+E\+A\+D\+Y($\ast$) state by calling \doxyref{P\+I\+C\+C\+\_\+\+Request\+A()}{p.}{class_m_f_r_c522_a6db371f6ca95e8ea22445124c79012cc} or \doxyref{P\+I\+C\+C\+\_\+\+Wakeup\+A()}{p.}{class_m_f_r_c522_a009dfa9138c6f999af82d7fc5b17a272}. On success\+:
\begin{DoxyItemize}
\item The chosen P\+I\+CC is in state A\+C\+T\+I\+V\+E($\ast$) and all other P\+I\+C\+Cs have returned to state I\+D\+L\+E/\+H\+A\+LT. (Figure 7 of the I\+S\+O/\+I\+EC 14443-\/3 draft.)
\item The U\+ID size and value of the chosen P\+I\+CC is returned in $\ast$uid along with the S\+AK.
\end{DoxyItemize}

A P\+I\+CC U\+ID consists of 4, 7 or 10 bytes. Only 4 bytes can be specified in a S\+E\+L\+E\+CT command, so for the longer U\+I\+Ds two or three iterations are used\+: U\+ID size Number of U\+ID bytes Cascade levels Example of P\+I\+CC ======== =================== ============== =============== single 4 1 M\+I\+F\+A\+RE Classic double 7 2 M\+I\+F\+A\+RE Ultralight triple 10 3 Not currently in use?

\begin{DoxyReturn}{Returns}
S\+T\+A\+T\+U\+S\+\_\+\+OK on success, S\+T\+A\+T\+U\+S\+\_\+??? otherwise. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em uid} & Pointer to \doxyref{Uid}{p.}{struct_m_f_r_c522_1_1_uid} struct. Normally output, but can also be used to supply a known U\+ID. \\
\hline
{\em valid\+Bits} & The number of known U\+ID bits supplied in $\ast$uid. Normally 0. If set you must also supply uid-\/$>$size. \\
\hline
\end{DoxyParams}


Definition at line 467 of file M\+F\+R\+C522.\+cpp.



References S\+T\+A\+T\+U\+S\+\_\+\+C\+O\+L\+L\+I\+S\+I\+ON, S\+T\+A\+T\+U\+S\+\_\+\+C\+R\+C\+\_\+\+W\+R\+O\+NG, S\+T\+A\+T\+U\+S\+\_\+\+E\+R\+R\+OR, S\+T\+A\+T\+U\+S\+\_\+\+I\+N\+T\+E\+R\+N\+A\+L\+\_\+\+E\+R\+R\+OR, S\+T\+A\+T\+U\+S\+\_\+\+I\+N\+V\+A\+L\+ID, and S\+T\+A\+T\+U\+S\+\_\+\+OK.


\begin{DoxyCode}
469                            \{
470     \textcolor{keywordtype}{bool} uidComplete;
471     \textcolor{keywordtype}{bool} selectDone;
472     \textcolor{keywordtype}{bool} useCascadeTag;
473     byte cascadeLevel   = 1; 
474     byte result;
475     byte count;
476     byte index;
477     byte uidIndex;                  \textcolor{comment}{// The first index in uid->uidByte[] that is used in the current
       Cascade Level.}
478     int8\_t currentLevelKnownBits;       \textcolor{comment}{// The number of known UID bits in the current Cascade Level.}
479     byte buffer[9];                 \textcolor{comment}{// The SELECT/ANTICOLLISION commands uses a 7 byte standard frame + 2
       bytes CRC\_A}
480     byte bufferUsed;                \textcolor{comment}{// The number of bytes used in the buffer, ie the number of bytes to
       transfer to the FIFO.}
481     byte rxAlign;                   \textcolor{comment}{// Used in BitFramingReg. Defines the bit position for the first bit
       received.}
482     byte txLastBits;                \textcolor{comment}{// Used in BitFramingReg. The number of valid bits in the last
       transmitted byte. }
483     byte *responseBuffer;
484     byte responseLength;
485     
486     \textcolor{comment}{// Description of buffer structure:}
487     \textcolor{comment}{//      Byte 0: SEL                 Indicates the Cascade Level: PICC\_CMD\_SEL\_CL1, PICC\_CMD\_SEL\_CL2 or
       PICC\_CMD\_SEL\_CL3}
488     \textcolor{comment}{//      Byte 1: NVB                 Number of Valid Bits (in complete command, not just the UID): High
       nibble: complete bytes, Low nibble: Extra bits. }
489     \textcolor{comment}{//      Byte 2: UID-data or CT      See explanation below. CT means Cascade Tag.}
490     \textcolor{comment}{//      Byte 3: UID-data}
491     \textcolor{comment}{//      Byte 4: UID-data}
492     \textcolor{comment}{//      Byte 5: UID-data}
493     \textcolor{comment}{//      Byte 6: BCC                 Block Check Character - XOR of bytes 2-5}
494     \textcolor{comment}{//      Byte 7: CRC\_A}
495     \textcolor{comment}{//      Byte 8: CRC\_A}
496     \textcolor{comment}{// The BCC and CRC\_A is only transmitted if we know all the UID bits of the current Cascade Level.}
497     \textcolor{comment}{//}
498     \textcolor{comment}{// Description of bytes 2-5: (Section 6.5.4 of the ISO/IEC 14443-3 draft: UID contents and cascade
       levels)}
499     \textcolor{comment}{//      UID size    Cascade level   Byte2   Byte3   Byte4   Byte5}
500     \textcolor{comment}{//      ========    =============   =====   =====   =====   =====}
501     \textcolor{comment}{//       4 bytes        1           uid0    uid1    uid2    uid3}
502     \textcolor{comment}{//       7 bytes        1           CT      uid0    uid1    uid2}
503     \textcolor{comment}{//                      2           uid3    uid4    uid5    uid6}
504     \textcolor{comment}{//      10 bytes        1           CT      uid0    uid1    uid2}
505     \textcolor{comment}{//                      2           CT      uid3    uid4    uid5}
506     \textcolor{comment}{//                      3           uid6    uid7    uid8    uid9}
507     
508     \textcolor{comment}{// Sanity checks}
509     \textcolor{keywordflow}{if} (validBits > 80) \{
510         \textcolor{keywordflow}{return} STATUS_INVALID;
511     \}
512 
513     \textcolor{comment}{// Prepare MFRC522}
514     PCD_ClearRegisterBitMask(CollReg, 0x80);            \textcolor{comment}{// ValuesAfterColl=1 => Bits received after
       collision are cleared.}
515 
516     \textcolor{comment}{// Repeat Cascade Level loop until we have a complete UID.}
517     uidComplete = \textcolor{keyword}{false};
518     \textcolor{keywordflow}{while} ( ! uidComplete) \{
519         \textcolor{comment}{// Set the Cascade Level in the SEL byte, find out if we need to use the Cascade Tag in byte 2.}
520         \textcolor{keywordflow}{switch} (cascadeLevel) \{
521             \textcolor{keywordflow}{case} 1:
522                 buffer[0] = PICC_CMD_SEL_CL1;
523                 uidIndex = 0;
524                 useCascadeTag = validBits && uid->size > 4; \textcolor{comment}{// When we know that the UID has more than 4
       bytes}
525                 \textcolor{keywordflow}{break};
526             
527             \textcolor{keywordflow}{case} 2:
528                 buffer[0] = PICC_CMD_SEL_CL2;
529                 uidIndex = 3;
530                 useCascadeTag = validBits && uid->size > 7; \textcolor{comment}{// When we know that the UID has more than 7
       bytes}
531                 \textcolor{keywordflow}{break};
532             
533             \textcolor{keywordflow}{case} 3:
534                 buffer[0] = PICC_CMD_SEL_CL3;
535                 uidIndex = 6;
536                 useCascadeTag = \textcolor{keyword}{false};                      \textcolor{comment}{// Never used in CL3.}
537                 \textcolor{keywordflow}{break};
538             
539             \textcolor{keywordflow}{default}:
540                 \textcolor{keywordflow}{return} STATUS_INTERNAL_ERROR;
541                 \textcolor{keywordflow}{break};
542         \}
543         
544         \textcolor{comment}{// How many UID bits are known in this Cascade Level?}
545         currentLevelKnownBits = validBits - (8 * uidIndex);
546         \textcolor{keywordflow}{if} (currentLevelKnownBits < 0) \{
547             currentLevelKnownBits = 0;
548         \}
549         \textcolor{comment}{// Copy the known bits from uid->uidByte[] to buffer[]}
550         index = 2; \textcolor{comment}{// destination index in buffer[]}
551         \textcolor{keywordflow}{if} (useCascadeTag) \{
552             buffer[index++] = PICC_CMD_CT;
553         \}
554         byte bytesToCopy = currentLevelKnownBits / 8 + (currentLevelKnownBits % 8 ? 1 : 0); \textcolor{comment}{// The number
       of bytes needed to represent the known bits for this level.}
555         \textcolor{keywordflow}{if} (bytesToCopy) \{
556             byte maxBytes = useCascadeTag ? 3 : 4; \textcolor{comment}{// Max 4 bytes in each Cascade Level. Only 3 left if we
       use the Cascade Tag}
557             \textcolor{keywordflow}{if} (bytesToCopy > maxBytes) \{ 
558                 bytesToCopy = maxBytes;
559             \}
560             \textcolor{keywordflow}{for} (count = 0; count < bytesToCopy; count++) \{
561                 buffer[index++] = uid->uidByte[uidIndex + count];
562             \}
563         \}
564         \textcolor{comment}{// Now that the data has been copied we need to include the 8 bits in CT in currentLevelKnownBits}
565         \textcolor{keywordflow}{if} (useCascadeTag) \{
566             currentLevelKnownBits += 8;
567         \}
568         
569         \textcolor{comment}{// Repeat anti collision loop until we can transmit all UID bits + BCC and receive a SAK - max 32
       iterations.}
570         selectDone = \textcolor{keyword}{false};
571         \textcolor{keywordflow}{while} ( ! selectDone) \{
572             \textcolor{comment}{// Find out how many bits and bytes to send and receive.}
573             \textcolor{keywordflow}{if} (currentLevelKnownBits >= 32) \{ \textcolor{comment}{// All UID bits in this Cascade Level are known. This is a
       SELECT.}
574                 \textcolor{comment}{//Serial.print("SELECT: currentLevelKnownBits="); Serial.println(currentLevelKnownBits,
       DEC);}
575                 buffer[1] = 0x70; \textcolor{comment}{// NVB - Number of Valid Bits: Seven whole bytes}
576                 \textcolor{comment}{// Calulate BCC - Block Check Character}
577                 buffer[6] = buffer[2] ^ buffer[3] ^ buffer[4] ^ buffer[5];
578                 \textcolor{comment}{// Calculate CRC\_A}
579                 result = PCD_CalculateCRC(buffer, 7, &buffer[7]);
580                 \textcolor{keywordflow}{if} (result != STATUS_OK) \{
581                     \textcolor{keywordflow}{return} result;
582                 \}
583                 txLastBits      = 0; \textcolor{comment}{// 0 => All 8 bits are valid.}
584                 bufferUsed      = 9;
585                 \textcolor{comment}{// Store response in the last 3 bytes of buffer (BCC and CRC\_A - not needed after tx)}
586                 responseBuffer  = &buffer[6];
587                 responseLength  = 3;
588             \}
589             \textcolor{keywordflow}{else} \{ \textcolor{comment}{// This is an ANTICOLLISION.}
590                 \textcolor{comment}{//Serial.print("ANTICOLLISION: currentLevelKnownBits=");
       Serial.println(currentLevelKnownBits, DEC);}
591                 txLastBits      = currentLevelKnownBits % 8;
592                 count           = currentLevelKnownBits / 8;    \textcolor{comment}{// Number of whole bytes in the UID part.}
593                 index           = 2 + count;                    \textcolor{comment}{// Number of whole bytes: SEL + NVB + UIDs}
594                 buffer[1]       = (index << 4) + txLastBits;    \textcolor{comment}{// NVB - Number of Valid Bits}
595                 bufferUsed      = index + (txLastBits ? 1 : 0);
596                 \textcolor{comment}{// Store response in the unused part of buffer}
597                 responseBuffer  = &buffer[index];
598                 responseLength  = \textcolor{keyword}{sizeof}(buffer) - index;
599             \}
600 
601             \textcolor{comment}{// Set bit adjustments}
602             rxAlign = txLastBits;                                           \textcolor{comment}{// Having a seperate variable
       is overkill. But it makes the next line easier to read.}
603             PCD_WriteRegister(BitFramingReg, (rxAlign << 4) + txLastBits);  \textcolor{comment}{// RxAlign =
       BitFramingReg[6..4]. TxLastBits = BitFramingReg[2..0]}
604 
605             \textcolor{comment}{// Transmit the buffer and receive the response.}
606             result = PCD_TransceiveData(buffer, bufferUsed, responseBuffer, &responseLength, &txLastBits, 
      rxAlign);         
607             \textcolor{keywordflow}{if} (result == STATUS_COLLISION) \{ \textcolor{comment}{// More than one PICC in the field => collision.}
608                 result = PCD_ReadRegister(CollReg); \textcolor{comment}{// CollReg[7..0] bits are: ValuesAfterColl reserved
       CollPosNotValid CollPos[4:0]}
609                 \textcolor{keywordflow}{if} (result & 0x20) \{ \textcolor{comment}{// CollPosNotValid}
610                     \textcolor{keywordflow}{return} STATUS_COLLISION; \textcolor{comment}{// Without a valid collision position we cannot continue}
611                 \}
612                 byte collisionPos = result & 0x1F; \textcolor{comment}{// Values 0-31, 0 means bit 32.}
613                 \textcolor{keywordflow}{if} (collisionPos == 0) \{
614                     collisionPos = 32;
615                 \}
616                 \textcolor{keywordflow}{if} (collisionPos <= currentLevelKnownBits) \{ \textcolor{comment}{// No progress - should not happen }
617                     \textcolor{keywordflow}{return} STATUS_INTERNAL_ERROR;
618                 \}
619                 \textcolor{comment}{// Choose the PICC with the bit set.}
620                 currentLevelKnownBits = collisionPos;
621                 count           = (currentLevelKnownBits - 1) % 8; \textcolor{comment}{// The bit to modify}
622                 index           = 1 + (currentLevelKnownBits / 8) + (count ? 1 : 0); \textcolor{comment}{// First byte is index
       0.}
623                 buffer[index]   |= (1 << count); 
624             \}
625             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (result != STATUS_OK) \{
626                 \textcolor{keywordflow}{return} result;
627             \}
628             \textcolor{keywordflow}{else} \{ \textcolor{comment}{// STATUS\_OK}
629                 \textcolor{keywordflow}{if} (currentLevelKnownBits >= 32) \{ \textcolor{comment}{// This was a SELECT.}
630                     selectDone = \textcolor{keyword}{true}; \textcolor{comment}{// No more anticollision }
631                     \textcolor{comment}{// We continue below outside the while.}
632                 \}
633                 \textcolor{keywordflow}{else} \{ \textcolor{comment}{// This was an ANTICOLLISION.}
634                     \textcolor{comment}{// We now have all 32 bits of the UID in this Cascade Level}
635                     currentLevelKnownBits = 32;
636                     \textcolor{comment}{// Run loop again to do the SELECT.}
637                 \}
638             \}
639         \} \textcolor{comment}{// End of while ( ! selectDone)}
640 
641         \textcolor{comment}{// We do not check the CBB - it was constructed by us above.}
642         
643         \textcolor{comment}{// Copy the found UID bytes from buffer[] to uid->uidByte[]}
644         index           = (buffer[2] == PICC_CMD_CT) ? 3 : 2; \textcolor{comment}{// source index in buffer[]}
645         bytesToCopy     = (buffer[2] == PICC_CMD_CT) ? 3 : 4;
646         \textcolor{keywordflow}{for} (count = 0; count < bytesToCopy; count++) \{
647             uid->uidByte[uidIndex + count] = buffer[index++];
648         \}
649         
650         \textcolor{comment}{// Check response SAK (Select Acknowledge)}
651         \textcolor{keywordflow}{if} (responseLength != 3 || txLastBits != 0) \{       \textcolor{comment}{// SAK must be exactly 24 bits (1 byte +
       CRC\_A).}
652             \textcolor{keywordflow}{return} STATUS_ERROR;
653         \}
654         \textcolor{comment}{// Verify CRC\_A - do our own calculation and store the control in buffer[2..3] - those bytes are
       not needed anymore.}
655         result = PCD_CalculateCRC(responseBuffer, 1, &buffer[2]);
656         \textcolor{keywordflow}{if} (result != STATUS_OK) \{
657             \textcolor{keywordflow}{return} result;
658         \}
659         \textcolor{keywordflow}{if} ((buffer[2] != responseBuffer[1]) || (buffer[3] != responseBuffer[2])) \{
660             \textcolor{keywordflow}{return} STATUS_CRC_WRONG;
661         \}
662         \textcolor{keywordflow}{if} (responseBuffer[0] & 0x04) \{ \textcolor{comment}{// Cascade bit set - UID not complete yes}
663             cascadeLevel++;
664         \}
665         \textcolor{keywordflow}{else} \{
666             uidComplete = \textcolor{keyword}{true};
667             uid->sak = responseBuffer[0];
668         \}
669     \} \textcolor{comment}{// End of while ( ! uidComplete)}
670     
671     \textcolor{comment}{// Set correct uid->size}
672     uid->size = 3 * cascadeLevel + 1;
673 
674     \textcolor{keywordflow}{return} STATUS_OK;
675 \} \textcolor{comment}{// End PICC\_Select()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a009dfa9138c6f999af82d7fc5b17a272}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!P\+I\+C\+C\+\_\+\+WakeupA@{P\+I\+C\+C\+\_\+\+WakeupA}}
\index{P\+I\+C\+C\+\_\+\+WakeupA@{P\+I\+C\+C\+\_\+\+WakeupA}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{P\+I\+C\+C\+\_\+\+Wakeup\+A()}
{\footnotesize\ttfamily byte M\+F\+R\+C522\+::\+P\+I\+C\+C\+\_\+\+WakeupA (\begin{DoxyParamCaption}\item[{byte $\ast$}]{buffer\+A\+T\+QA,  }\item[{byte $\ast$}]{buffer\+Size }\end{DoxyParamCaption})}

Transmits a Wake-\/\+UP command, Type A. Invites P\+I\+C\+Cs in state I\+D\+LE and H\+A\+LT to go to R\+E\+A\+D\+Y($\ast$) and prepare for anticollision or selection. 7 bit frame. Beware\+: When two P\+I\+C\+Cs are in the field at the same time I often get S\+T\+A\+T\+U\+S\+\_\+\+T\+I\+M\+E\+O\+UT -\/ probably due do bad antenna design.

\begin{DoxyReturn}{Returns}
S\+T\+A\+T\+U\+S\+\_\+\+OK on success, S\+T\+A\+T\+U\+S\+\_\+??? otherwise. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em buffer\+A\+T\+QA} & The buffer to store the A\+T\+QA (Answer to request) in \\
\hline
{\em buffer\+Size} & Buffer size, at least two bytes. Also number of bytes returned if S\+T\+A\+T\+U\+S\+\_\+\+OK. \\
\hline
\end{DoxyParams}


Definition at line 416 of file M\+F\+R\+C522.\+cpp.


\begin{DoxyCode}
418                               \{
419     \textcolor{keywordflow}{return} PICC_REQA_or_WUPA(PICC_CMD_WUPA, bufferATQA, bufferSize);
420 \} \textcolor{comment}{// End PICC\_WakeupA()}
\end{DoxyCode}
\mbox{\label{class_m_f_r_c522_a5b743b53393d88588e9d878159e89faf}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!set\+Bit\+Mask@{set\+Bit\+Mask}}
\index{set\+Bit\+Mask@{set\+Bit\+Mask}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{set\+Bit\+Mask()}
{\footnotesize\ttfamily void M\+F\+R\+C522\+::set\+Bit\+Mask (\begin{DoxyParamCaption}\item[{unsigned char}]{reg,  }\item[{unsigned char}]{mask }\end{DoxyParamCaption})}

\mbox{\label{class_m_f_r_c522_a425d73a02db79e17abd78ff805770fc3}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!set\+S\+P\+I\+Config@{set\+S\+P\+I\+Config}}
\index{set\+S\+P\+I\+Config@{set\+S\+P\+I\+Config}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{set\+S\+P\+I\+Config()}
{\footnotesize\ttfamily void M\+F\+R\+C522\+::set\+S\+P\+I\+Config (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Set S\+PI bus to work with \doxyref{M\+F\+R\+C522}{p.}{class_m_f_r_c522} chip. Please call this function if you have changed the S\+PI config since the \doxyref{M\+F\+R\+C522}{p.}{class_m_f_r_c522} constructor was run. 

Definition at line 39 of file M\+F\+R\+C522.\+cpp.


\begin{DoxyCode}
39                            \{
40     SPI.begin();            \textcolor{comment}{// Init SPI bus}
41     SPI.setClockDivider(SPI\_CLOCK\_DIV8);
42     SPI.setBitOrder(MSBFIRST);
43     SPI.setDataMode(SPI\_MODE0);
44 \} \textcolor{comment}{// End setSPIConfig()}
\end{DoxyCode}


\subsection{Member Data Documentation}
\mbox{\label{class_m_f_r_c522_affaa7030ec6e5984cce845a8ed6df1b2}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!\+\_\+chip\+Select\+Pin@{\+\_\+chip\+Select\+Pin}}
\index{\+\_\+chip\+Select\+Pin@{\+\_\+chip\+Select\+Pin}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{\+\_\+chip\+Select\+Pin}
{\footnotesize\ttfamily byte M\+F\+R\+C522\+::\+\_\+chip\+Select\+Pin\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 349 of file M\+F\+R\+C522.\+h.

\mbox{\label{class_m_f_r_c522_a3885cb4bb582de0045cff2829d59006f}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!\+\_\+reset\+Power\+Down\+Pin@{\+\_\+reset\+Power\+Down\+Pin}}
\index{\+\_\+reset\+Power\+Down\+Pin@{\+\_\+reset\+Power\+Down\+Pin}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{\+\_\+reset\+Power\+Down\+Pin}
{\footnotesize\ttfamily byte M\+F\+R\+C522\+::\+\_\+reset\+Power\+Down\+Pin\hspace{0.3cm}{\ttfamily [private]}}



Definition at line 350 of file M\+F\+R\+C522.\+h.

\mbox{\label{class_m_f_r_c522_a7bdf27d2122006aabd423ad71495e5f1}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!F\+I\+F\+O\+\_\+\+S\+I\+ZE@{F\+I\+F\+O\+\_\+\+S\+I\+ZE}}
\index{F\+I\+F\+O\+\_\+\+S\+I\+ZE@{F\+I\+F\+O\+\_\+\+S\+I\+ZE}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{F\+I\+F\+O\+\_\+\+S\+I\+ZE}
{\footnotesize\ttfamily const byte M\+F\+R\+C522\+::\+F\+I\+F\+O\+\_\+\+S\+I\+ZE = 64\hspace{0.3cm}{\ttfamily [static]}}



Definition at line 269 of file M\+F\+R\+C522.\+h.

\mbox{\label{class_m_f_r_c522_ad456545d41962dd7f8bd4210f5618498}} 
\index{M\+F\+R\+C522@{M\+F\+R\+C522}!uid@{uid}}
\index{uid@{uid}!M\+F\+R\+C522@{M\+F\+R\+C522}}
\subsubsection{uid}
{\footnotesize\ttfamily \textbf{ Uid} M\+F\+R\+C522\+::uid}



Definition at line 266 of file M\+F\+R\+C522.\+h.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
lib/\+M\+F\+R\+C522/src/\textbf{ M\+F\+R\+C522.\+h}\item 
lib/\+M\+F\+R\+C522/src/\textbf{ M\+F\+R\+C522.\+cpp}\end{DoxyCompactItemize}
