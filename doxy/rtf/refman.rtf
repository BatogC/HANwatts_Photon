{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\info 
{\title {\comment Particle Photon software  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
2.0 \par
}}Particle Photon software}
{\comment Generated byDoxgyen. }
{\creatim \yr2021\mo1\dy19\hr15\min18\sec40}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt Particle Photon software}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 2.0\par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Tue Jan 19 2021 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
JSON Parser and Generator{\tc \v JSON Parser and Generator}\par \pard\plain 
{\bkmkstart AAAAAAABHI}
{\bkmkend AAAAAAABHI}
\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
There are a number of JSON parsers and generators for Particle products including the popular {\f2 SparkJson} library and {\f2 JSMNSpark}.\par
I created yet another library because I wanted something lightweight. SparkJson creates piles of objects that are copies of the original data during parsing. {\f2 JSMN} is very lightweight, but is kind of a pain to use.\par
What I did was wrap JSMN with an easier to use C++ API, along with adding easy value accessors.\par
I also added a JSON generator that's nearly as efficient as using sprintf, but much easier to use. It takes care of escaping quotes and special characters, and converts UTF-8 to JSON UTF-16 entities.\par
The parser and generator are separated internally so if you only need one or the other the linker will remove the unnecessary code automatically to save space.\par
The {\f2 full API documentation can be found here}.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 JSON Parser} \par}
The parser can be used in many situations, but it's particularly well-suited for handing responses from webhooks, including multi-part responses.\par
The parser can be used in two different ways: static allocation, where almost all of the memory location is done in advance, or dynamically.\par
To do it dynamically, just construct the {\f2 JsonParser} object as a global or local variable:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid JsonParser parser;\par
}
\par
To do it statically, you need to guess the maximum size of the data you want to receive and the maximum number of tokens it will have. Each object is one token, plus two tokens for each key/value pair. Each array is one token, plus one token for each value in the array.\par
This {\f2 JsonParserStatic} example creates a static parser to parse up to 1024 bytes of data and 50 tokens:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid JsonParserStatic<1024, 50> parser;\par
}
\par
You then typically add the data to parse using the {\f2 addData} or {\f2 addString} method. If you're getting the data from a subscribe handler, you'll probably use addString.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid parser.addString(data);\par
}
\par
If you have a pointer and length, the addData method can be used instead.\par
Then, once all of the data has been added, call {\f2 parse}. This is handy for webhooks where you may get a multipart response. Example 3 demonstrates this:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid void subscriptionHandler(const char *event, const char *data) \{\par
    int responseIndex = 0;\par
\par
    const char *slashOffset = strrchr(event, '/');\par
    if (slashOffset) \{\par
        responseIndex = atoi(slashOffset + 1);\par
    \}\par
\par
    if (responseIndex == 0) \{\par
        jsonParser.clear();\par
    \}\par
    jsonParser.addString(data);\par
\par
    if (jsonParser.parse()) \{\par
        // Looks valid (we received all parts)\par
\par
        // This printing thing is just for testing purposes, you should use the commands to\par
        // process data\par
        printJson(jsonParser);\par
    \}\par
\}\par
}
\par
Say you have this object:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  "t1":"abc",\par
  "t2":1234,\par
  "t3":1234.5,\par
  "t4":true,\par
  "t5":false,\par
  "t6":null,\par
  "t7":"\\"quoted\\""\par
\}\par
}
\par
You could read the value of t1 by using {\f2 getOuterValueByKey} and this code:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid String strValue;\par
parser1.getOuterValueByKey("t1", strValue);\par
}
\par
This also works for other data types:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid int intValue;\par
parser1.getOuterValueByKey("t2", intValue)\par
\par
float floatValue;\par
parser1.getOuterValueByKey("t3", floatValue);\par
\par
bool boolValue;\par
parser1.getOuterValueByKey("t4", boolValue);\par
}
\par
There's also a fluent-style API that can make reading complex JSON easier. For example, given this fragment of JSON:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
    "response": \{\par
        "version": "0.1",\par
        "termsofService": "http://www.wunderground.com/weather/api/d/terms.html",\par
        "features": \{\par
            "forecast": 1\par
        \}\par
    \},\par
    "forecast": \{\par
        "txt_forecast": \{\par
            "date": "12:25 PM EST",\par
            "forecastday": \{\par
                "period": 7,\par
                "icon": "nt_partlycloudy",\par
                "icon_url": "http://icons.wxug.com/i/c/k/nt_partlycloudy.gif",\par
                "title": "Saturday Night",\par
                "fcttext": "Partly cloudy early with increasing clouds overnight. Low 29F. Winds NW at 15 to 25 mph.",\par
                "fcttext_metric": "Partly cloudy early with increasing clouds overnight. Low -2C. Winds NW at 25 to 40 km/h.",\par
                "pop": "20"\par
            \}\par
        \},\par
}
\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid String s = parser.getReference().key("response").key("version").valueString();\par
// s == "0.1"\par
\par
s = parser.getReference().key("forecast").key("txt_forecast").key("date").valueString();\par
// s = "12:25 PM EST"\par
\par
int value = parser.getReference().key("forecast").key("txt_forecast").key("forecastday").key("period").valueInt();\par
// value == 7\par
}
\par
If you have a complicated JSON file to decode, using the {\f2 JSON Parser Tool} makes it easy. You paste in your JSON and it formats it nicely. Click on a row and will generate the fluent accessor to get that value!\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 JSON Generator} \par}
The JSON Generator is used to build valid JSON strings. While you can build JSON using sprintf, the JSON generator is able to double-quote escape strings, and escape double quotes within strings. It can also generate correct JSON unicode characters.\par
The most common use is to construct a static buffer to hold the JSON data for Particle.publish. Since this data is limited to 256 bytes, this is a reasonable approach using {\f2 JsonWriterStatic}:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid JsonWriterStatic<256> jw;\par
}
\par
You can also dynamically allocate a buffer using the plain {\f2 JsonWriter}.\par
The {\b JsonWriter} handles nested objects and arrays, but does so without creating temporary copies of the objects. Because of this, it's necessary to use startObject(), startArray(), and finishObjectOrArray() so the objects are balanced properly.\par
To make this easier, the {\f2 JsonWriterAutoObject} can be instantiated on the stack. When the object goes out of scope, it will automatically close the object. You use it like this:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
    JsonWriterAutoObject obj(&jw);\par
\par
    // Add various types of data\par
    jw.insertKeyValue("a", true);\par
    jw.insertKeyValue("b", 1234);\par
    jw.insertKeyValue("c", "test");\par
\}\par
}
\par
This will output the JSON data:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\\"a\\":true,\\"b\\":1234,\\"c\\":\\"test\\"\}\par
}
\par
If you are sending float or double values you may want to limit the number of decimal places to send. This is done using {\f2 setFloatPlaces}.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 {\b JsonModifier}} \par}
The {\b JsonModifier} class (added in version 0.1.0) makes it possible to modify an existing object that has been parsed with {\b JsonParser}.\par
You will typically process a JSON object using a {\f2 {\b JsonParser}}  object, {\f2 addString()}  or {\f2 addData()}  method, then {\f2 parse()} .\par
Assuming your {\f2 {\b JsonParser}}  is in the variable {\f2 jp}  you then construct a temporary modifier object on the stack like this:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid JsonModifier mod(jp);\par
}
\par
The most common thing to do is have a JSON object and you want to update the value, or insert the value if it does not exist:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid mod.insertOrUpdateKeyValue(jp.getOuterObject(), "a", (int)1);\par
}
\par
If the input JSON was empty, it would then be:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{"a":1\}\par
}
\par
You can add int, long, float, double, bool, and const char * objects this way.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid mod.insertOrUpdateKeyValue(jp.getOuterObject(), "b", "testing");\par
}
\par
This would change the object to:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{"a":1,"b":"testing"\}\par
}
\par
Updating an object will remove it from its current location and add it at the end of the object.\par
Another common function is {\f2 appendArrayValue()}  which appends to an array.\par
You can also use {\f2 removeKeyValue()}  and {\f2 removeArrayIndex()}  to remove keys or array entries.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 Examples} \par}
There are three Particle devices examples.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 1 - Parser} \par}
The parser example is a standalone test of parsing some JSON data. The data is built into the code, so just just run it and monitor the serial output to make sure the test passes.\par
It also demonstrates how to read simple values out of the JSON data.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 2 - Generator} \par}
The generator example is a standalone test of generating some JSON data. The data is built into the code, so just just run it and monitor the serial output to make sure the test passes.\par
It also demonstrates how to write JSON data.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 3 - Subscription} \par}
This example creates a subscription on the event jsonParserTest, so you can send it JSON data, and it will parse and print it to the debuggging serial. For example, if you published these three events:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid particle publish jsonParserTest '\{"a":1234\}' --private\par
particle publish jsonParserTest '\{"a":1234,"b":"test"\}' --private\par
particle publish jsonParserTest '\{"a":1234,"b":"test":"c":[1,2,3]\}' --private\par
}
\par
You'd get these three objects printed to debugging serial.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
  "a":1234\par
\}\par
\{\par
  "a":1234,\par
  "b":"test"\par
\}\par
\{\par
  "a":1234,\par
  "b":"test",\par
  "c":  [\par
    1,\par
    2,\par
    3\par
  ]\par
\par
\}\par
}
\par
It also demonstrates how to handle multi-part webhook responses.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 Test code} \par}
The github repository also has code in the test directory. It can run an automated test of several sample data files to verify operation. It's run by doing something like:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid cd test\par
make\par
}
\par
On Linux only, if you have valgrind installed, it can also do a build with valgrind checking to check for memory leaks and buffer overruns. It's run by doing:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid cd test\par
make check\par
}
\par
The test code is also a reference of various ways you can call the API.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 Version History} \par}
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 0.1.3 (2020-09-22)} \par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Added {\b JsonWriter} methods insertKeyArray() and insertKeyVector() to make it easier to add arrays.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Added {\b JsonWriter} methods insertArray() and insertVector() to make it easier to add arrays.\par}
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 0.1.1 (2020-05-14)} \par}
Fixed a bug where calling parse() on an empty buffer returns true. It should return false. See issue #7.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 0.1.0 (2019-09-18)} \par}
Added support for {\b JsonModifier}, a class to modify an existing JSON object in place, without making a copy of it.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 0.0.7 (2019-08-30)} \par}
Fixed a bug in the 3-subscription example. The check for the part number should use strrchr, not strchr, because it needs to find the last slash before the part number for webhook multi-part responses. \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
RFID{\tc \v RFID}\par \pard\plain 
{\bkmkstart AAAAAAABHJ}
{\bkmkend AAAAAAABHJ}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update for Libraries 2.0 by Paul Kourany, Jan 2017 - v1.0.3 Adapted for Spark Core by Paul Kourany, May 2014\par
v0.1.2 - SOS bug fixed, now compatible with all Particle devices\par
Read a card using a mfrc522 reader on your SPI interface on your Arduino{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Pin layout should be as follows (on Spark Core):\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
MOSI: Pin A5\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
MISO: Pin A4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SCK : Pin A3\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SS : Pin A2 (Configurable)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
RST : Pin D2 (Configurable)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\par}
Arduino RFID Library for {\b MFRC522}\par
Read a card using a mfrc522 reader on your SPI interface on your Arduino{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Pin layout should be as follows (on Arduino Uno):\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
MOSI: Pin 11 / ICSP-4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
MISO: Pin 12 / ICSP-1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SCK : Pin 13 / ISCP-3\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SS : Pin 10 (Configurable)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
RST : Pin 9 (Configurable)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Pin layout should be as follows (on Arduino Mega):\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
MOSI: Pin 51 / ICSP-4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
MISO: Pin 50 / ICSP-1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SCK : Pin 52 / ISCP-3\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SS : Pin 53 (Configurable)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
RST : Pin 5 (Configurable) \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
MQTT for Photon, Spark Core{\tc \v MQTT for Photon, Spark Core}\par \pard\plain 
{\bkmkstart AAAAAAABHK}
{\bkmkend AAAAAAABHK}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 MQTT} publish/subscribe library for Photon, Spark Core version 0.4.28.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 Source Code} \par}
This lightweight library source code are only 2 files. firmware -> {\b MQTT.cpp}, MQTT.h.\par
Application can use QOS0,1,2 and retain flag when send a publish message.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 Example} \par}
Some sample sketches for Spark Core and Photon included(firmware/examples/).{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
mqtttest.ino : simple pub/sub sample.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
mqttqostest.ino : QoS1, QoS2 publish and callback sample.\par}
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 developer examples} \par}
some applications use {\b MQTT} with Photon. here are developer's reference examples.{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 Spark Core / Photon and CloudMQTT}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 MQTT Publish-Subscribe Using Rpi, ESP and Photon}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 Particle Photon on Watson IoT}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 Connecting IoT devices to the Watson Conversation Car-Dashboard app}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 ThingSpeak MQTT API}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 HOW TO CONNECT A PARTICLE PHOTON TO THE LOSANT IOT PLATFORM}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 How I Hacked my Humidor with Losant and a Particle Photon}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 ARTIK as MQTT Message Broker}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 Particle and Ubidots using MQTT}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 USING TWILIO SYNC WITH MQTT ON A PARTICLE PHOTON}\par}
## sample source {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid #include "application.h"\par
#include "MQTT.h"\par
\par
void callback(char* topic, byte* payload, unsigned int length);\par
MQTT client("iot.eclipse.org", 1883, callback);\par
\par
// recieve message\par
void callback(char* topic, byte* payload, unsigned int length) \{\par
    char p[length + 1];\par
    memcpy(p, payload, length);\par
    p[length] = NULL;\par
\par
    if (!strcmp(p, "RED"))\par
        RGB.color(255, 0, 0);\par
    else if (!strcmp(p, "GREEN"))\par
        RGB.color(0, 255, 0);\par
    else if (!strcmp(p, "BLUE"))\par
        RGB.color(0, 0, 255);\par
    else\par
        RGB.color(255, 255, 255);\par
    delay(1000);\par
\}\par
\par
\par
void setup() \{\par
    RGB.control(true);\par
\par
    // connect to the server(unique id by Time.now())\par
    client.connect("sparkclient_" + String(Time.now()));\par
\par
    // publish/subscribe\par
    if (client.isConnected()) \{\par
        client.publish("outTopic/message","hello world");\par
        client.subscribe("inTopic/message");\par
    \}\par
\}\par
\par
void loop() \{\par
    if (client.isConnected())\par
        client.loop();\par
\}\par
}
 {\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 FAQ} \par}
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 Can't connect/publish/subscribe to the {\b MQTT} server?} \par}
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Check your {\b MQTT} server and port(default 1883) is really working with the mosquitto_pub/sub command. And maybe your {\b MQTT} server can't connect from Internet because of firewall. Check your network environments.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Check your subscribe/publish topic name is really matched.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Perhaps device firmware network stack is failed. check your firmware version and bugs.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If you use MQTT-TLS, check your RooT CA pem file, client key, certifications is okay or not.\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Several {\b MQTT} server will disconnect to the 1st connection when you use the same user_id. When the application call the connect method, use different user_id in every devices in connect method's 2nd argument. Use MAC address as a user_id will be better. {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
   // device.1
   client.connect("spark-client", "user_1", "password1");
   // other devices...
   client.connect("spark-client", "user_others", "password1");
\par}
\par}
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 I want to change {\b MQTT} keep alive timeout.} \par}
{\b MQTT} keepalive timeout is defined "MQTT_DEFAULT_KEEPALIVE 15"(15 sec) in header file. You can change the keepalive timeout in constructor. {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
    {\b MQTT} client("server_name", 1883, callback); // default: send keepalive packet to {\b MQTT} server in every 15sec.
    {\b MQTT} client("server_name", 1883, 30, callback); // keepliave timeout is 30sec.
\par}
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 Want to use over the 255 message size.} \par}
In this library, max {\b MQTT} message size is defined "MQTT_MAX_PACKET_SIZE 255" in header file. But If you want to use over 255bytes, use the constructor 4th argument. {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 
    {\b MQTT} client("server_name", 1883, callback); // default 255bytes
    {\b MQTT} client("server_name", 1883, MQTT_DEFAULT_KEEPALIVE, callback, 512); // max 512bytes
\par}
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 Can I use on old firmware?} \par}
No, use default latest firmware. I test this library on default latest firmware or latest pre-release version. If you really want to use old firmware(I think don't need that case), maybe it can't work well and it is out of my assumption.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 Bug or Problem?} \par}
First of all, check the {\f2 Particle community site. But still your problem will not clear, please send a bug-fixed diff and Pull request or problem details to issue. Pull Request If you have a bug or feature, please send a pull request. Thanks for all developer's pull request! }\par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Particle Photon code{\tc \v Particle Photon code}\par \pard\plain 
{\bkmkstart AAAAAAABHL}
{\bkmkend AAAAAAABHL}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The Particle Photon subsystem software named 2020_photon_code: The entire '2020_photon_code' folder is a Visual Studio project that uses the Particle Workbench and dependencies to program the Photons (remotely). {\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 Welcome to the project!} \par}
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 {\f2 /src}  folder:} \par}
This is the source folder that contains the firmware files for the project. It should {\i not}  be renamed. Anything that is in this folder when you compile your project will be sent to the Particle compile service and compiled into a firmware binary for the Particle device that you have targeted. The project is set up for Photon v2.0.1.\par
The main files are included in the {\f2 src}  folder. The dependencies are specified in the {\f2 project.properties}  file referenced below.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 {\f2 .ino}  file:} \par}
This file is the firmware that will run as the primary application on the Particle device. It contains a {\f2 {\b setup()}}  and {\f2 {\b loop()}}  function, and is written in C++.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 {\f2 project.properties}  file:} \par}
This is the file that specifies the name and version number of the libraries that the project depends on. Dependencies are added automatically to the {\f2 project.properties}  file when you add a library to a project using the {\f2 particle library add}  command in the CLI or add a library in the Desktop IDE.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 Adding additional files to the project} \par}
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 Projects with multiple sources} \par}
If you would like add additional files to your application, they should be added to the {\f2 /src}  folder. All files in the {\f2 /src}  folder will be sent to the Particle Cloud to produce a compiled binary.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 Projects with external libraries} \par}
If the project includes a library that has not been registered in the Particle libraries system, you should create a new folder named {\f2 /lib/<libraryname>/src}  under {\f2 /<project dir>}  and add the {\f2 .h} , {\f2 .cpp}  & {\f2 library.properties}  files for your library there.\par
{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {\tc\tcl4 Compiling the project} \par}
When you're ready to compile the project, make sure you have the correct Particle device target selected and run {\f2 particle compile <platform>}  in the CLI or click the Compile button in the Desktop IDE. The following files in the project folder will be sent to the compile service:\par
{
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Everything in the {\f2 /src}  folder, including your {\f2 .ino}  application file\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The {\f2 project.properties}  file for your project\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Any libraries stored under {\f2 lib/<libraryname>/src}  \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Index\par \pard\plain 
{\tc \v Namespace Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Namespace List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all namespaces with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b JsonParserGeneratorRK} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Hierarchical Index\par \pard\plain 
{\tc \v Hierarchical Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class Hierarchy\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
JsonParserGeneratorRK::jsmn_parser\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
JsonParserGeneratorRK::jsmntok_t\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
JsonBuffer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIF \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
JsonParser\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJO \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
JsonParserStatic< BUFFER_SIZE, MAX_TOKENS >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
JsonWriter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMK \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
JsonModifier\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
JsonWriterStatic< BUFFER_SIZE >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
JsonParserString\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
JsonReference\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
JsonWriterAutoArray\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
JsonWriterAutoObject\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
JsonWriterContext\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MFRC522\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MFRC522::MIFARE_Key\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MQTT\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Print\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXU \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Stream\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
StringPrintableHelper\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
Printable\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
String\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAX \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
StringSumHelper\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
MFRC522::Uid\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b JsonParserGeneratorRK::jsmn_parser} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
JSON parser })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b JsonParserGeneratorRK::jsmntok_t} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
JSON token description })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b JsonBuffer} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base class for managing a static or dynamic buffer, used by both {\b JsonParser} and {\b JsonWriter} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b JsonModifier} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for modifying a JSON object in place, without needing to make a copy of it })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b JsonParser} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
API to the {\b JsonParser} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b JsonParserStatic< BUFFER_SIZE, MAX_TOKENS >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a {\b JsonParser} with a static buffer })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b JsonParserString} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class used internally for writing to strings })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b JsonReference} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class provides a fluent-style API for easily traversing a tree of JSON objects to find a value })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b JsonWriter} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for building a JSON string })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b JsonWriterAutoArray} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for creating a JSON array with {\b JsonWriter} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b JsonWriterAutoObject} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for creating a JSON object with {\b JsonWriter} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b JsonWriterContext} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally by {\b JsonWriter} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b JsonWriterStatic< BUFFER_SIZE >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a {\b JsonWriter} with a statically allocated buffer })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MFRC522} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MFRC522::MIFARE_Key} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MQTT} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Print} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for printing to a stream or file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Printable} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Way for new classes to allow themselves to be printed })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Stream} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b String} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wiring {\b String}: A class to hold and manipulate a dynamically allocated string })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b StringPrintableHelper} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b StringSumHelper} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class used when appending mutiple {\b String} and other values using + })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MFRC522::Uid} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b lib/JsonParserGeneratorRK/docs/src/{\b spark_wiring_print.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/JsonParserGeneratorRK/docs/src/{\b spark_wiring_printable.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/JsonParserGeneratorRK/docs/src/{\b spark_wiring_string.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/JsonParserGeneratorRK/examples/1-parser/{\b 1-parser-JsonParserGeneratorRK.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/JsonParserGeneratorRK/examples/2-generator/{\b 2-generator-JsonParserGeneratorRK.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/JsonParserGeneratorRK/examples/3-subscription/{\b 3-subscription-JsonParserGeneratorRK.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/JsonParserGeneratorRK/src/{\b JsonParserGeneratorRK.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/JsonParserGeneratorRK/src/{\b JsonParserGeneratorRK.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/JsonParserGeneratorRK/test/{\b JsonTest.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/JsonParserGeneratorRK/test/gcclib/{\b helpers.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/JsonParserGeneratorRK/test/gcclib/{\b Particle.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/JsonParserGeneratorRK/test/gcclib/{\b rng_hal.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copyright (c) 2015 Particle Industries, Inc. All rights reserved })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/JsonParserGeneratorRK/test/gcclib/{\b spark_wiring_print.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wrapper for wiring print })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/JsonParserGeneratorRK/test/gcclib/{\b spark_wiring_print.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/JsonParserGeneratorRK/test/gcclib/{\b spark_wiring_printable.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/JsonParserGeneratorRK/test/gcclib/{\b spark_wiring_stream.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header for spark_wiring_stream.c module })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/JsonParserGeneratorRK/test/gcclib/{\b spark_wiring_string.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copyright (c) 2013-2015 Particle Industries, Inc. All rights reserved. ...mostly rewritten by Paul Stoffregen... Copyright (c) 2009-10 Hernando Barragan. All rights reserved. Copyright 2011, Paul Stoffregen, {\f2 paul@pjrc.com} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/JsonParserGeneratorRK/test/gcclib/{\b spark_wiring_string.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/JsonParserGeneratorRK/test/gcclib/{\b string_convert.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/JsonParserGeneratorRK/test/gcclib/{\b system_tick_hal.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copyright (c) 2013-2015 Particle Industries, Inc. All rights reserved })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/JsonParserGeneratorRK/test/gcclib/{\b test1.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/MFRC522/src/{\b MFRC522.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/MFRC522/src/{\b MFRC522.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/MFRC522/src/MFRC522/{\b MFRC522.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/MQTT/src/{\b MQTT.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/MQTT/src/{\b MQTT.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lib/MQTT/src/MQTT/{\b MQTT.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b 2020_photon_code.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b Commandparser.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b target/2.0.1/photon/obj/src/{\b module_info.o.d} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b target/2.0.1/photon/obj/src/{\b newlib_stubs.o.d} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b target/2.0.1/photon/obj/src/{\b user_export.o.d} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAID \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b target/2.0.1/photon/obj/src/{\b user_module.o.d} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Documentation\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
JsonParserGeneratorRK Namespace Reference\par \pard\plain 
{\tc\tcl2 \v JsonParserGeneratorRK}
{\xe \v JsonParserGeneratorRK}
{\bkmkstart AAAAAAABFL}
{\bkmkend AAAAAAABFL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b jsmn_parser}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
JSON parser. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b jsmntok_t}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
JSON token description. }}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b jsmntype_t} \{ {\b JSMN_UNDEFINED} = 0, 
{\b JSMN_OBJECT} = 1, 
{\b JSMN_ARRAY} = 2, 
{\b JSMN_STRING} = 3, 
{\b JSMN_PRIMITIVE} = 4
 \}{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
JSON type identifier (object, array, string, primitive) }}}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b jsmnerr} \{ {\b JSMN_ERROR_NOMEM} = -1, 
{\b JSMN_ERROR_INVAL} = -2, 
{\b JSMN_ERROR_PART} = -3
 \}{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
JSMN error codes. }}}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b jsmn_init} ({\b jsmn_parser} *parser)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create JSON parser over an array of tokens. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b jsmn_parse} ({\b jsmn_parser} *parser, const char *js, size_t len, {\b jsmntok_t} *tokens, unsigned int num_tokens)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run JSON parser. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b jsmntok_t} * {\b jsmn_alloc_token} ({\b jsmn_parser} *parser, {\b jsmntok_t} *tokens, size_t num_tokens)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b jsmn_fill_token} ({\b jsmntok_t} *token, {\b jsmntype_t} type, int start, int end)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b jsmn_parse_primitive} ({\b jsmn_parser} *parser, const char *js, size_t len, {\b jsmntok_t} *tokens, size_t num_tokens)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b jsmn_parse_string} ({\b jsmn_parser} *parser, const char *js, size_t len, {\b jsmntok_t} *tokens, size_t num_tokens)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v jsmnerr\:JsonParserGeneratorRK}
{\xe \v JsonParserGeneratorRK\:jsmnerr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b JsonParserGeneratorRK::jsmnerr}}}
\par
{\bkmkstart AAAAAAABFM}
{\bkmkend AAAAAAABFM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
JSMN error codes. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v JSMN_ERROR_NOMEM\:JsonParserGeneratorRK}
{\xe \v JsonParserGeneratorRK\:JSMN_ERROR_NOMEM}
{\qr JSMN_ERROR_NOMEM{\bkmkstart AAAAAAABFN}
{\bkmkend AAAAAAABFN}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Not enough tokens were provided. \par
}\cell }{\row }
{\xe \v JSMN_ERROR_INVAL\:JsonParserGeneratorRK}
{\xe \v JsonParserGeneratorRK\:JSMN_ERROR_INVAL}
{\qr JSMN_ERROR_INVAL{\bkmkstart AAAAAAABFO}
{\bkmkend AAAAAAABFO}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Invalid character inside JSON string. \par
}\cell }{\row }
{\xe \v JSMN_ERROR_PART\:JsonParserGeneratorRK}
{\xe \v JsonParserGeneratorRK\:JSMN_ERROR_PART}
{\qr JSMN_ERROR_PART{\bkmkstart AAAAAAABFP}
{\bkmkend AAAAAAABFP}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The string is not a full JSON packet, more bytes expected. \par
}\cell }{\row }
}
{
Definition at line 30 of file JsonParserGeneratorRK.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    30                  \{\par
   31         JSMN_ERROR_NOMEM = -1,  \par
   32         JSMN_ERROR_INVAL = -2,  \par
   33         JSMN_ERROR_PART = -3    \par
   34     \};\par
}
}
{\xe \v jsmntype_t\:JsonParserGeneratorRK}
{\xe \v JsonParserGeneratorRK\:jsmntype_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b JsonParserGeneratorRK::jsmntype_t}}}
\par
{\bkmkstart AAAAAAABFQ}
{\bkmkend AAAAAAABFQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
JSON type identifier (object, array, string, primitive) }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v JSMN_UNDEFINED\:JsonParserGeneratorRK}
{\xe \v JsonParserGeneratorRK\:JSMN_UNDEFINED}
{\qr JSMN_UNDEFINED{\bkmkstart AAAAAAABFR}
{\bkmkend AAAAAAABFR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
undefined JSON type \par
}\cell }{\row }
{\xe \v JSMN_OBJECT\:JsonParserGeneratorRK}
{\xe \v JsonParserGeneratorRK\:JSMN_OBJECT}
{\qr JSMN_OBJECT{\bkmkstart AAAAAAABFS}
{\bkmkend AAAAAAABFS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
JSON object. \par
}\cell }{\row }
{\xe \v JSMN_ARRAY\:JsonParserGeneratorRK}
{\xe \v JsonParserGeneratorRK\:JSMN_ARRAY}
{\qr JSMN_ARRAY{\bkmkstart AAAAAAABFT}
{\bkmkend AAAAAAABFT}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
JSON array. \par
}\cell }{\row }
{\xe \v JSMN_STRING\:JsonParserGeneratorRK}
{\xe \v JsonParserGeneratorRK\:JSMN_STRING}
{\qr JSMN_STRING{\bkmkstart AAAAAAABFU}
{\bkmkend AAAAAAABFU}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
JSON string. \par
}\cell }{\row }
{\xe \v JSMN_PRIMITIVE\:JsonParserGeneratorRK}
{\xe \v JsonParserGeneratorRK\:JSMN_PRIMITIVE}
{\qr JSMN_PRIMITIVE{\bkmkstart AAAAAAABFV}
{\bkmkend AAAAAAABFV}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
JSON primitive (number, true, false, or null) \par
}\cell }{\row }
}
{
Definition at line 19 of file JsonParserGeneratorRK.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    19                  \{\par
   20         JSMN_UNDEFINED = 0, \par
   21         JSMN_OBJECT = 1,    \par
   22         JSMN_ARRAY = 2,     \par
   23         JSMN_STRING = 3,    \par
   24         JSMN_PRIMITIVE = 4  \par
   25     \} jsmntype_t;\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v jsmn_alloc_token\:JsonParserGeneratorRK}
{\xe \v JsonParserGeneratorRK\:jsmn_alloc_token}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b jsmntok_t}* JsonParserGeneratorRK::jsmn_alloc_token ({\b jsmn_parser} *  {\i parser}, {\b jsmntok_t} *  {\i tokens}, size_t  {\i num_tokens}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFW}
{\bkmkend AAAAAAABFW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allocates a fresh unused token from the token pull. \par
}{
Definition at line 1102 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParserGeneratorRK::jsmntok_t::end, JsonParserGeneratorRK::jsmntok_t::size, JsonParserGeneratorRK::jsmntok_t::start, and JsonParserGeneratorRK::jsmn_parser::toknext.}\par
{
Referenced by jsmn_parse(), jsmn_parse_primitive(), and jsmn_parse_string().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1103                                               \{\par
 1104     jsmntok_t *tok;\par
 1105     if (parser->toknext >= num_tokens) \{\par
 1106         return NULL;\par
 1107     \}\par
 1108     tok = &tokens[parser->toknext++];\par
 1109     tok->start = tok->end = -1;\par
 1110     tok->size = 0;\par
 1111 #ifdef JSMN_PARENT_LINKS\par
 1112     tok->parent = -1;\par
 1113 #endif\par
 1114     return tok;\par
 1115 \}\par
}
}
{\xe \v jsmn_fill_token\:JsonParserGeneratorRK}
{\xe \v JsonParserGeneratorRK\:jsmn_fill_token}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static void JsonParserGeneratorRK::jsmn_fill_token ({\b jsmntok_t} *  {\i token}, {\b jsmntype_t}  {\i type}, int  {\i start}, int  {\i end}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABFX}
{\bkmkend AAAAAAABFX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fills token type and boundaries. \par
}{
Definition at line 1120 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParserGeneratorRK::jsmntok_t::end, JsonParserGeneratorRK::jsmntok_t::size, JsonParserGeneratorRK::jsmntok_t::start, and JsonParserGeneratorRK::jsmntok_t::type.}\par
{
Referenced by jsmn_parse_primitive(), and jsmn_parse_string().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1121                                                 \{\par
 1122     token->type = type;\par
 1123     token->start = start;\par
 1124     token->end = end;\par
 1125     token->size = 0;\par
 1126 \}\par
}
}
{\xe \v jsmn_init\:JsonParserGeneratorRK}
{\xe \v JsonParserGeneratorRK\:jsmn_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonParserGeneratorRK::jsmn_init ({\b jsmn_parser} *  {\i parser})}}
\par
{\bkmkstart AAAAAAABFY}
{\bkmkend AAAAAAABFY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create JSON parser over an array of tokens. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new parser based over a given buffer with an array of tokens available. \par
}{
Definition at line 1405 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParserGeneratorRK::jsmn_parser::pos, JsonParserGeneratorRK::jsmn_parser::toknext, and JsonParserGeneratorRK::jsmn_parser::toksuper.}\par
{
Referenced by JsonParser::parse().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1405                                     \{\par
 1406     parser->pos = 0;\par
 1407     parser->toknext = 0;\par
 1408     parser->toksuper = -1;\par
 1409 \}\par
}
}
{\xe \v jsmn_parse\:JsonParserGeneratorRK}
{\xe \v JsonParserGeneratorRK\:jsmn_parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int JsonParserGeneratorRK::jsmn_parse ({\b jsmn_parser} *  {\i parser}, const char *  {\i js}, size_t  {\i len}, {\b jsmntok_t} *  {\i tokens}, unsigned int  {\i num_tokens})}}
\par
{\bkmkstart AAAAAAABFZ}
{\bkmkend AAAAAAABFZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run JSON parser. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It parses a JSON data string into and array of tokens, each describing a single JSON object.\par
Parse JSON string and fill tokens. \par
}{
Definition at line 1247 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParserGeneratorRK::jsmntok_t::end, jsmn_alloc_token(), JSMN_ARRAY, JSMN_ERROR_INVAL, JSMN_ERROR_NOMEM, JSMN_ERROR_PART, JSMN_OBJECT, jsmn_parse_primitive(), jsmn_parse_string(), JsonParserGeneratorRK::jsmn_parser::pos, JsonParserGeneratorRK::jsmntok_t::size, JsonParserGeneratorRK::jsmntok_t::start, JsonParserGeneratorRK::jsmn_parser::toknext, JsonParserGeneratorRK::jsmn_parser::toksuper, and JsonParserGeneratorRK::jsmntok_t::type.}\par
{
Referenced by JsonParser::parse().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1248                                                     \{\par
 1249     int r;\par
 1250     int i;\par
 1251     jsmntok_t *token;\par
 1252     int count = parser->toknext;\par
 1253 \par
 1254     for (; parser->pos < len && js[parser->pos] != '\\0'; parser->pos++) \{\par
 1255         char c;\par
 1256         jsmntype_t type;\par
 1257 \par
 1258         c = js[parser->pos];\par
 1259         switch (c) \{\par
 1260             case '\{': case '[':\par
 1261                 count++;\par
 1262                 if (tokens == NULL) \{\par
 1263                     break;\par
 1264                 \}\par
 1265                 token = jsmn_alloc_token(parser, tokens, num_tokens);\par
 1266                 if (token == NULL)\par
 1267                     return JSMN_ERROR_NOMEM;\par
 1268                 if (parser->toksuper != -1) \{\par
 1269                     tokens[parser->toksuper].size++;\par
 1270 #ifdef JSMN_PARENT_LINKS\par
 1271                     token->parent = parser->toksuper;\par
 1272 #endif\par
 1273                 \}\par
 1274                 token->type = (c == '\{' ? JSMN_OBJECT : JSMN_ARRAY);\par
 1275                 token->start = parser->pos;\par
 1276                 parser->toksuper = parser->toknext - 1;\par
 1277                 break;\par
 1278             case '\}': case ']':\par
 1279                 if (tokens == NULL)\par
 1280                     break;\par
 1281                 type = (c == '\}' ? JSMN_OBJECT : JSMN_ARRAY);\par
 1282 #ifdef JSMN_PARENT_LINKS\par
 1283                 if (parser->toknext < 1) \{\par
 1284                     return JSMN_ERROR_INVAL;\par
 1285                 \}\par
 1286                 token = &tokens[parser->toknext - 1];\par
 1287                 for (;;) \{\par
 1288                     if (token->start != -1 && token->end == -1) \{\par
 1289                         if (token->type != type) \{\par
 1290                             return JSMN_ERROR_INVAL;\par
 1291                         \}\par
 1292                         token->end = parser->pos + 1;\par
 1293                         parser->toksuper = token->parent;\par
 1294                         break;\par
 1295                     \}\par
 1296                     if (token->parent == -1) \{\par
 1297                         if(token->type != type || parser->toksuper == -1) \{\par
 1298                             return JSMN_ERROR_INVAL;\par
 1299                         \}\par
 1300                         break;\par
 1301                     \}\par
 1302                     token = &tokens[token->parent];\par
 1303                 \}\par
 1304 #else\par
 1305                 for (i = parser->toknext - 1; i >= 0; i--) \{\par
 1306                     token = &tokens[i];\par
 1307                     if (token->start != -1 && token->end == -1) \{\par
 1308                         if (token->type != type) \{\par
 1309                             return JSMN_ERROR_INVAL;\par
 1310                         \}\par
 1311                         parser->toksuper = -1;\par
 1312                         token->end = parser->pos + 1;\par
 1313                         break;\par
 1314                     \}\par
 1315                 \}\par
 1316                 /* Error if unmatched closing bracket */\par
 1317                 if (i == -1) return JSMN_ERROR_INVAL;\par
 1318                 for (; i >= 0; i--) \{\par
 1319                     token = &tokens[i];\par
 1320                     if (token->start != -1 && token->end == -1) \{\par
 1321                         parser->toksuper = i;\par
 1322                         break;\par
 1323                     \}\par
 1324                 \}\par
 1325 #endif\par
 1326                 break;\par
 1327             case '\\"':\par
 1328                 r = jsmn_parse_string(parser, js, len, tokens, num_tokens);\par
 1329                 if (r < 0) return r;\par
 1330                 count++;\par
 1331                 if (parser->toksuper != -1 && tokens != NULL)\par
 1332                     tokens[parser->toksuper].size++;\par
 1333                 break;\par
 1334             case '\\t' : case '\\r' : case '\\n' : case ' ':\par
 1335                 break;\par
 1336             case ':':\par
 1337                 parser->toksuper = parser->toknext - 1;\par
 1338                 break;\par
 1339             case ',':\par
 1340                 if (tokens != NULL && parser->toksuper != -1 &&\par
 1341                         tokens[parser->toksuper].type != JSMN_ARRAY &&\par
 1342                         tokens[parser->toksuper].type != JSMN_OBJECT) \{\par
 1343 #ifdef JSMN_PARENT_LINKS\par
 1344                     parser->toksuper = tokens[parser->toksuper].parent;\par
 1345 #else\par
 1346                     for (i = parser->toknext - 1; i >= 0; i--) \{\par
 1347                         if (tokens[i].type == JSMN_ARRAY || tokens[i].type == JSMN_OBJECT) \{\par
 1348                             if (tokens[i].start != -1 && tokens[i].end == -1) \{\par
 1349                                 parser->toksuper = i;\par
 1350                                 break;\par
 1351                             \}\par
 1352                         \}\par
 1353                     \}\par
 1354 #endif\par
 1355                 \}\par
 1356                 break;\par
 1357 #ifdef JSMN_STRICT\par
 1358             /* In strict mode primitives are: numbers and booleans */\par
 1359             case '-': case '0': case '1' : case '2': case '3' : case '4':\par
 1360             case '5': case '6': case '7' : case '8': case '9':\par
 1361             case 't': case 'f': case 'n' :\par
 1362                 /* And they must not be keys of the object */\par
 1363                 if (tokens != NULL && parser->toksuper != -1) \{\par
 1364                     jsmntok_t *t = &tokens[parser->toksuper];\par
 1365                     if (t->type == JSMN_OBJECT ||\par
 1366                             (t->type == JSMN_STRING && t->size != 0)) \{\par
 1367                         return JSMN_ERROR_INVAL;\par
 1368                     \}\par
 1369                 \}\par
 1370 #else\par
 1371             /* In non-strict mode every unquoted value is a primitive */\par
 1372             default:\par
 1373 #endif\par
 1374                 r = jsmn_parse_primitive(parser, js, len, tokens, num_tokens);\par
 1375                 if (r < 0) return r;\par
 1376                 count++;\par
 1377                 if (parser->toksuper != -1 && tokens != NULL)\par
 1378                     tokens[parser->toksuper].size++;\par
 1379                 break;\par
 1380 \par
 1381 #ifdef JSMN_STRICT\par
 1382             /* Unexpected char in strict mode */\par
 1383             default:\par
 1384                 return JSMN_ERROR_INVAL;\par
 1385 #endif\par
 1386         \}\par
 1387     \}\par
 1388 \par
 1389     if (tokens != NULL) \{\par
 1390         for (i = parser->toknext - 1; i >= 0; i--) \{\par
 1391             /* Unmatched opened object or array */\par
 1392             if (tokens[i].start != -1 && tokens[i].end == -1) \{\par
 1393                 return JSMN_ERROR_PART;\par
 1394             \}\par
 1395         \}\par
 1396     \}\par
 1397 \par
 1398     return count;\par
 1399 \}\par
}
}
{\xe \v jsmn_parse_primitive\:JsonParserGeneratorRK}
{\xe \v JsonParserGeneratorRK\:jsmn_parse_primitive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int JsonParserGeneratorRK::jsmn_parse_primitive ({\b jsmn_parser} *  {\i parser}, const char *  {\i js}, size_t  {\i len}, {\b jsmntok_t} *  {\i tokens}, size_t  {\i num_tokens}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGA}
{\bkmkend AAAAAAABGA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fills next available token with JSON primitive. \par
}{
Definition at line 1131 of file JsonParserGeneratorRK.cpp.}\par
{
References jsmn_alloc_token(), JSMN_ERROR_INVAL, JSMN_ERROR_NOMEM, jsmn_fill_token(), JSMN_PRIMITIVE, and JsonParserGeneratorRK::jsmn_parser::pos.}\par
{
Referenced by jsmn_parse().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1132                                                           \{\par
 1133     jsmntok_t *token;\par
 1134     int start;\par
 1135 \par
 1136     start = parser->pos;\par
 1137 \par
 1138     for (; parser->pos < len && js[parser->pos] != '\\0'; parser->pos++) \{\par
 1139         switch (js[parser->pos]) \{\par
 1140 #ifndef JSMN_STRICT\par
 1141             /* In strict mode primitive must be followed by "," or "\}" or "]" */\par
 1142             case ':':\par
 1143 #endif\par
 1144             case '\\t' : case '\\r' : case '\\n' : case ' ' :\par
 1145             case ','  : case ']'  : case '\}' :\par
 1146                 goto found;\par
 1147         \}\par
 1148         if (js[parser->pos] < 32 || js[parser->pos] >= 127) \{\par
 1149             parser->pos = start;\par
 1150             return JSMN_ERROR_INVAL;\par
 1151         \}\par
 1152     \}\par
 1153 #ifdef JSMN_STRICT\par
 1154     /* In strict mode primitive must be followed by a comma/object/array */\par
 1155     parser->pos = start;\par
 1156     return JSMN_ERROR_PART;\par
 1157 #endif\par
 1158 \par
 1159 found:\par
 1160     if (tokens == NULL) \{\par
 1161         parser->pos--;\par
 1162         return 0;\par
 1163     \}\par
 1164     token = jsmn_alloc_token(parser, tokens, num_tokens);\par
 1165     if (token == NULL) \{\par
 1166         parser->pos = start;\par
 1167         return JSMN_ERROR_NOMEM;\par
 1168     \}\par
 1169     jsmn_fill_token(token, JSMN_PRIMITIVE, start, parser->pos);\par
 1170 #ifdef JSMN_PARENT_LINKS\par
 1171     token->parent = parser->toksuper;\par
 1172 #endif\par
 1173     parser->pos--;\par
 1174     return 0;\par
 1175 \}\par
}
}
{\xe \v jsmn_parse_string\:JsonParserGeneratorRK}
{\xe \v JsonParserGeneratorRK\:jsmn_parse_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static int JsonParserGeneratorRK::jsmn_parse_string ({\b jsmn_parser} *  {\i parser}, const char *  {\i js}, size_t  {\i len}, {\b jsmntok_t} *  {\i tokens}, size_t  {\i num_tokens}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABGB}
{\bkmkend AAAAAAABGB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fills next token with JSON string. \par
}{
Definition at line 1180 of file JsonParserGeneratorRK.cpp.}\par
{
References jsmn_alloc_token(), JSMN_ERROR_INVAL, JSMN_ERROR_NOMEM, JSMN_ERROR_PART, jsmn_fill_token(), JSMN_STRING, and JsonParserGeneratorRK::jsmn_parser::pos.}\par
{
Referenced by jsmn_parse().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1181                                                           \{\par
 1182     jsmntok_t *token;\par
 1183 \par
 1184     int start = parser->pos;\par
 1185 \par
 1186     parser->pos++;\par
 1187 \par
 1188     /* Skip starting quote */\par
 1189     for (; parser->pos < len && js[parser->pos] != '\\0'; parser->pos++) \{\par
 1190         char c = js[parser->pos];\par
 1191 \par
 1192         /* Quote: end of string */\par
 1193         if (c == '\\"') \{\par
 1194             if (tokens == NULL) \{\par
 1195                 return 0;\par
 1196             \}\par
 1197             token = jsmn_alloc_token(parser, tokens, num_tokens);\par
 1198             if (token == NULL) \{\par
 1199                 parser->pos = start;\par
 1200                 return JSMN_ERROR_NOMEM;\par
 1201             \}\par
 1202             jsmn_fill_token(token, JSMN_STRING, start+1, parser->pos);\par
 1203 #ifdef JSMN_PARENT_LINKS\par
 1204             token->parent = parser->toksuper;\par
 1205 #endif\par
 1206             return 0;\par
 1207         \}\par
 1208 \par
 1209         /* Backslash: Quoted symbol expected */\par
 1210         if (c == '\\\\' && parser->pos + 1 < len) \{\par
 1211             int i;\par
 1212             parser->pos++;\par
 1213             switch (js[parser->pos]) \{\par
 1214                 /* Allowed escaped symbols */\par
 1215                 case '\\"': case '/' : case '\\\\' : case 'b' :\par
 1216                 case 'f' : case 'r' : case 'n'  : case 't' :\par
 1217                     break;\par
 1218                 /* Allows escaped symbol \\uXXXX */\par
 1219                 case 'u':\par
 1220                     parser->pos++;\par
 1221                     for(i = 0; i < 4 && parser->pos < len && js[parser->pos] != '\\0'; i++) \{\par
 1222                         /* If it isn't a hex character we have an error */\par
 1223                         if(!((js[parser->pos] >= 48 && js[parser->pos] <= 57) || /* 0-9 */\par
 1224                                     (js[parser->pos] >= 65 && js[parser->pos] <= 70) || /* A-F */\par
 1225                                     (js[parser->pos] >= 97 && js[parser->pos] <= 102))) \{ /* a-f */\par
 1226                             parser->pos = start;\par
 1227                             return JSMN_ERROR_INVAL;\par
 1228                         \}\par
 1229                         parser->pos++;\par
 1230                     \}\par
 1231                     parser->pos--;\par
 1232                     break;\par
 1233                 /* Unexpected symbol */\par
 1234                 default:\par
 1235                     parser->pos = start;\par
 1236                     return JSMN_ERROR_INVAL;\par
 1237             \}\par
 1238         \}\par
 1239     \}\par
 1240     parser->pos = start;\par
 1241     return JSMN_ERROR_PART;\par
 1242 \}\par
}
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
JsonParserGeneratorRK::jsmn_parser Struct Reference\par \pard\plain 
{\tc\tcl2 \v JsonParserGeneratorRK::jsmn_parser}
{\xe \v JsonParserGeneratorRK::jsmn_parser}
{\bkmkstart AAAAAAABGC}
{\bkmkend AAAAAAABGC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
JSON parser. }}\par
{
{\f2 #include <JsonParserGeneratorRK.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b pos}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
offset in the JSON string }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b toknext}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
next token to allocate }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b toksuper}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
superior token node, e.g parent object or array }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
JSON parser. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains an array of token blocks available. Also stores the string being parsed now and current position in that string. \par
}{
Definition at line 55 of file JsonParserGeneratorRK.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v pos\:JsonParserGeneratorRK::jsmn_parser}
{\xe \v JsonParserGeneratorRK::jsmn_parser\:pos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int JsonParserGeneratorRK::jsmn_parser::pos}}
\par
{\bkmkstart AAAAAAABGD}
{\bkmkend AAAAAAABGD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
offset in the JSON string }}\par
{
Definition at line 56 of file JsonParserGeneratorRK.h.}\par
{
Referenced by JsonParserGeneratorRK::jsmn_init(), JsonParserGeneratorRK::jsmn_parse(), JsonParserGeneratorRK::jsmn_parse_primitive(), and JsonParserGeneratorRK::jsmn_parse_string().}\par
}
{\xe \v toknext\:JsonParserGeneratorRK::jsmn_parser}
{\xe \v JsonParserGeneratorRK::jsmn_parser\:toknext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int JsonParserGeneratorRK::jsmn_parser::toknext}}
\par
{\bkmkstart AAAAAAABGE}
{\bkmkend AAAAAAABGE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
next token to allocate }}\par
{
Definition at line 57 of file JsonParserGeneratorRK.h.}\par
{
Referenced by JsonParserGeneratorRK::jsmn_alloc_token(), JsonParserGeneratorRK::jsmn_init(), and JsonParserGeneratorRK::jsmn_parse().}\par
}
{\xe \v toksuper\:JsonParserGeneratorRK::jsmn_parser}
{\xe \v JsonParserGeneratorRK::jsmn_parser\:toksuper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int JsonParserGeneratorRK::jsmn_parser::toksuper}}
\par
{\bkmkstart AAAAAAABGF}
{\bkmkend AAAAAAABGF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
superior token node, e.g parent object or array }}\par
{
Definition at line 58 of file JsonParserGeneratorRK.h.}\par
{
Referenced by JsonParserGeneratorRK::jsmn_init(), and JsonParserGeneratorRK::jsmn_parse().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/src/{\b JsonParserGeneratorRK.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
JsonParserGeneratorRK::jsmntok_t Struct Reference\par \pard\plain 
{\tc\tcl2 \v JsonParserGeneratorRK::jsmntok_t}
{\xe \v JsonParserGeneratorRK::jsmntok_t}
{\bkmkstart AAAAAAABGG}
{\bkmkend AAAAAAABGG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
JSON token description. }}\par
{
{\f2 #include <JsonParserGeneratorRK.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b jsmntype_t} {\b type}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
type (object, array, string etc.) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b start}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
start position in JSON data string }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b end}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
end position in JSON data string }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b size}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
size }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
JSON token description. \par
}{
Definition at line 39 of file JsonParserGeneratorRK.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v end\:JsonParserGeneratorRK::jsmntok_t}
{\xe \v JsonParserGeneratorRK::jsmntok_t\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int JsonParserGeneratorRK::jsmntok_t::end}}
\par
{\bkmkstart AAAAAAABGH}
{\bkmkend AAAAAAABGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
end position in JSON data string }}\par
{
Definition at line 42 of file JsonParserGeneratorRK.h.}\par
{
Referenced by JsonParser::copyTokenValue(), JsonModifier::findRightComma(), JsonParser::getArraySize(), JsonParser::getKeyValueTokenByIndex(), JsonParser::getTokenByIndex(), JsonParser::getTokenJsonString(), JsonParser::getTokenValue(), JsonParser::getValueTokenByIndex(), JsonParserGeneratorRK::jsmn_alloc_token(), JsonParserGeneratorRK::jsmn_fill_token(), JsonParserGeneratorRK::jsmn_parse(), main(), printJsonInner(), printToken(), JsonModifier::removeArrayIndex(), JsonModifier::removeKeyValue(), JsonParser::skipObject(), JsonModifier::startAppend(), JsonModifier::startModify(), and JsonModifier::tokenWithQuotes().}\par
}
{\xe \v size\:JsonParserGeneratorRK::jsmntok_t}
{\xe \v JsonParserGeneratorRK::jsmntok_t\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int JsonParserGeneratorRK::jsmntok_t::size}}
\par
{\bkmkstart AAAAAAABGI}
{\bkmkend AAAAAAABGI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
size }}\par
{
Definition at line 43 of file JsonParserGeneratorRK.h.}\par
{
Referenced by JsonParserGeneratorRK::jsmn_alloc_token(), JsonParserGeneratorRK::jsmn_fill_token(), JsonParserGeneratorRK::jsmn_parse(), printToken(), and JsonModifier::startAppend().}\par
}
{\xe \v start\:JsonParserGeneratorRK::jsmntok_t}
{\xe \v JsonParserGeneratorRK::jsmntok_t\:start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int JsonParserGeneratorRK::jsmntok_t::start}}
\par
{\bkmkstart AAAAAAABGJ}
{\bkmkend AAAAAAABGJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
start position in JSON data string }}\par
{
Definition at line 41 of file JsonParserGeneratorRK.h.}\par
{
Referenced by JsonParser::copyTokenValue(), JsonModifier::findLeftComma(), JsonParser::getTokenJsonString(), JsonParser::getTokenValue(), JsonParserGeneratorRK::jsmn_alloc_token(), JsonParserGeneratorRK::jsmn_fill_token(), JsonParserGeneratorRK::jsmn_parse(), main(), printJsonInner(), printToken(), JsonModifier::removeArrayIndex(), JsonModifier::removeKeyValue(), JsonModifier::startModify(), and JsonModifier::tokenWithQuotes().}\par
}
{\xe \v type\:JsonParserGeneratorRK::jsmntok_t}
{\xe \v JsonParserGeneratorRK::jsmntok_t\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b jsmntype_t} JsonParserGeneratorRK::jsmntok_t::type}}
\par
{\bkmkstart AAAAAAABGK}
{\bkmkend AAAAAAABGK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
type (object, array, string etc.) }}\par
{
Definition at line 40 of file JsonParserGeneratorRK.h.}\par
{
Referenced by JsonParser::getOuterArray(), JsonParser::getOuterObject(), JsonParser::getOuterToken(), JsonParserGeneratorRK::jsmn_fill_token(), JsonParserGeneratorRK::jsmn_parse(), printJsonInner(), printToken(), and JsonModifier::tokenWithQuotes().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/src/{\b JsonParserGeneratorRK.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
JsonBuffer Class Reference\par \pard\plain 
{\tc\tcl2 \v JsonBuffer}
{\xe \v JsonBuffer}
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base class for managing a static or dynamic buffer, used by both {\b JsonParser} and {\b JsonWriter}. }}\par
{
{\f2 #include <JsonParserGeneratorRK.h>}}\par
Inheritance diagram for JsonBuffer:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_json_buffer__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonBuffer} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b JsonBuffer} object with no external buffer specified. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~JsonBuffer} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. Destroying the object does not delete any underlying buffer! }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonBuffer} (char *{\b buffer}, size_t {\b bufferLen})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b JsonBuffer} with an external buffer of a given size. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBuffer} (char *{\b buffer}, size_t {\b bufferLen})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the buffers to the specified buffer and length. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b allocate} (size_t len)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allocate the buffer using malloc/realloc. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b addString} (const char *data)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a c-string to the end of the buffer. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b addData} (const char *data, size_t dataLen)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a string to the end of the buffer. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b getBuffer} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a pointer to the internal buffer. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b getOffset} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the current offset for writing. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setOffset} (size_t {\b offset})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
swets the current offset for writing }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b getBufferLen} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the current length of the buffer. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears the current buffer for writing. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b nullTerminate} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Null terminates the buffer. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b buffer}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The buffer to to read from or write to. This is not null-terminated. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b bufferLen}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The length of the buffer in bytes,. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b offset}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The read or write offset. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b staticBuffers}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
True if the buffers were passed in and should not freed or reallocated. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base class for managing a static or dynamic buffer, used by both {\b JsonParser} and {\b JsonWriter}. \par
}{
Definition at line 146 of file JsonParserGeneratorRK.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v JsonBuffer\:JsonBuffer}
{\xe \v JsonBuffer\:JsonBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
JsonBuffer::JsonBuffer ()}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b JsonBuffer} object with no external buffer specified. }}\par
{
Definition at line 6 of file JsonParserGeneratorRK.cpp.}\par
{
References buffer, bufferLen, offset, and staticBuffers.}\par
{
Referenced by JsonParser::JsonParser(), and JsonWriter::JsonWriter().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     6                         : buffer(0), bufferLen(0), offset(0), staticBuffers(false) \{\par
    7 \par
    8 \}\par
}
}
{\xe \v ~JsonBuffer\:JsonBuffer}
{\xe \v JsonBuffer\:~JsonBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
JsonBuffer::~JsonBuffer (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. Destroying the object does not delete any underlying buffer! }}\par
{
Definition at line 9 of file JsonParserGeneratorRK.cpp.}\par
{
References buffer, and staticBuffers.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     9                         \{\par
   10     if (!staticBuffers && buffer) \{\par
   11         free(buffer);\par
   12     \}\par
   13 \}\par
}
}
{\xe \v JsonBuffer\:JsonBuffer}
{\xe \v JsonBuffer\:JsonBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
JsonBuffer::JsonBuffer (char *  {\i buffer}, size_t  {\i bufferLen})}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b JsonBuffer} with an external buffer of a given size. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buffer} \cell }{Pointer to the buffer\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bufferLen} \cell }{The length of the buffer\cell }
{\row }
}
This buffer will not be deleted when the object is destructed. \par
}{
Definition at line 15 of file JsonParserGeneratorRK.cpp.}\par
{
References buffer, bufferLen, offset, and staticBuffers.}\par
{
Referenced by JsonParser::JsonParser(), and JsonWriter::JsonWriter().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    15                                                       : buffer(buffer), bufferLen(bufferLen), offset(0), staticBuffers(true) \{\par
   16 \par
   17 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addData\:JsonBuffer}
{\xe \v JsonBuffer\:addData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonBuffer::addData (const char *  {\i data}, size_t  {\i dataLen})}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a string to the end of the buffer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{Pointer to the string bytes. Does not need to be null-terminated\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dataLen} \cell }{Length of the data in bytes. For UTF-8, this is the number of bytes, not characters! \cell }
{\row }
}
}{
Definition at line 48 of file JsonParserGeneratorRK.cpp.}\par
{
References allocate(), buffer, bufferLen, and offset.}\par
{
Referenced by addString(), and main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    48                                                          \{\par
   49     if (!buffer || (offset + dataLen) > bufferLen) \{\par
   50         // Need to allocate more space for data\par
   51         if (!allocate(offset + dataLen)) \{\par
   52             return false;\par
   53         \}\par
   54     \}\par
   55 \par
   56     memcpy(&buffer[offset], data, dataLen);\par
   57     offset += dataLen;\par
   58 \par
   59     return true;\par
   60 \}\par
}
}
{\xe \v addString\:JsonBuffer}
{\xe \v JsonBuffer\:addString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonBuffer::addString (const char *  {\i data}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Add a c-string to the end of the buffer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{Pointer to a c-string (null terminated). \cell }
{\row }
}
}{
Definition at line 197 of file JsonParserGeneratorRK.h.}\par
{
References addData().}\par
{
Referenced by main(), runTest(), and subscriptionHandler().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   197 \{ return addData(data, strlen(data)); \}\par
}
}
{\xe \v allocate\:JsonBuffer}
{\xe \v JsonBuffer\:allocate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonBuffer::allocate (size_t  {\i len})}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Allocate the buffer using malloc/realloc. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i len} \cell }{The length of the buffer in bytes\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the allocation/reallocation was successful or false if there was not enough free memory.\par
}There's also a version that takes a pointer and length to use a static buffer instead of a dynamically allocated one. \par
}{
Definition at line 25 of file JsonParserGeneratorRK.cpp.}\par
{
References buffer, bufferLen, and staticBuffers.}\par
{
Referenced by addData(), and main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    25                                     \{\par
   26     if (!staticBuffers) \{\par
   27         char *newBuffer;\par
   28         if (buffer) \{\par
   29             newBuffer = (char *) realloc(buffer, len);\par
   30         \}\par
   31         else \{\par
   32             newBuffer = (char *) malloc(len);\par
   33         \}\par
   34         if (newBuffer) \{\par
   35             buffer = newBuffer;\par
   36             bufferLen = len;\par
   37             return true;\par
   38         \}\par
   39         else \{\par
   40             return false;\par
   41         \}\par
   42     \}\par
   43     else \{\par
   44         return false;\par
   45     \}\par
   46 \}\par
}
}
{\xe \v clear\:JsonBuffer}
{\xe \v JsonBuffer\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonBuffer::clear ()}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears the current buffer for writing. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This only sets the offset to 0, it does not clear the bytes. \par
}{
Definition at line 62 of file JsonParserGeneratorRK.cpp.}\par
{
References offset.}\par
{
Referenced by getMeasure_callback(), runTest(), and subscriptionHandler().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    62                        \{\par
   63     offset = 0;\par
   64 \}\par
}
}
{\xe \v getBuffer\:JsonBuffer}
{\xe \v JsonBuffer\:getBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* JsonBuffer::getBuffer () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a pointer to the internal buffer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Note: The internal buffer is not null-terminated! \par
}{
Definition at line 213 of file JsonParserGeneratorRK.h.}\par
{
References buffer.}\par
{
Referenced by _assertJsonParserBuffer(), _assertJsonWriterBuffer(), JsonModifier::findLeftComma(), JsonModifier::findRightComma(), JsonModifier::finish(), printJsonInner(), printToken(), JsonModifier::removeArrayIndex(), JsonModifier::removeKeyValue(), runTest(), JsonModifier::startAppend(), and JsonModifier::startModify().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   213 \{ return buffer; \}\par
}
}
{\xe \v getBufferLen\:JsonBuffer}
{\xe \v JsonBuffer\:getBufferLen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t JsonBuffer::getBufferLen () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the current length of the buffer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The buffer length is either the bufferLen passed to the constructor that takes a buffer and bufferLen or the length allocated using allocate(len). \par
}{
Definition at line 231 of file JsonParserGeneratorRK.h.}\par
{
References bufferLen.}\par
{
Referenced by JsonModifier::startAppend(), and JsonModifier::startModify().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   231 \{ return bufferLen; \}\par
}
}
{\xe \v getOffset\:JsonBuffer}
{\xe \v JsonBuffer\:getOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t JsonBuffer::getOffset () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the current offset for writing. }}\par
{
Definition at line 218 of file JsonParserGeneratorRK.h.}\par
{
References offset.}\par
{
Referenced by _assertJsonParserBuffer(), _assertJsonWriterBuffer(), JsonModifier::findRightComma(), JsonModifier::finish(), JsonModifier::removeArrayIndex(), JsonModifier::removeKeyValue(), JsonModifier::startAppend(), and JsonModifier::startModify().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   218 \{ return offset; \}\par
}
}
{\xe \v nullTerminate\:JsonBuffer}
{\xe \v JsonBuffer\:nullTerminate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonBuffer::nullTerminate ()}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Null terminates the buffer. }}\par
{
Definition at line 66 of file JsonParserGeneratorRK.cpp.}\par
{
References buffer, bufferLen, and offset.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    66                                \{\par
   67     if (buffer) \{\par
   68         if (offset < bufferLen) \{\par
   69             buffer[offset] = 0;\par
   70         \}\par
   71         else \{\par
   72             buffer[bufferLen - 1] = 0;\par
   73         \}\par
   74     \}\par
   75 \}\par
}
}
{\xe \v setBuffer\:JsonBuffer}
{\xe \v JsonBuffer\:setBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonBuffer::setBuffer (char *  {\i buffer}, size_t  {\i bufferLen})}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the buffers to the specified buffer and length. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buffer} \cell }{Pointer to the buffer\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bufferLen} \cell }{The length of the buffer\cell }
{\row }
}
This buffer will not be deleted when the object is destructed. \par
}{
Definition at line 19 of file JsonParserGeneratorRK.cpp.}\par
{
References buffer, bufferLen, and staticBuffers.}\par
{
Referenced by JsonModifier::startAppend(), and JsonModifier::startModify().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    19                                                          \{\par
   20     this->buffer = buffer;\par
   21     this->bufferLen = bufferLen;\par
   22     this->staticBuffers = true;\par
   23 \}\par
}
}
{\xe \v setOffset\:JsonBuffer}
{\xe \v JsonBuffer\:setOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonBuffer::setOffset (size_t  {\i offset}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
swets the current offset for writing }}\par
{
Definition at line 223 of file JsonParserGeneratorRK.h.}\par
{
References offset.}\par
{
Referenced by JsonModifier::finish(), JsonModifier::removeArrayIndex(), and JsonModifier::removeKeyValue().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   223 \{ this->offset = offset; \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v buffer\:JsonBuffer}
{\xe \v JsonBuffer\:buffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* JsonBuffer::buffer{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The buffer to to read from or write to. This is not null-terminated. }}\par
{
Definition at line 246 of file JsonParserGeneratorRK.h.}\par
{
Referenced by addData(), allocate(), JsonParser::allocateTokens(), JsonParser::copyTokenValue(), JsonWriter::finishObjectOrArray(), getBuffer(), JsonParser::getTokenJsonString(), JsonParser::getTokenValue(), JsonWriter::insertChar(), JsonWriter::insertvsprintf(), JsonBuffer(), nullTerminate(), JsonParser::parse(), setBuffer(), and ~JsonBuffer().}\par
}
{\xe \v bufferLen\:JsonBuffer}
{\xe \v JsonBuffer\:bufferLen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t JsonBuffer::bufferLen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The length of the buffer in bytes,. }}\par
{
Definition at line 247 of file JsonParserGeneratorRK.h.}\par
{
Referenced by addData(), allocate(), JsonWriter::finishObjectOrArray(), getBufferLen(), JsonWriter::insertChar(), JsonWriter::insertString(), JsonWriter::insertvsprintf(), JsonBuffer(), nullTerminate(), and setBuffer().}\par
}
{\xe \v offset\:JsonBuffer}
{\xe \v JsonBuffer\:offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t JsonBuffer::offset{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The read or write offset. }}\par
{
Definition at line 248 of file JsonParserGeneratorRK.h.}\par
{
Referenced by addData(), clear(), JsonWriter::finishObjectOrArray(), getOffset(), JsonWriter::init(), JsonWriter::insertChar(), JsonWriter::insertString(), JsonWriter::insertvsprintf(), JsonBuffer(), nullTerminate(), JsonParser::parse(), and setOffset().}\par
}
{\xe \v staticBuffers\:JsonBuffer}
{\xe \v JsonBuffer\:staticBuffers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonBuffer::staticBuffers{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
True if the buffers were passed in and should not freed or reallocated. }}\par
{
Definition at line 249 of file JsonParserGeneratorRK.h.}\par
{
Referenced by allocate(), JsonParser::allocateTokens(), JsonBuffer(), JsonParser::parse(), setBuffer(), ~JsonBuffer(), and JsonParser::~JsonParser().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/src/{\b JsonParserGeneratorRK.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/src/{\b JsonParserGeneratorRK.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
JsonModifier Class Reference\par \pard\plain 
{\tc\tcl2 \v JsonModifier}
{\xe \v JsonModifier}
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for modifying a JSON object in place, without needing to make a copy of it. }}\par
{
{\f2 #include <JsonParserGeneratorRK.h>}}\par
Inheritance diagram for JsonModifier:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_json_modifier__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for JsonModifier:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_json_modifier__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonModifier} ({\b JsonParser} &{\b jp})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~JsonModifier} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class T > void {\b insertOrUpdateKeyValue} (const {\b JsonParserGeneratorRK::jsmntok_t} *container, const char *key, T value)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts or updates a key/value pair into an object. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class T > void {\b appendArrayValue} (const {\b JsonParserGeneratorRK::jsmntok_t} *arrayToken, T value)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Appends a value to an array. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeKeyValue} (const {\b JsonParserGeneratorRK::jsmntok_t} *container, const char *key)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes a key and value from an object. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeArrayIndex} (const {\b JsonParserGeneratorRK::jsmntok_t} *container, size_t index)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes an entry from an array. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b startModify} (const {\b JsonParserGeneratorRK::jsmntok_t} *token)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Low level function to modify a token in place. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b startAppend} (const {\b JsonParserGeneratorRK::jsmntok_t} *arrayOrObjectToken)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Low level function to append to an object or array. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b finish} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finish modifying the object. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonParserGeneratorRK::jsmntok_t} {\b tokenWithQuotes} (const {\b JsonParserGeneratorRK::jsmntok_t} *tok) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a copy of tok, but moving so start and end include the double quotes for strings. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b findLeftComma} (const {\b JsonParserGeneratorRK::jsmntok_t} *tok) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Find the offset of the comma to the left of the token, or -1 if there isn't one. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b findRightComma} (const {\b JsonParserGeneratorRK::jsmntok_t} *tok) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Find the offset of the comma to the left of the token, or -1 if there isn't one. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonParser} & {\b jp}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b JsonParser} object passed to the constructor. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b start} = -1\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start offset in the buffer. Set to -1 when {\b startModify()} or {\b startAppend()} is not in progress. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b origAfter} = 0\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of bytes after the insertion position, saved at saveLoc when start is in progress. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b saveLoc} = 0\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Location where data is temporarily saved until {\b finish()} is called. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for modifying a JSON object in place, without needing to make a copy of it. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Make sure the underlying {\b JsonParser} is big enough to hold the modified object. If you use JsonParserStatic<> make sure you have enough bytes and tokens.\par
The most commonly used method is {\b insertOrUpdateKeyValue()}. This inserts or updates a key in an array. Another is {\b appendArrayValue()} which appends a value to an array. Both methods are templated so you can use them with any valid type supported by {\b insertValue()} in {\b JsonWriter}: bool, int, float, double, const char *.\par
This class is a subclass of {\b JsonWriter}, so you can also use the low-level functions and {\b JsonWriter} methods to do unusual object manipulations.\par
You can also use {\b removeKeyValue()} and {\b removeArrayIndex()} to remove keys or array entries. \par
}{
Definition at line 1323 of file JsonParserGeneratorRK.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v JsonModifier\:JsonModifier}
{\xe \v JsonModifier\:JsonModifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
JsonModifier::JsonModifier ({\b JsonParser} &  {\i jp})}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 881 of file JsonParserGeneratorRK.cpp.}\par
{
References jp.}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   881                                          : jp(jp) \{\par
  882 \par
  883 \}\par
}
}
{\xe \v ~JsonModifier\:JsonModifier}
{\xe \v JsonModifier\:~JsonModifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
JsonModifier::~JsonModifier (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 885 of file JsonParserGeneratorRK.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   885                             \{\par
  886 \par
  887 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v appendArrayValue\:JsonModifier}
{\xe \v JsonModifier\:appendArrayValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void JsonModifier::appendArrayValue (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i arrayToken}, T  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Appends a value to an array. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Uses templates so you can pass any type object that's supported by {\b insertValue()} overloads, for example: bool, int, float, double, const char *.\par
To modify the outermost array, use jp.getOuterArray() for the arrayToken. You can also modify arrays in an object using getValueTokenByKey().\par
Note: This method call jp.parse() so any jsmntok_t may be changed by this method. If you've fetched one, such as by using getValueTokenByKey() be sure to fetch it again to be safe. \par
}{
Definition at line 1363 of file JsonParserGeneratorRK.h.}\par
{
References finish(), and startAppend().}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1363                                                                                      \{\par
 1364         startAppend(arrayToken);\par
 1365         insertArrayValue(value);\par
 1366         finish();\par
 1367     \}\par
}
}
{\xe \v findLeftComma\:JsonModifier}
{\xe \v JsonModifier\:findLeftComma}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int JsonModifier::findLeftComma (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i tok}) const}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Find the offset of the comma to the left of the token, or -1 if there isn't one. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally, you probably won't need to use this. \par
}{
Definition at line 1058 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonBuffer::getBuffer(), jp, JsonParserGeneratorRK::jsmntok_t::start, and tokenWithQuotes().}\par
{
Referenced by main(), removeArrayIndex(), and removeKeyValue().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1058                                                                                \{\par
 1059 \par
 1060     JsonParserGeneratorRK::jsmntok_t expandedToken = tokenWithQuotes(tok);\par
 1061 \par
 1062     int ii = expandedToken.start - 1;\par
 1063     while(ii >= 0 && jp.getBuffer()[ii] == ' ') \{\par
 1064         // Whitespace\par
 1065         ii--;\par
 1066     \}\par
 1067     // printf("after whitespace check ii=%d c=%c\\n", ii, jp.getBuffer()[ii]);\par
 1068 \par
 1069     if (ii < 0 || jp.getBuffer()[ii] != ',') \{\par
 1070         return -1;\par
 1071     \}\par
 1072 \par
 1073 \par
 1074     return ii;\par
 1075 \}\par
}
}
{\xe \v findRightComma\:JsonModifier}
{\xe \v JsonModifier\:findRightComma}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int JsonModifier::findRightComma (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i tok}) const}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Find the offset of the comma to the left of the token, or -1 if there isn't one. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally, you probably won't need to use this. \par
}{
Definition at line 1077 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParserGeneratorRK::jsmntok_t::end, JsonBuffer::getBuffer(), JsonBuffer::getOffset(), jp, and tokenWithQuotes().}\par
{
Referenced by main(), removeArrayIndex(), and removeKeyValue().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1077                                                                                 \{\par
 1078     JsonParserGeneratorRK::jsmntok_t expandedToken = tokenWithQuotes(tok);\par
 1079 \par
 1080     int ii = expandedToken.end;\par
 1081     while(ii < jp.getOffset() && jp.getBuffer()[ii] == ' ') \{\par
 1082         // Whitespace\par
 1083         ii++;\par
 1084     \}\par
 1085 \par
 1086     if (ii < 0 || jp.getBuffer()[ii] != ',') \{\par
 1087         return -1;\par
 1088     \}\par
 1089 \par
 1090     return ii;\par
 1091 \}\par
}
}
{\xe \v finish\:JsonModifier}
{\xe \v JsonModifier\:finish}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonModifier::finish ()}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finish modifying the object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finish must be called after startModify or startAppend otherwise the object will be corrupted.\par
Note: This method call jp.parse() so any jsmntok_t may be changed by this method. If you've fetched one, such as by using getValueTokenByKey() be sure to fetch it again to be safe.\par
The high level function like insertOrUpdateKeyValue, appendArrayValue, removeKeyValue, and removeArrayIndex internally call finish so you should not call it again with those methods. \par
}{
Definition at line 1033 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonBuffer::getBuffer(), JsonBuffer::getOffset(), jp, origAfter, JsonParser::parse(), saveLoc, JsonBuffer::setOffset(), and start.}\par
{
Referenced by appendArrayValue(), insertOrUpdateKeyValue(), and main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1033                           \{\par
 1034     if (start == -1) \{\par
 1035         return;\par
 1036     \}\par
 1037     //printf("finishing offset=%d\\n", getOffset());\par
 1038 \par
 1039     if (origAfter > 0) \{\par
 1040         memmove(jp.getBuffer() + start + getOffset(), jp.getBuffer() + saveLoc, origAfter);\par
 1041     \}\par
 1042     jp.setOffset(start + getOffset() + origAfter);\par
 1043     jp.parse();\par
 1044     start = -1;\par
 1045 \}\par
}
}
{\xe \v insertOrUpdateKeyValue\:JsonModifier}
{\xe \v JsonModifier\:insertOrUpdateKeyValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void JsonModifier::insertOrUpdateKeyValue (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i container}, const char *  {\i key}, T  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts or updates a key/value pair into an object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Uses templates so you can pass any type object that's supported by {\b insertValue()} overloads, for example: bool, int, float, double, const char *.\par
To modify the outermost object, use jp.getOuterObject() for the container.\par
Note: This method call jp.parse() so any jsmntok_t may be changed by this method. If you've fetched one, such as by using getValueTokenByKey() be sure to fetch it again to be safe. \par
}{
Definition at line 1340 of file JsonParserGeneratorRK.h.}\par
{
References finish(), removeKeyValue(), and startAppend().}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1340                                                                                                            \{\par
 1341         // Remove existing item (ignore failure, as the key might not exist)\par
 1342         removeKeyValue(container, key);\par
 1343 \par
 1344         // Create a new key/value pair\par
 1345         startAppend(container);\par
 1346         insertKeyValue(key, value);\par
 1347         finish();\par
 1348     \}\par
}
}
{\xe \v removeArrayIndex\:JsonModifier}
{\xe \v JsonModifier\:removeArrayIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonModifier::removeArrayIndex (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i container}, size_t  {\i index})}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes an entry from an array. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Note: This method call jp.parse() so any jsmntok_t may be changed by this method. If you've fetched one, such as by using getValueTokenByKey() be sure to fetch it again to be safe. \par
}{
Definition at line 944 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParserGeneratorRK::jsmntok_t::end, findLeftComma(), findRightComma(), JsonBuffer::getBuffer(), JsonBuffer::getOffset(), JsonParser::getTokenByIndex(), jp, origAfter, JsonParser::parse(), JsonBuffer::setOffset(), JsonParserGeneratorRK::jsmntok_t::start, and tokenWithQuotes().}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   944                                                                                                  \{\par
  945 \par
  946     const JsonParserGeneratorRK::jsmntok_t *tok = jp.getTokenByIndex(container, index);\par
  947     if (!tok) \{\par
  948         return false;\par
  949     \}\par
  950 \par
  951     const JsonParserGeneratorRK::jsmntok_t expandedToken = tokenWithQuotes(tok);\par
  952 \par
  953     int left = findLeftComma(tok);\par
  954     int right = findRightComma(tok);\par
  955 \par
  956     if (left >= 0 && right >= 0) \{\par
  957         // Commas on both sides, just remove the one on the right\par
  958         left = expandedToken.start;\par
  959     \}\par
  960     else\par
  961     if (left >= 0) \{\par
  962         // Only comma on left, removing the last item so remove the comma\par
  963         right = expandedToken.end;\par
  964     \}\par
  965     else\par
  966     if (right >= 0) \{\par
  967         // Only comma on the right, removing the first item so remove the comma\par
  968         right++;\par
  969         left = expandedToken.start;\par
  970     \}\par
  971     else \{\par
  972         // Single item, leaving array empty afterwards (both < 0), no commads\par
  973         left = expandedToken.start;\par
  974         right = expandedToken.end;\par
  975     \}\par
  976 \par
  977     origAfter = jp.getOffset() - right;\par
  978 \par
  979     if (origAfter > 0) \{\par
  980         memmove(jp.getBuffer() + left, jp.getBuffer() + right, origAfter);\par
  981     \}\par
  982 \par
  983     jp.setOffset(left + origAfter);\par
  984     jp.parse();\par
  985 \par
  986     return true;\par
  987 \}\par
}
}
{\xe \v removeKeyValue\:JsonModifier}
{\xe \v JsonModifier\:removeKeyValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonModifier::removeKeyValue (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i container}, const char *  {\i key})}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes a key and value from an object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Note: This method call jp.parse() so any jsmntok_t may be changed by this method. If you've fetched one, such as by using getValueTokenByKey() be sure to fetch it again to be safe. \par
}{
Definition at line 890 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParserGeneratorRK::jsmntok_t::end, findLeftComma(), findRightComma(), JsonBuffer::getBuffer(), JsonBuffer::getOffset(), JsonParser::getValueTokenByKey(), jp, origAfter, JsonParser::parse(), JsonBuffer::setOffset(), JsonParserGeneratorRK::jsmntok_t::start, and tokenWithQuotes().}\par
{
Referenced by insertOrUpdateKeyValue(), and main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   890                                                                                                   \{\par
  891 \par
  892 \par
  893     const JsonParserGeneratorRK::jsmntok_t *keyToken, *valueToken;\par
  894 \par
  895     bool bResult = jp.getValueTokenByKey(container, key, valueToken);\par
  896     if (!bResult) \{\par
  897         return false;\par
  898     \}\par
  899 \par
  900     // The key token always proceeds the value token\par
  901     keyToken = &valueToken[-1];\par
  902 \par
  903     // Include the double quotes\par
  904     const JsonParserGeneratorRK::jsmntok_t expandedKeyToken = tokenWithQuotes(keyToken);\par
  905     const JsonParserGeneratorRK::jsmntok_t expandedValueToken = tokenWithQuotes(valueToken);\par
  906 \par
  907     int left = findLeftComma(keyToken);\par
  908     int right = findRightComma(valueToken);\par
  909 \par
  910     if (left >= 0 && right >= 0) \{\par
  911         // Commas on both sides, just remove the one on the right\par
  912         left = expandedKeyToken.start;\par
  913         right++;\par
  914     \}\par
  915     else\par
  916     if (left >= 0) \{\par
  917         // Only comma on left, removing the last item so remove the comma\par
  918         right = expandedValueToken.end;\par
  919     \}\par
  920     else\par
  921     if (right >= 0) \{\par
  922         // Only comma on the right, removing the first item so remove the comma\par
  923         right++;\par
  924         left = expandedKeyToken.start;\par
  925     \}\par
  926     else \{\par
  927         // Single item, leaving array empty afterwards (both < 0), no commads\par
  928         left = expandedKeyToken.start;\par
  929         right = expandedValueToken.end;\par
  930     \}\par
  931 \par
  932     origAfter = jp.getOffset() - right;\par
  933 \par
  934     if (origAfter > 0) \{\par
  935         memmove(jp.getBuffer() + left, jp.getBuffer() + right, origAfter);\par
  936     \}\par
  937 \par
  938     jp.setOffset(left + origAfter);\par
  939     jp.parse();\par
  940 \par
  941     return true;\par
  942 \}\par
}
}
{\xe \v startAppend\:JsonModifier}
{\xe \v JsonModifier\:startAppend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonModifier::startAppend (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i arrayOrObjectToken})}}
\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Low level function to append to an object or array. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i arrayOrObjectToken} \cell }{the jsmntok_t to append to. This must be an object or array token.\cell }
{\row }
}
You must call {\b finish()} after modification is done to restore the object to a valid state. \par
}{
Definition at line 1009 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParserGeneratorRK::jsmntok_t::end, JsonBuffer::getBuffer(), JsonBuffer::getBufferLen(), JsonBuffer::getOffset(), JsonWriter::init(), jp, origAfter, saveLoc, JsonBuffer::setBuffer(), JsonWriter::setIsFirst(), JsonParserGeneratorRK::jsmntok_t::size, and start.}\par
{
Referenced by appendArrayValue(), insertOrUpdateKeyValue(), and main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1009                                                                                        \{\par
 1010     if (start != -1) \{\par
 1011         // Modification or insertion already in progress\par
 1012         return false;\par
 1013     \}\par
 1014 \par
 1015     start = arrayOrObjectToken->end - 1; // Before the closing ] or \}\par
 1016     origAfter = jp.getOffset() - start;\par
 1017     saveLoc = jp.getBufferLen() - origAfter;\par
 1018 \par
 1019     if (origAfter > 0) \{\par
 1020         memmove(jp.getBuffer() + saveLoc, jp.getBuffer() + start, origAfter);\par
 1021     \}\par
 1022 \par
 1023     setBuffer(jp.getBuffer() + start, saveLoc - start);\par
 1024     init();\par
 1025 \par
 1026     // If array is not empty, add a separator\par
 1027     setIsFirst(arrayOrObjectToken->size == 0);\par
 1028 \par
 1029     return true;\par
 1030 \}\par
}
}
{\xe \v startModify\:JsonModifier}
{\xe \v JsonModifier\:startModify}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonModifier::startModify (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i token})}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Low level function to modify a token in place. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i token} \cell }{the jsmntok_t to modify\cell }
{\row }
}
You must call {\b finish()} after modification is done to restore the object to a valid state!\par
Note: {\b insertOrUpdateKeyValue()} does not use this. Instead it removes then appends the new value. The reason is that startModify does not work if you change the type of the data to or from a string. This is tricky to deal with correctly, so it's easier to just remove and add the item again. \par
}{
Definition at line 988 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParserGeneratorRK::jsmntok_t::end, JsonBuffer::getBuffer(), JsonBuffer::getBufferLen(), JsonBuffer::getOffset(), JsonWriter::init(), jp, origAfter, saveLoc, JsonBuffer::setBuffer(), JsonParserGeneratorRK::jsmntok_t::start, and start.}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   988                                                                           \{\par
  989     if (start != -1) \{\par
  990         // Modification or insertion already in progress\par
  991         return false;\par
  992     \}\par
  993     start = token->start;\par
  994     origAfter = jp.getOffset() - token->end;\par
  995     saveLoc = jp.getBufferLen() - origAfter;\par
  996 \par
  997     //printf("start=%d origAfter=%d saveLoc=%d bufferSize=%d\\n", start, origAfter, saveLoc, saveLoc - start);\par
  998 \par
  999     if (origAfter > 0) \{\par
 1000         memmove(jp.getBuffer() + saveLoc, jp.getBuffer() + token->end, origAfter);\par
 1001     \}\par
 1002 \par
 1003     setBuffer(jp.getBuffer() + start, saveLoc - start);\par
 1004     init();\par
 1005 \par
 1006     return true;\par
 1007 \}\par
}
}
{\xe \v tokenWithQuotes\:JsonModifier}
{\xe \v JsonModifier\:tokenWithQuotes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b JsonParserGeneratorRK::jsmntok_t} JsonModifier::tokenWithQuotes (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i tok}) const}}
\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return a copy of tok, but moving so start and end include the double quotes for strings. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally, you probably won't need to use this. \par
}{
Definition at line 1048 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParserGeneratorRK::jsmntok_t::end, JsonParserGeneratorRK::JSMN_STRING, JsonParserGeneratorRK::jsmntok_t::start, and JsonParserGeneratorRK::jsmntok_t::type.}\par
{
Referenced by findLeftComma(), findRightComma(), removeArrayIndex(), and removeKeyValue().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1048                                                                                                             \{\par
 1049     JsonParserGeneratorRK::jsmntok_t expandedToken = *tok;\par
 1050 \par
 1051     if (tok->type == JsonParserGeneratorRK::JSMN_STRING) \{\par
 1052         expandedToken.start--;\par
 1053         expandedToken.end++;\par
 1054     \}\par
 1055     return expandedToken;\par
 1056 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v jp\:JsonModifier}
{\xe \v JsonModifier\:jp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b JsonParser}& JsonModifier::jp{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b JsonParser} object passed to the constructor. }}\par
{
Definition at line 1447 of file JsonParserGeneratorRK.h.}\par
{
Referenced by findLeftComma(), findRightComma(), finish(), JsonModifier(), removeArrayIndex(), removeKeyValue(), startAppend(), and startModify().}\par
}
{\xe \v origAfter\:JsonModifier}
{\xe \v JsonModifier\:origAfter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int JsonModifier::origAfter = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of bytes after the insertion position, saved at saveLoc when start is in progress. }}\par
{
Definition at line 1449 of file JsonParserGeneratorRK.h.}\par
{
Referenced by finish(), removeArrayIndex(), removeKeyValue(), startAppend(), and startModify().}\par
}
{\xe \v saveLoc\:JsonModifier}
{\xe \v JsonModifier\:saveLoc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int JsonModifier::saveLoc = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Location where data is temporarily saved until {\b finish()} is called. }}\par
{
Definition at line 1450 of file JsonParserGeneratorRK.h.}\par
{
Referenced by finish(), startAppend(), and startModify().}\par
}
{\xe \v start\:JsonModifier}
{\xe \v JsonModifier\:start}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int JsonModifier::start = -1{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start offset in the buffer. Set to -1 when {\b startModify()} or {\b startAppend()} is not in progress. }}\par
{
Definition at line 1448 of file JsonParserGeneratorRK.h.}\par
{
Referenced by finish(), startAppend(), and startModify().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/src/{\b JsonParserGeneratorRK.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/src/{\b JsonParserGeneratorRK.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
JsonParser Class Reference\par \pard\plain 
{\tc\tcl2 \v JsonParser}
{\xe \v JsonParser}
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
API to the {\b JsonParser}. }}\par
{
{\f2 #include <JsonParserGeneratorRK.h>}}\par
Inheritance diagram for JsonParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_json_parser__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for JsonParser:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_json_parser__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonParser} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a parser object. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~JsonParser} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroy a parser object. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonParser} (char *{\b buffer}, size_t {\b bufferLen}, {\b JsonParserGeneratorRK::jsmntok_t} *{\b tokens}, size_t {\b maxTokens})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Static buffers constructor. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b allocateTokens} (size_t {\b maxTokens})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Preallocates a specific number of tokens. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b parse} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parses the data you have added using {\b addData()} or {\b addString()}. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonReference} {\b getReference} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a {\b JsonReference} object. This is used for fluent-style access to the data. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b JsonParserGeneratorRK::jsmntok_t} * {\b getOuterObject} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the outer JSON object token. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b JsonParserGeneratorRK::jsmntok_t} * {\b getOuterArray} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the outer JSON array token. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b JsonParserGeneratorRK::jsmntok_t} * {\b getOuterToken} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the outer JSON object or array token. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b getArraySize} (const {\b JsonParserGeneratorRK::jsmntok_t} *arrayContainer) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a token for an JSON array in arrayContainer, gets the number of elements in the array. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class T > bool {\b getValueByKey} (const {\b JsonParserGeneratorRK::jsmntok_t} *container, const char *name, T &result) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given an object token in container, gets the value with the specified key name. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class T > bool {\b getOuterValueByKey} (const char *name, T &result) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the value with the specified key name out of the outer object. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class T > bool {\b getKeyValueByIndex} (const {\b JsonParserGeneratorRK::jsmntok_t} *container, size_t index, {\b String} &key, T &result) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the key/value pair of an object by index. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class T > bool {\b getOuterKeyValueByIndex} (size_t index, {\b String} &key, T &result) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the key/value pair of the outer object by index (0 = first, 1 = second, ...) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class T > bool {\b getValueByIndex} (const {\b JsonParserGeneratorRK::jsmntok_t} *arrayContainer, size_t index, T &result) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given an array token in arrayContainer, gets the value with the specified index. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class T > bool {\b getValueByColRow} (const {\b JsonParserGeneratorRK::jsmntok_t} *arrayContainer, size_t col, size_t row, T &result) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method is used to extract data from a 2-dimensional JSON array, an array of arrays of values. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getValueTokenByKey} (const {\b JsonParserGeneratorRK::jsmntok_t} *container, const char *key, const {\b JsonParserGeneratorRK::jsmntok_t} *&value) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given an object token in container, gets the token value with the specified key name. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getValueTokenByIndex} (const {\b JsonParserGeneratorRK::jsmntok_t} *container, size_t desiredIndex, const {\b JsonParserGeneratorRK::jsmntok_t} *&value) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given an array token in container, gets the token value with the specified index. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getValueTokenByColRow} (const {\b JsonParserGeneratorRK::jsmntok_t} *container, size_t col, size_t row, const {\b JsonParserGeneratorRK::jsmntok_t} *&value) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method is used to extract data from a 2-dimensional JSON array, an array of arrays of values. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b JsonParserGeneratorRK::jsmntok_t} * {\b getTokenByIndex} (const {\b JsonParserGeneratorRK::jsmntok_t} *container, size_t desiredIndex) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a containing object, finds the nth token in the object. Internal use only. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getKeyValueTokenByIndex} (const {\b JsonParserGeneratorRK::jsmntok_t} *container, const {\b JsonParserGeneratorRK::jsmntok_t} *&key, const {\b JsonParserGeneratorRK::jsmntok_t} *&value, size_t index) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a JSON object in container, gets the key/value pair specified by index. Internal use only. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b skipObject} (const {\b JsonParserGeneratorRK::jsmntok_t} *container, const {\b JsonParserGeneratorRK::jsmntok_t} *&obj) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally to skip over the token in obj. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b copyTokenValue} (const {\b JsonParserGeneratorRK::jsmntok_t} *token, char *dst, size_t dstLen) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copies the value of the token into a buffer, making it a null-terminated cstring. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getTokenValue} (const {\b JsonParserGeneratorRK::jsmntok_t} *token, bool &result) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a bool (boolean) value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getTokenValue} (const {\b JsonParserGeneratorRK::jsmntok_t} *token, int &result) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets an integer value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getTokenValue} (const {\b JsonParserGeneratorRK::jsmntok_t} *token, unsigned long &result) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets an unsigned long value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getTokenValue} (const {\b JsonParserGeneratorRK::jsmntok_t} *token, float &result) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a float (single precision floating point) value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getTokenValue} (const {\b JsonParserGeneratorRK::jsmntok_t} *token, double &result) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a double (double precision floating point) value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getTokenValue} (const {\b JsonParserGeneratorRK::jsmntok_t} *token, {\b String} &result) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a {\b String} value into a Wiring {\b String} object. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getTokenValue} (const {\b JsonParserGeneratorRK::jsmntok_t} *token, char *str, size_t &strLen) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a string as a c-string into the specified buffer. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getTokenValue} (const {\b JsonParserGeneratorRK::jsmntok_t} *token, {\b JsonParserString} &str) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a string as a {\b JsonParserString} object. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getTokenJsonString} (const {\b JsonParserGeneratorRK::jsmntok_t} *token, {\b String} &result) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts a token (object, array, string, or primitive) back into JSON in a Wiring {\b String}. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getTokenJsonString} (const {\b JsonParserGeneratorRK::jsmntok_t} *token, char *str, size_t &strLen) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts a token (object, array, string, or primitive) back into JSON in a buffer. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getTokenJsonString} (const {\b JsonParserGeneratorRK::jsmntok_t} *token, {\b JsonParserString} &str) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a token as a JSON string. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonParserGeneratorRK::jsmntok_t} * {\b getTokens} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally in the test suite for printing the token list. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonParserGeneratorRK::jsmntok_t} * {\b getTokensEnd} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally in the test suite for printing the token list. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b getMaxTokens} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally in the test suite for printing the token list. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b appendUtf8} (uint16_t unicode, {\b JsonParserString} &str)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a Unicode UTF-16 code point, converts it to UTF-8 and appends it to str. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonParserGeneratorRK::jsmntok_t} * {\b tokens}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Array of tokens after parsing. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonParserGeneratorRK::jsmntok_t} * {\b tokensEnd}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer into tokens, points after last used token. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b maxTokens}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of tokens that can be stored in tokens. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonParserGeneratorRK::jsmn_parser} {\b parser}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The JSMN parser object. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b JsonModifier}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
API to the {\b JsonParser}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a memory-efficient JSON parser based on jsmn. It only keeps one copy of the data in raw format and an array of tokens. You make calls to read values out. \par
}{
Definition at line 262 of file JsonParserGeneratorRK.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v JsonParser\:JsonParser}
{\xe \v JsonParser\:JsonParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
JsonParser::JsonParser ()}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a parser object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This version dynamically allocates the buffer and token storage. If you want to minimize memory allocations you can pass in a static buffer and array of tokens to use instead. \par
}{
Definition at line 80 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonBuffer::JsonBuffer(), maxTokens, tokens, and tokensEnd.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    80                        : JsonBuffer(), tokens(0), tokensEnd(0), maxTokens(0) \{\par
   81 \}\par
}
}
{\xe \v ~JsonParser\:JsonParser}
{\xe \v JsonParser\:~JsonParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
JsonParser::~JsonParser (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroy a parser object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the buffer was allocated dynamically it will be deleted. If you passed in a static buffer the static buffer is not deleted. \par
}{
Definition at line 89 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonBuffer::staticBuffers, and tokens.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    89                         \{\par
   90     if (!staticBuffers && tokens) \{\par
   91         free(tokens);\par
   92     \}\par
   93 \}\par
}
}
{\xe \v JsonParser\:JsonParser}
{\xe \v JsonParser\:JsonParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
JsonParser::JsonParser (char *  {\i buffer}, size_t  {\i bufferLen}, {\b JsonParserGeneratorRK::jsmntok_t} *  {\i tokens}, size_t  {\i maxTokens})}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Static buffers constructor. }}\par
{
Definition at line 83 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonBuffer::JsonBuffer(), maxTokens, and tokens.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    83                                                                                                                :\par
   84         JsonBuffer(buffer, bufferLen), tokens(tokens), maxTokens(maxTokens) \{\par
   85 \par
   86 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v allocateTokens\:JsonParser}
{\xe \v JsonParser\:allocateTokens}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonParser::allocateTokens (size_t  {\i maxTokens})}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Preallocates a specific number of tokens. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Optional: You should set this larger than the expected number of tokens for efficiency, but if you are not using the static allocator it will resize the token storage space if it's too small. \par
}{
Definition at line 95 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonBuffer::buffer, maxTokens, JsonBuffer::staticBuffers, and tokens.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    95                                                 \{\par
   96     if (!staticBuffers) \{\par
   97         JsonParserGeneratorRK::jsmntok_t *newTokens;\par
   98         if (tokens) \{\par
   99             newTokens = (JsonParserGeneratorRK::jsmntok_t *)realloc(buffer, sizeof(JsonParserGeneratorRK::jsmntok_t) * maxTokens);\par
  100         \}\par
  101         else \{\par
  102             newTokens = (JsonParserGeneratorRK::jsmntok_t *)malloc(sizeof(JsonParserGeneratorRK::jsmntok_t) * maxTokens);\par
  103         \}\par
  104         if (newTokens) \{\par
  105             tokens = newTokens;\par
  106             this->maxTokens = maxTokens;\par
  107             return true;\par
  108         \}\par
  109         else \{\par
  110             return false;\par
  111         \}\par
  112     \}\par
  113     else \{\par
  114         return false;\par
  115     \}\par
  116 \}\par
}
}
{\xe \v appendUtf8\:JsonParser}
{\xe \v JsonParser\:appendUtf8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonParser::appendUtf8 (uint16_t  {\i unicode}, {\b JsonParserString} &  {\i str}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a Unicode UTF-16 code point, converts it to UTF-8 and appends it to str. }}\par
{
Definition at line 509 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParserString::append().}\par
{
Referenced by getTokenValue().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   509                                                                    \{\par
  510 \par
  511     unsigned char value;\par
  512 \par
  513     if (unicode <= 0x007f) \{\par
  514         // 0x00000000 - 0x0000007F:\par
  515         str.append((char)unicode);\par
  516     \}\par
  517     else\par
  518     if (unicode <= 0x7ff) \{\par
  519         // 0x00000080 - 0x000007FF:\par
  520         // 110xxxxx 10xxxxxx\par
  521 \par
  522         value = (0b11000000 | ((unicode >> 6) & 0b11111));\par
  523         str.append((char)value);\par
  524 \par
  525         value = (0b10000000 | (unicode & 0b111111));\par
  526         str.append((char)value);\par
  527     \}\par
  528     else \{\par
  529         // 0x00000800 - 0x0000FFFF:\par
  530         // 1110xxxx 10xxxxxx 10xxxxxx\par
  531         value = 0b11100000 | ((unicode >> 12) & 0b1111);\par
  532         str.append((char)value);\par
  533 \par
  534         value = 0b10000000 | ((unicode >> 6) & 0b111111);\par
  535         str.append((char)value);\par
  536 \par
  537         value = 0b10000000 | (unicode & 0b111111);\par
  538         str.append((char)value);\par
  539     \}\par
  540 \}\par
}
}
{\xe \v copyTokenValue\:JsonParser}
{\xe \v JsonParser\:copyTokenValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonParser::copyTokenValue (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i token}, char *  {\i dst}, size_t  {\i dstLen}) const}}
\par
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copies the value of the token into a buffer, making it a null-terminated cstring. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the string is longer than dstLen - 1 bytes, it will be truncated and the result will still be a valid cstring.\par
This is used internally because the token data is not null-terminated, and doing things like sscanf or strtoul on it can read past the end of the buffer. This assures that only null-terminated data is passed to these functions. \par
}{
Definition at line 327 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonBuffer::buffer, JsonParserGeneratorRK::jsmntok_t::end, and JsonParserGeneratorRK::jsmntok_t::start.}\par
{
Referenced by getTokenValue().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   327                                                                                                            \{\par
  328 \par
  329     int ii;\par
  330     for(ii = 0; ii < (token->end - token->start) && ii < ((int)dstLen - 1); ii++) \{\par
  331         dst[ii] = buffer[token->start + ii];\par
  332     \}\par
  333     dst[ii] = 0;\par
  334 \}\par
}
}
{\xe \v getArraySize\:JsonParser}
{\xe \v JsonParser\:getArraySize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t JsonParser::getArraySize (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i arrayContainer}) const}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a token for an JSON array in arrayContainer, gets the number of elements in the array. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
0 = no elements, 1 = one element, ...\par
The index values for {\b getValueByIndex()}, etc. are 0-based, so the last index you pass in is less than {\b getArraySize()}. \par
}{
Definition at line 315 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParserGeneratorRK::jsmntok_t::end, skipObject(), and tokensEnd.}\par
{
Referenced by main(), and JsonReference::size().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   315                                                                                           \{\par
  316     size_t index = 0;\par
  317     const JsonParserGeneratorRK::jsmntok_t *token = arrayContainer + 1;\par
  318 \par
  319     while(token < tokensEnd && token->end < arrayContainer->end) \{\par
  320         index++;\par
  321         skipObject(arrayContainer, token);\par
  322     \}\par
  323 \par
  324     return index;\par
  325 \}\par
}
}
{\xe \v getKeyValueByIndex\:JsonParser}
{\xe \v JsonParser\:getKeyValueByIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > bool JsonParser::getKeyValueByIndex (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i container}, size_t  {\i index}, {\b String} &  {\i key}, T &  {\i result}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the key/value pair of an object by index. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i container} \cell }{The object to look in (see getOuterKeyValueByIndex if you want to the outermost object you parsed)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{0 = first, 1 = second, ...\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i key} \cell }{Filled in with the name of the key\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i result} \cell }{Filled in with the value. The value can be of type: bool, int, unsigned long, float, double, {\b String}, or (char *, size_t&).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the call succeeded or false if it failed.\par
}Normally you get a value in an object by its key, but if you want to iterate all of the keys you can use this method. Call it until it returns false.\par
This should only be used for things like string, numbers, booleans, etc.. If you want to get a JSON array or object within an object, use {\b getValueTokenByKey()} instead. \par
}{
Definition at line 425 of file JsonParserGeneratorRK.h.}\par
{
References getKeyValueTokenByIndex(), and getTokenValue().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   425                                                                                                                          \{\par
  426         const JsonParserGeneratorRK::jsmntok_t *keyToken;\par
  427         const JsonParserGeneratorRK::jsmntok_t *valueToken;\par
  428 \par
  429         if (getKeyValueTokenByIndex(container, keyToken, valueToken, index)) \{\par
  430             getTokenValue(keyToken, key);\par
  431             return getTokenValue(valueToken, result);\par
  432         \}\par
  433         else \{\par
  434             return false;\par
  435         \}\par
  436     \}\par
}
}
{\xe \v getKeyValueTokenByIndex\:JsonParser}
{\xe \v JsonParser\:getKeyValueTokenByIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonParser::getKeyValueTokenByIndex (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i container}, const {\b JsonParserGeneratorRK::jsmntok_t} *&  {\i key}, const {\b JsonParserGeneratorRK::jsmntok_t} *&  {\i value}, size_t  {\i index}) const}}
\par
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a JSON object in container, gets the key/value pair specified by index. Internal use only. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i container} \cell }{The array token to look in.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i key} \cell }{Filled in with the key token for nth key value pair.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{Filled in with the value token for then nth key value pair.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{The index to retrieve (0 = first, 1 = second, ...).\cell }
{\row }
}
This is a low-level function; you will typically use {\b getValueByIndex()} or {\b getValueByKey()} instead. \par
}{
Definition at line 250 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParserGeneratorRK::jsmntok_t::end, skipObject(), and tokensEnd.}\par
{
Referenced by getKeyValueByIndex(), getValueTokenByKey(), main(), and printJsonInner().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   250                                                                                                                                                                                                              \{\par
  251 \par
  252     size_t index = 0;\par
  253     const JsonParserGeneratorRK::jsmntok_t *token = container + 1;\par
  254 \par
  255     while(token < tokensEnd && token->end < container->end) \{\par
  256         if (desiredIndex == index) \{\par
  257             key = token;\par
  258             if (skipObject(container, token)) \{\par
  259                 value = token;\par
  260                 return true;\par
  261             \}\par
  262         \}\par
  263         index++;\par
  264         skipObject(container, token);\par
  265         skipObject(container, token);\par
  266     \}\par
  267 \par
  268     return false;\par
  269 \}\par
}
}
{\xe \v getMaxTokens\:JsonParser}
{\xe \v JsonParser\:getMaxTokens}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t JsonParser::getMaxTokens () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally in the test suite for printing the token list. }}\par
{
Definition at line 743 of file JsonParserGeneratorRK.h.}\par
{
References maxTokens.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   743 \{ return maxTokens; \};\par
}
}
{\xe \v getOuterArray\:JsonParser}
{\xe \v JsonParser\:getOuterArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b JsonParserGeneratorRK::jsmntok_t} * JsonParser::getOuterArray () const}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the outer JSON array token. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sometimes the JSON will contain an array of values (or objects) instead of starting with an object. This gets the outermost array.\par
A token ({\b JsonParserGeneratorRK::jsmntok_t}) identifies a particular piece of data in the JSON data, such as an object, array, or element within an object or array, such as a string, integer, boolean, etc.. \par
}{
Definition at line 192 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParserGeneratorRK::JSMN_ARRAY, tokens, tokensEnd, and JsonParserGeneratorRK::jsmntok_t::type.}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   192                                                                       \{\par
  193     for(const JsonParserGeneratorRK::jsmntok_t *token = tokens; token < tokensEnd; token++) \{\par
  194         if (token->type == JsonParserGeneratorRK::JSMN_ARRAY) \{\par
  195             return token;\par
  196         \}\par
  197     \}\par
  198     return 0;\par
  199 \}\par
}
}
{\xe \v getOuterKeyValueByIndex\:JsonParser}
{\xe \v JsonParser\:getOuterKeyValueByIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > bool JsonParser::getOuterKeyValueByIndex (size_t  {\i index}, {\b String} &  {\i key}, T &  {\i result}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the key/value pair of the outer object by index (0 = first, 1 = second, ...) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Normally you get a value in an object by its key, but if you want to iterate all of the keys you can use this method.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{0 = first, 1 = second, ...\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i key} \cell }{Filled in with the name of the key\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i result} \cell }{Filled in with the value. The value can be of type: bool, int, unsigned long, float, double, {\b String}, or (char *, size_t&).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the call succeeded or false if it failed.\par
}This should only be used for things like string, numbers, booleans, etc.. If you want to get a JSON array or object within an object, use {\b getValueTokenByKey()} instead. \par
}{
Definition at line 457 of file JsonParserGeneratorRK.h.}\par
{
References getOuterObject().}\par
{
Referenced by runTest().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   457                                                                              \{\par
  458         return getKeyValueByIndex(getOuterObject(), index, key, result);\par
  459     \}\par
}
}
{\xe \v getOuterObject\:JsonParser}
{\xe \v JsonParser\:getOuterObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b JsonParserGeneratorRK::jsmntok_t} * JsonParser::getOuterObject () const}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the outer JSON object token. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Typically JSON will contain an object that contains values and possibly other objects. This method gets the token for the outer object.\par
A token ({\b JsonParserGeneratorRK::jsmntok_t}) identifies a particular piece of data in the JSON data, such as an object, array, or element within an object or array, such as a string, integer, boolean, etc.. \par
}{
Definition at line 218 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParserGeneratorRK::JSMN_OBJECT, tokens, tokensEnd, and JsonParserGeneratorRK::jsmntok_t::type.}\par
{
Referenced by getOuterKeyValueByIndex(), getOuterValueByKey(), and main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   218                                                                        \{\par
  219     if (tokens < tokensEnd && tokens[0].type == JsonParserGeneratorRK::JSMN_OBJECT) \{\par
  220         return &tokens[0];\par
  221     \}\par
  222     else \{\par
  223         return 0;\par
  224     \}\par
  225 \}\par
}
}
{\xe \v getOuterToken\:JsonParser}
{\xe \v JsonParser\:getOuterToken}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b JsonParserGeneratorRK::jsmntok_t} * JsonParser::getOuterToken () const}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the outer JSON object or array token. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A token ({\b JsonParserGeneratorRK::jsmntok_t}) identifies a particular piece of data in the JSON data, such as an object, array, or element within an object or array, such as a string, integer, boolean, etc.. \par
}{
Definition at line 227 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParserGeneratorRK::JSMN_ARRAY, JsonParserGeneratorRK::JSMN_OBJECT, tokens, tokensEnd, and JsonParserGeneratorRK::jsmntok_t::type.}\par
{
Referenced by main(), and printJson().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   227                                                                       \{\par
  228     for(const JsonParserGeneratorRK::jsmntok_t *token = tokens; token < tokensEnd; token++) \{\par
  229         if (token->type == JsonParserGeneratorRK::JSMN_OBJECT || token->type == JsonParserGeneratorRK::JSMN_ARRAY) \{\par
  230             return token;\par
  231         \}\par
  232     \}\par
  233     return 0;\par
  234 \}\par
}
}
{\xe \v getOuterValueByKey\:JsonParser}
{\xe \v JsonParser\:getOuterValueByKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > bool JsonParser::getOuterValueByKey (const char *  {\i name}, T &  {\i result}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the value with the specified key name out of the outer object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i name} \cell }{The name of the key to retrieve\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i result} \cell }{The returned data.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the data was retrieved successfully, false if not (key not present or incompatible data type).\par
}The outer object must be a JSON object, not an array.\par
This should only be used for things like string, numbers, booleans, etc.. If you want to get a JSON array or object within an object, use {\b getValueTokenByKey()} instead. \par
}{
Definition at line 393 of file JsonParserGeneratorRK.h.}\par
{
References getOuterObject(), and getValueTokenByKey().}\par
{
Referenced by main(), and runTest().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   393                                                                \{\par
  394         const JsonParserGeneratorRK::jsmntok_t *value;\par
  395 \par
  396         if (getValueTokenByKey(getOuterObject(), name, value)) \{\par
  397             return getTokenValue(value, result);\par
  398         \}\par
  399         else \{\par
  400             return false;\par
  401         \}\par
  402     \}\par
}
}
{\xe \v getReference\:JsonParser}
{\xe \v JsonParser\:getReference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b JsonReference} JsonParser::getReference () const}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a {\b JsonReference} object. This is used for fluent-style access to the data. }}\par
{
Definition at line 182 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonReference::JsonReference(), tokens, and tokensEnd.}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   182                                              \{\par
  183 \par
  184     if (tokens < tokensEnd) \{\par
  185         return JsonReference(this, &tokens[0]);\par
  186     \}\par
  187     else \{\par
  188         return JsonReference(this);\par
  189     \}\par
  190 \}\par
}
}
{\xe \v getTokenByIndex\:JsonParser}
{\xe \v JsonParser\:getTokenByIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b JsonParserGeneratorRK::jsmntok_t} * JsonParser::getTokenByIndex (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i container}, size_t  {\i desiredIndex}) const}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given a containing object, finds the nth token in the object. Internal use only. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i container} \cell }{The array token to look in.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i desiredIndex} \cell }{The index to retrieve (0 = first, 1 = second, ...).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The token\par
}This is used internally. It should not be used to get the nth array value, use getValueTokenByIndex instead. \par
}{
Definition at line 201 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParserGeneratorRK::jsmntok_t::end, skipObject(), and tokensEnd.}\par
{
Referenced by main(), and JsonModifier::removeArrayIndex().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   201                                                                                                                                             \{\par
  202 \par
  203     size_t index = 0;\par
  204     const JsonParserGeneratorRK::jsmntok_t *token = container + 1;\par
  205 \par
  206     while(token < tokensEnd && token->end < container->end) \{\par
  207         if (desiredIndex == index) \{\par
  208             return token;\par
  209         \}\par
  210         index++;\par
  211         skipObject(container, token);\par
  212     \}\par
  213 \par
  214     return 0;\par
  215 \}\par
}
}
{\xe \v getTokenJsonString\:JsonParser}
{\xe \v JsonParser\:getTokenJsonString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonParser::getTokenJsonString (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i token}, {\b String} &  {\i result}) const}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts a token (object, array, string, or primitive) back into JSON in a Wiring {\b String}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i token} \cell }{The token to convert back to a string\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i result} \cell }{Filled in with the string. Any previous contents in the string are cleared first. \cell }
{\row }
}
}{
Definition at line 487 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParserGeneratorRK::jsmntok_t::end, getTokenJsonString(), JsonParserString::JsonParserString(), String::operator=(), String::reserve(), and JsonParserGeneratorRK::jsmntok_t::start.}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   487                                                                                                      \{\par
  488     result = "";\par
  489     result.reserve(token->end - token->start + 3);\par
  490 \par
  491     JsonParserString strWrapper(&result);\par
  492     return getTokenJsonString(token, strWrapper);\par
  493 \}\par
}
}
{\xe \v getTokenJsonString\:JsonParser}
{\xe \v JsonParser\:getTokenJsonString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonParser::getTokenJsonString (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i token}, char *  {\i str}, size_t &  {\i strLen}) const}}
\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts a token (object, array, string, or primitive) back into JSON in a buffer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i token} \cell }{The token to convert back to a string\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{The buffer to be written to\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i strLen} \cell }{The length of the buffer on entry, set to the number of bytes written on exit. \cell }
{\row }
}
}{
Definition at line 495 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParserString::getLength(), getTokenJsonString(), and JsonParserString::JsonParserString().}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   495                                                                                                                 \{\par
  496     JsonParserString strWrapper(str, bufLen);\par
  497     bool result = getTokenJsonString(token, strWrapper);\par
  498     bufLen = strWrapper.getLength() + 1;\par
  499     return result;\par
  500 \}\par
}
}
{\xe \v getTokenJsonString\:JsonParser}
{\xe \v JsonParser\:getTokenJsonString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonParser::getTokenJsonString (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i token}, {\b JsonParserString} &  {\i str}) const}}
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a token as a JSON string. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i token} \cell }{The token to convert back to a string\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{The {\b JsonParserString} object to write to\cell }
{\row }
}
This overload is typically used internally, normally you'd use the version that takes a {\b String}& or char *, size_t. \par
}{
Definition at line 502 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParserString::append(), JsonBuffer::buffer, JsonParserGeneratorRK::jsmntok_t::end, and JsonParserGeneratorRK::jsmntok_t::start.}\par
{
Referenced by getTokenJsonString().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   502                                                                                                             \{\par
  503     str.append(&buffer[token->start], token->end - token->start);\par
  504     return true;\par
  505 \}\par
}
}
{\xe \v getTokens\:JsonParser}
{\xe \v JsonParser\:getTokens}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b JsonParserGeneratorRK::jsmntok_t}* JsonParser::getTokens (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally in the test suite for printing the token list. }}\par
{
Definition at line 733 of file JsonParserGeneratorRK.h.}\par
{
References tokens.}\par
{
Referenced by printTokens().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   733 \{ return tokens; \};\par
}
}
{\xe \v getTokensEnd\:JsonParser}
{\xe \v JsonParser\:getTokensEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b JsonParserGeneratorRK::jsmntok_t}* JsonParser::getTokensEnd (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally in the test suite for printing the token list. }}\par
{
Definition at line 738 of file JsonParserGeneratorRK.h.}\par
{
References tokensEnd.}\par
{
Referenced by printTokens().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   738 \{ return tokensEnd; \};\par
}
}
{\xe \v getTokenValue\:JsonParser}
{\xe \v JsonParser\:getTokenValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonParser::getTokenValue (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i token}, bool &  {\i result}) const}}
\par
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a bool (boolean) value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Normally you'd use {\b getValueByKey()}, {\b getValueByIndex()} or {\b getValueByColRow()} which will automatically use this when the result parameter is a bool variable. \par
}{
Definition at line 338 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonBuffer::buffer, JsonParserGeneratorRK::jsmntok_t::end, and JsonParserGeneratorRK::jsmntok_t::start.}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   338                                                                                               \{\par
  339     if (token->end > token->start) \{\par
  340         switch(buffer[token->start]) \{\par
  341         case 't': // should be this\par
  342         case 'T':\par
  343         case 'y':\par
  344         case 'Y':\par
  345         case '1':\par
  346             result = true;\par
  347             break;\par
  348 \par
  349         default:\par
  350             result = false;\par
  351             break;\par
  352         \}\par
  353         return true;\par
  354     \}\par
  355     else \{\par
  356         return false;\par
  357     \}\par
  358 \}\par
}
}
{\xe \v getTokenValue\:JsonParser}
{\xe \v JsonParser\:getTokenValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonParser::getTokenValue (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i token}, int &  {\i result}) const}}
\par
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets an integer value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Normally you'd use {\b getValueByKey()}, {\b getValueByIndex()} or {\b getValueByColRow()} which will automatically use this when the result parameter is an int variable. \par
}{
Definition at line 360 of file JsonParserGeneratorRK.cpp.}\par
{
References copyTokenValue().}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   360                                                                                              \{\par
  361     // Copy data here, because tokens are not null terminated\par
  362     char tmp[16];\par
  363     copyTokenValue(token, tmp, sizeof(tmp));\par
  364 \par
  365     if (sscanf(tmp, "%d", &result) == 1) \{\par
  366         return true;\par
  367     \}\par
  368     else \{\par
  369         return false;\par
  370     \}\par
  371 \}\par
}
}
{\xe \v getTokenValue\:JsonParser}
{\xe \v JsonParser\:getTokenValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonParser::getTokenValue (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i token}, unsigned long &  {\i result}) const}}
\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets an unsigned long value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Normally you'd use {\b getValueByKey()}, {\b getValueByIndex()} or {\b getValueByColRow()} which will automatically use this when the result parameter is an unsigned long variable. \par
}{
Definition at line 373 of file JsonParserGeneratorRK.cpp.}\par
{
References copyTokenValue().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   373                                                                                                        \{\par
  374     // Copy data here, because tokens are not null terminated\par
  375     char tmp[16];\par
  376     copyTokenValue(token, tmp, sizeof(tmp));\par
  377 \par
  378     if (sscanf(tmp, "%lu", &result) == 1) \{\par
  379         return true;\par
  380     \}\par
  381     else \{\par
  382         return false;\par
  383     \}\par
  384 \}\par
}
}
{\xe \v getTokenValue\:JsonParser}
{\xe \v JsonParser\:getTokenValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonParser::getTokenValue (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i token}, float &  {\i result}) const}}
\par
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a float (single precision floating point) value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Normally you'd use {\b getValueByKey()}, {\b getValueByIndex()} or {\b getValueByColRow()} which will automatically use this when the result parameter is a float variable. \par
}{
Definition at line 388 of file JsonParserGeneratorRK.cpp.}\par
{
References copyTokenValue().}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   388                                                                                                \{\par
  389     // Copy data here, because tokens are not null terminated\par
  390     char tmp[16];\par
  391     copyTokenValue(token, tmp, sizeof(tmp));\par
  392 \par
  393     result = strtof(tmp, 0);\par
  394     return true;\par
  395 \}\par
}
}
{\xe \v getTokenValue\:JsonParser}
{\xe \v JsonParser\:getTokenValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonParser::getTokenValue (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i token}, double &  {\i result}) const}}
\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a double (double precision floating point) value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Normally you'd use {\b getValueByKey()}, {\b getValueByIndex()} or {\b getValueByColRow()} which will automatically use this when the result parameter is a double variable. \par
}{
Definition at line 397 of file JsonParserGeneratorRK.cpp.}\par
{
References copyTokenValue().}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   397                                                                                                 \{\par
  398     // Copy data here, because tokens are not null terminated\par
  399     char tmp[16];\par
  400     copyTokenValue(token, tmp, sizeof(tmp));\par
  401 \par
  402     result = strtod(tmp, 0);\par
  403     return true;\par
  404 \}\par
}
}
{\xe \v getTokenValue\:JsonParser}
{\xe \v JsonParser\:getTokenValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonParser::getTokenValue (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i token}, {\b String} &  {\i result}) const}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a {\b String} value into a Wiring {\b String} object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This will automatically decode Unicode character escapes in the data and the returned {\b String} will contain UTF-8.\par
Normally you'd use {\b getValueByKey()}, {\b getValueByIndex()} or {\b getValueByColRow()} which will automatically use this when the result parameter is a {\b String} variable. \par
}{
Definition at line 408 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParserGeneratorRK::jsmntok_t::end, getTokenValue(), JsonParserString::JsonParserString(), String::operator=(), String::reserve(), and JsonParserGeneratorRK::jsmntok_t::start.}\par
{
Referenced by getKeyValueByIndex(), getValueTokenByKey(), main(), and printJsonInner().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   408                                                                                                 \{\par
  409 \par
  410     result = "";\par
  411     result.reserve(token->end - token->start + 1);\par
  412 \par
  413     JsonParserString strWrapper(&result);\par
  414     return getTokenValue(token, strWrapper);\par
  415 \}\par
}
}
{\xe \v getTokenValue\:JsonParser}
{\xe \v JsonParser\:getTokenValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonParser::getTokenValue (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i token}, char *  {\i str}, size_t &  {\i strLen}) const}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a string as a c-string into the specified buffer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the token specifies too large of a string it will be truncated. This will automatically decode Unicode character escapes in the data and the returned string will contain UTF-8. \par
}{
Definition at line 417 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParserString::getLength(), getTokenValue(), and JsonParserString::JsonParserString().}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   417                                                                                                            \{\par
  418     JsonParserString strWrapper(str, bufLen);\par
  419     bool result = getTokenValue(token, strWrapper);\par
  420     bufLen = strWrapper.getLength() + 1;\par
  421     return result;\par
  422 \}\par
}
}
{\xe \v getTokenValue\:JsonParser}
{\xe \v JsonParser\:getTokenValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonParser::getTokenValue (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i token}, {\b JsonParserString} &  {\i str}) const}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets a string as a {\b JsonParserString} object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is used internally by {\b getTokenValue()} overloads that take a {\b String} or buffer and length; you will normally not need to use this directly.\par
This will automatically decode Unicode character escapes in the data and the returned string will contain UTF-8. \par
}{
Definition at line 425 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParserString::append(), appendUtf8(), JsonBuffer::buffer, JsonParserGeneratorRK::jsmntok_t::end, and JsonParserGeneratorRK::jsmntok_t::start.}\par
{
Referenced by getTokenValue().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   425                                                                                                        \{\par
  426 \par
  427     int unicode;\par
  428     bool escape = false;\par
  429 \par
  430     for(int ii = token->start; ii < token->end; ii++) \{\par
  431         if (escape) \{\par
  432             escape = false;\par
  433             switch(buffer[ii]) \{\par
  434             case 'b':\par
  435                 str.append('\\b');\par
  436                 break;\par
  437 \par
  438             case 'f':\par
  439                 str.append('\\f');\par
  440                 break;\par
  441 \par
  442             case 'n':\par
  443                 str.append('\\n');\par
  444                 break;\par
  445 \par
  446             case 'r':\par
  447                 str.append('\\r');\par
  448                 break;\par
  449 \par
  450             case 't':\par
  451                 str.append('\\t');\par
  452                 break;\par
  453 \par
  454             case 'u':\par
  455                 if ((ii + 4) < token->end) \{\par
  456                     // Copy data here because buffer is not null terminated and this could\par
  457                     // read past the end otherwise\par
  458                     char tmp[5];\par
  459                     for(size_t jj = 0; jj < 4; jj++) \{\par
  460                         tmp[jj] = buffer[ii + jj + 1];\par
  461                     \}\par
  462                     tmp[4] = 0;\par
  463                     if (sscanf(tmp, "%04x", &unicode) == 1) \{\par
  464                         appendUtf8((uint16_t)unicode, str);\par
  465                         ii += 5; // also increments in loop\par
  466                     \}\par
  467                 \}\par
  468                 break;\par
  469 \par
  470             default:\par
  471                 str.append(buffer[ii]);\par
  472                 break;\par
  473             \}\par
  474         \}\par
  475         else\par
  476         if (buffer[ii] == '\\\\') \{\par
  477             escape = true;\par
  478         \}\par
  479         else \{\par
  480             str.append(buffer[ii]);\par
  481         \}\par
  482     \}\par
  483 \par
  484     return true;\par
  485 \}\par
}
}
{\xe \v getValueByColRow\:JsonParser}
{\xe \v JsonParser\:getValueByColRow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > bool JsonParser::getValueByColRow (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i arrayContainer}, size_t  {\i col}, size_t  {\i row}, T &  {\i result}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method is used to extract data from a 2-dimensional JSON array, an array of arrays of values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i arrayContainer} \cell }{A token for an array containing another array\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i col} \cell }{The column (outer array index, 0 = first column, 1 = second column, ...)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i row} \cell }{The row (inner array index, 0 = first row, 1 = second row, ...)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i result} \cell }{Filled in with the value. The value can be of type: bool, int, unsigned long, float, double, {\b String}, or (char *, size_t&).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the call succeeded or false if it failed. You can call this repeatedly until it returns false to iterate the array.\par
}This should only be used for things like string, numbers, booleans, etc.. If you want to get a JSON array or object within a two-dimensional array, use {\b getValueTokenByColRow()} instead. \par
}{
Definition at line 509 of file JsonParserGeneratorRK.h.}\par
{
References getValueTokenByColRow().}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   509                                                                                                                          \{\par
  510         const JsonParserGeneratorRK::jsmntok_t *value;\par
  511 \par
  512         if (getValueTokenByColRow(arrayContainer, col, row, value)) \{\par
  513             return getTokenValue(value, result);\par
  514         \}\par
  515         else \{\par
  516             return false;\par
  517         \}\par
  518     \}\par
}
}
{\xe \v getValueByIndex\:JsonParser}
{\xe \v JsonParser\:getValueByIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > bool JsonParser::getValueByIndex (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i arrayContainer}, size_t  {\i index}, T &  {\i result}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given an array token in arrayContainer, gets the value with the specified index. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i arrayContainer} \cell }{A token for an array\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{The index in the array. 0 = first item, 1 = second item, ...\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i result} \cell }{Filled in with the value. The value can be of type: bool, int, unsigned long, float, double, {\b String}, or (char *, size_t&).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the call succeeded or false if it failed. You can call this repeatedly until it returns false to iterate the array.\par
}This should only be used for things like string, numbers, booleans, etc.. If you want to get a JSON array or object within an array, use {\b getValueTokenByIndex()} instead. \par
}{
Definition at line 479 of file JsonParserGeneratorRK.h.}\par
{
References getValueTokenByIndex().}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   479                                                                                                               \{\par
  480         const JsonParserGeneratorRK::jsmntok_t *value;\par
  481 \par
  482         if (getValueTokenByIndex(arrayContainer, index, value)) \{\par
  483             return getTokenValue(value, result);\par
  484         \}\par
  485         else \{\par
  486             return false;\par
  487         \}\par
  488     \}\par
}
}
{\xe \v getValueByKey\:JsonParser}
{\xe \v JsonParser\:getValueByKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > bool JsonParser::getValueByKey (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i container}, const char *  {\i name}, T &  {\i result}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given an object token in container, gets the value with the specified key name. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i container} \cell }{The token for the object to obtain the data from.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i name} \cell }{The name of the key to retrieve\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i result} \cell }{The returned data. The value can be of type: bool, int, unsigned long, float, double, {\b String}, or (char *, size_t&).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the data was retrieved successfully, false if not (key not present or incompatible data type).\par
}This should only be used for things like string, numbers, booleans, etc.. If you want to get a JSON array or object within an object, use {\b getValueTokenByKey()} instead. \par
}{
Definition at line 367 of file JsonParserGeneratorRK.h.}\par
{
References getValueTokenByKey().}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   367                                                                                                            \{\par
  368         const JsonParserGeneratorRK::jsmntok_t *value;\par
  369 \par
  370         if (getValueTokenByKey(container, name, value)) \{\par
  371             return getTokenValue(value, result);\par
  372         \}\par
  373         else \{\par
  374             return false;\par
  375         \}\par
  376     \}\par
}
}
{\xe \v getValueTokenByColRow\:JsonParser}
{\xe \v JsonParser\:getValueTokenByColRow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonParser::getValueTokenByColRow (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i container}, size_t  {\i col}, size_t  {\i row}, const {\b JsonParserGeneratorRK::jsmntok_t} *&  {\i value}) const}}
\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This method is used to extract data from a 2-dimensional JSON array, an array of arrays of values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i container} \cell }{A token for an array containing another array\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i col} \cell }{The column (outer array index, 0 = first column, 1 = second column, ...)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i row} \cell }{The row (inner array index, 0 = first row, 1 = second row, ...)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{Filled in with the token for the value for key.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the index row and column are valid or false if either is out of range.\par
}This can be used for 2-dimensional arrays whose values are arrays or objects, to get the token for the container. It can also be used for values, but normally you'd use {\b getValueByColRow()} instead, which is generally more convenient. \par
}{
Definition at line 301 of file JsonParserGeneratorRK.cpp.}\par
{
References getValueTokenByIndex().}\par
{
Referenced by getValueByColRow().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   301                                                                                                                                                                   \{\par
  302 \par
  303     const JsonParserGeneratorRK::jsmntok_t *columnContainer;\par
  304 \par
  305     if (getValueTokenByIndex(container, col, columnContainer)) \{\par
  306         return getValueTokenByIndex(columnContainer, row, value);\par
  307     \}\par
  308     else \{\par
  309         return false;\par
  310     \}\par
  311 \}\par
}
}
{\xe \v getValueTokenByIndex\:JsonParser}
{\xe \v JsonParser\:getValueTokenByIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonParser::getValueTokenByIndex (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i container}, size_t  {\i desiredIndex}, const {\b JsonParserGeneratorRK::jsmntok_t} *&  {\i value}) const}}
\par
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given an array token in container, gets the token value with the specified index. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i container} \cell }{The array token to look in.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i desiredIndex} \cell }{The index to retrieve (0 = first, 1 = second, ...).\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{Filled in with the token for the value for key.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the index is valid or false if the index exceeds the size of the array.\par
}This can be used for arrays whose values are arrays or objects, to get the token for the container. It can also be used for values, but normally you'd use {\b getValueByIndex()} instead, which is generally more convenient. \par
}{
Definition at line 285 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParserGeneratorRK::jsmntok_t::end, skipObject(), and tokensEnd.}\par
{
Referenced by getValueByIndex(), getValueTokenByColRow(), JsonReference::index(), main(), and printJsonInner().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   285                                                                                                                                                               \{\par
  286     size_t index = 0;\par
  287     const JsonParserGeneratorRK::jsmntok_t *token = container + 1;\par
  288 \par
  289     while(token < tokensEnd && token->end < container->end) \{\par
  290         if (desiredIndex == index) \{\par
  291             value = token;\par
  292             return true;\par
  293         \}\par
  294         index++;\par
  295         skipObject(container, token);\par
  296     \}\par
  297 \par
  298     return false;\par
  299 \}\par
}
}
{\xe \v getValueTokenByKey\:JsonParser}
{\xe \v JsonParser\:getValueTokenByKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonParser::getValueTokenByKey (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i container}, const char *  {\i key}, const {\b JsonParserGeneratorRK::jsmntok_t} *&  {\i value}) const}}
\par
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Given an object token in container, gets the token value with the specified key name. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i container} \cell }{The object token to look in.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i key} \cell }{The key to look for.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{Filled in with the token for the value for key.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the key is found or false if not.\par
}This can be used for objects whose keys are arrays or objects, to get the token for the container. It can also be used for values, but normally you'd use {\b getValueByKey()} instead, which is generally more convenient. \par
}{
Definition at line 272 of file JsonParserGeneratorRK.cpp.}\par
{
References getKeyValueTokenByIndex(), getTokenValue(), and String::operator==().}\par
{
Referenced by getOuterValueByKey(), getValueByKey(), JsonReference::key(), main(), and JsonModifier::removeKeyValue().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   272                                                                                                                                                          \{\par
  273 \par
  274     const JsonParserGeneratorRK::jsmntok_t *key;\par
  275     String keyName;\par
  276 \par
  277     for(size_t ii = 0; getKeyValueTokenByIndex(container, key, value, ii); ii++) \{\par
  278         if (getTokenValue(key, keyName) && keyName == name) \{\par
  279             return true;\par
  280         \}\par
  281     \}\par
  282     return false;\par
  283 \}\par
}
}
{\xe \v parse\:JsonParser}
{\xe \v JsonParser\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonParser::parse ()}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parses the data you have added using {\b addData()} or {\b addString()}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When parsing data split into multiple chunks as a webhook response you can call {\b addString()} in your webhook subscription handler and call parse after each chunk. Only on the last chunk will parse return true, and you'll know the entire reponse has been received. \par
}{
Definition at line 118 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonBuffer::buffer, JsonParserGeneratorRK::JSMN_ERROR_NOMEM, JsonParserGeneratorRK::jsmn_init(), JsonParserGeneratorRK::jsmn_parse(), maxTokens, JsonBuffer::offset, parser, JsonBuffer::staticBuffers, tokens, and tokensEnd.}\par
{
Referenced by JsonModifier::finish(), getMeasure_callback(), main(), JsonModifier::removeArrayIndex(), JsonModifier::removeKeyValue(), runTest(), and subscriptionHandler().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   118                        \{\par
  119     if (offset == 0) \{\par
  120         // If addString or addData is not called, or called with an empty string,\par
  121         // do not return true, see issue #7.\par
  122         return false;\par
  123     \}\par
  124 \par
  125     if (tokens) \{\par
  126         // Try to use the existing token buffer if possible\par
  127         JsonParserGeneratorRK::jsmn_init(&parser);\par
  128         int result = JsonParserGeneratorRK::jsmn_parse(&parser, buffer, offset, tokens, maxTokens);\par
  129         if (result == JsonParserGeneratorRK::JSMN_ERROR_NOMEM) \{\par
  130             if (staticBuffers) \{\par
  131                 // If using static buffers and there is not enough space, fail\par
  132                 return false;\par
  133             \}\par
  134             free(tokens);\par
  135             tokens = 0;\par
  136             maxTokens = 0;\par
  137         \}\par
  138         else\par
  139         if (result < 0) \{\par
  140             // Failed to parse: JSMN_ERROR_INVAL or JSMN_ERROR_PART\par
  141             return false;\par
  142         \}\par
  143         else \{\par
  144             tokensEnd = &tokens[result];\par
  145             return true;\par
  146         \}\par
  147     \}\par
  148 \par
  149     // Pass 1: determine now many tokens we need\par
  150     JsonParserGeneratorRK::jsmn_init(&parser);\par
  151     int result = JsonParserGeneratorRK::jsmn_parse(&parser, buffer, offset, 0, 0);\par
  152     if (result < 0) \{\par
  153         // Failed to parse: JSMN_ERROR_INVAL or JSMN_ERROR_PART\par
  154         return false;\par
  155     \}\par
  156 \par
  157     // If we get here, tokens will always be == 0; it would have been freed if it was\par
  158     // too small, and this code is never executed for staticBuffers == true\par
  159 \par
  160     maxTokens = (size_t) result;\par
  161     if (maxTokens > 0) \{\par
  162         tokens = (JsonParserGeneratorRK::jsmntok_t *)malloc(sizeof(JsonParserGeneratorRK::jsmntok_t) * maxTokens);\par
  163 \par
  164         JsonParserGeneratorRK::jsmn_init(&parser);\par
  165         int result = JsonParserGeneratorRK::jsmn_parse(&parser, buffer, offset, tokens, maxTokens);\par
  166 \par
  167         tokensEnd = &tokens[result];\par
  168     \}\par
  169     else \{\par
  170         tokensEnd = tokens;\par
  171     \}\par
  172 \par
  173     /*\par
  174     for(const JsonParserGeneratorRK::jsmntok_t *token = tokens; token < tokensEnd; token++) \{\par
  175         printf("%d, %d, %d, %d\\n", token->type, token->start, token->end, token->size);\par
  176     \}\par
  177     */\par
  178 \par
  179     return true;\par
  180 \}\par
}
}
{\xe \v skipObject\:JsonParser}
{\xe \v JsonParser\:skipObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonParser::skipObject (const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i container}, const {\b JsonParserGeneratorRK::jsmntok_t} *&  {\i obj}) const}}
\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally to skip over the token in obj. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i container} \cell }{The array token to look in.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i obj} \cell }{Object within the token, updated to the next object if true is returned\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if there was a next object, false if not.\par
}For simple primitives and strings, this is equivalent to obj++. For objects and arrays, however, this skips over the entire object or array, including any nested objects within them. \par
}{
Definition at line 237 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParserGeneratorRK::jsmntok_t::end, and tokensEnd.}\par
{
Referenced by getArraySize(), getKeyValueTokenByIndex(), getTokenByIndex(), and getValueTokenByIndex().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   237                                                                                                                              \{\par
  238     int curObjectEnd = obj->end;\par
  239 \par
  240     while(++obj < tokensEnd && obj->end < container->end && obj->end <= curObjectEnd) \{\par
  241     \}\par
  242 \par
  243     if (obj >= tokensEnd || obj->end > container->end) \{\par
  244         // No object after index\par
  245         return false;\par
  246     \}\par
  247     return true;\par
  248 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v JsonModifier\:JsonParser}
{\xe \v JsonParser\:JsonModifier}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b JsonModifier}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 756 of file JsonParserGeneratorRK.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v maxTokens\:JsonParser}
{\xe \v JsonParser\:maxTokens}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t JsonParser::maxTokens{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of tokens that can be stored in tokens. }}\par
{
Definition at line 753 of file JsonParserGeneratorRK.h.}\par
{
Referenced by allocateTokens(), getMaxTokens(), JsonParser(), and parse().}\par
}
{\xe \v parser\:JsonParser}
{\xe \v JsonParser\:parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b JsonParserGeneratorRK::jsmn_parser} JsonParser::parser{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The JSMN parser object. }}\par
{
Definition at line 754 of file JsonParserGeneratorRK.h.}\par
{
Referenced by parse().}\par
}
{\xe \v tokens\:JsonParser}
{\xe \v JsonParser\:tokens}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b JsonParserGeneratorRK::jsmntok_t}* JsonParser::tokens{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Array of tokens after parsing. }}\par
{
Definition at line 751 of file JsonParserGeneratorRK.h.}\par
{
Referenced by allocateTokens(), getOuterArray(), getOuterObject(), getOuterToken(), getReference(), getTokens(), JsonParser(), parse(), and ~JsonParser().}\par
}
{\xe \v tokensEnd\:JsonParser}
{\xe \v JsonParser\:tokensEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b JsonParserGeneratorRK::jsmntok_t}* JsonParser::tokensEnd{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Pointer into tokens, points after last used token. }}\par
{
Definition at line 752 of file JsonParserGeneratorRK.h.}\par
{
Referenced by getArraySize(), getKeyValueTokenByIndex(), getOuterArray(), getOuterObject(), getOuterToken(), getReference(), getTokenByIndex(), getTokensEnd(), getValueTokenByIndex(), JsonParser(), parse(), and skipObject().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/src/{\b JsonParserGeneratorRK.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/src/{\b JsonParserGeneratorRK.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
JsonParserStatic< BUFFER_SIZE, MAX_TOKENS > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v JsonParserStatic< BUFFER_SIZE, MAX_TOKENS >}
{\xe \v JsonParserStatic< BUFFER_SIZE, MAX_TOKENS >}
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a {\b JsonParser} with a static buffer. }}\par
{
{\f2 #include <JsonParserGeneratorRK.h>}}\par
Inheritance diagram for JsonParserStatic< BUFFER_SIZE, MAX_TOKENS >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_json_parser_static__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for JsonParserStatic< BUFFER_SIZE, MAX_TOKENS >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_json_parser_static__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonParserStatic} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b JsonParser} using a static buffer and static maximum number of tokens. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b staticBuffer} [BUFFER_SIZE]\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The static buffer to hold the data. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonParserGeneratorRK::jsmntok_t} {\b staticTokens} [MAX_TOKENS]\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The static buffer to hold the tokens. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<size_t BUFFER_SIZE, size_t MAX_TOKENS>\par
class JsonParserStatic< BUFFER_SIZE, MAX_TOKENS >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a {\b JsonParser} with a static buffer. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
You normally use this when you're creating a parser as a global variable. For small data (under around 256 bytes so) you can also allocate one on the stack.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i BUFFER_SIZE} \cell }{The maximum size of the data to be parsed, in bytes. If you are parsing a webhook response split into parts, this is the total size of all parts.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i MAX_TOKENS} \cell }{The maximum number of tokens you expect. Each object has a token and two for each key/value pair. Each array is a token and one for each element in the array. \cell }
{\row }
}
}{
Definition at line 772 of file JsonParserGeneratorRK.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v JsonParserStatic\:JsonParserStatic}
{\xe \v JsonParserStatic\:JsonParserStatic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<size_t BUFFER_SIZE, size_t MAX_TOKENS> {\b JsonParserStatic}< BUFFER_SIZE, MAX_TOKENS >::{\b JsonParserStatic} (){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b JsonParser} using a static buffer and static maximum number of tokens. }}\par
{
Definition at line 777 of file JsonParserGeneratorRK.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   777 : JsonParser(staticBuffer, BUFFER_SIZE, staticTokens, MAX_TOKENS) \{\};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v staticBuffer\:JsonParserStatic}
{\xe \v JsonParserStatic\:staticBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<size_t BUFFER_SIZE, size_t MAX_TOKENS> char {\b JsonParserStatic}< BUFFER_SIZE, MAX_TOKENS >::staticBuffer[BUFFER_SIZE]{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The static buffer to hold the data. }}\par
{
Definition at line 777 of file JsonParserGeneratorRK.h.}\par
}
{\xe \v staticTokens\:JsonParserStatic}
{\xe \v JsonParserStatic\:staticTokens}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<size_t BUFFER_SIZE, size_t MAX_TOKENS> {\b JsonParserGeneratorRK::jsmntok_t} {\b JsonParserStatic}< BUFFER_SIZE, MAX_TOKENS >::staticTokens[MAX_TOKENS]{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The static buffer to hold the tokens. }}\par
{
Definition at line 781 of file JsonParserGeneratorRK.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/src/{\b JsonParserGeneratorRK.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
JsonParserString Class Reference\par \pard\plain 
{\tc\tcl2 \v JsonParserString}
{\xe \v JsonParserString}
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class used internally for writing to strings. }}\par
{
{\f2 #include <JsonParserGeneratorRK.h>}}\par
Collaboration diagram for JsonParserString:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_json_parser_string__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonParserString} ({\b String} *{\b str})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b JsonParserString} wrapping a Wiring {\b String}. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonParserString} (char *{\b buf}, size_t {\b bufLen})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b JsonParserString} wrapping a buffer and length. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b append} (char ch)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append a single char to the underlying string. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b append} (const char *{\b str}, size_t len)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append a buffer and length to the underlying string. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b getLength} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the length of the string. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} * {\b str}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When writing to a {\b String}, the {\b String} object. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b buf}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When writing to a buffer, the pointer to the buffer. Not used for {\b String}. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b bufLen}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When writing to a buffer, the length of the buffer in bytes. Not used for {\b String}. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b length}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The current offset being written to. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class used internally for writing to strings. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a wrapper around either {\b String} (the Wiring version) or a buffer and length. This allows writing to a static buffer with no dynamic memory allocation at all.\par
One of the things about {\b String} is that while you can pre-allocate reserve space for data, you can't get access to the internal length field, so you can't write to raw bytes then resize it to the correct size. This wrapper is that allows appending to either a {\b String} or buffer to get around this limitation of {\b String}.\par
You can also use it for sizing only by passing NULL for buf. \par
}{
Definition at line 92 of file JsonParserGeneratorRK.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v JsonParserString\:JsonParserString}
{\xe \v JsonParserString\:JsonParserString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
JsonParserString::JsonParserString ({\b String} *  {\i str})}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b JsonParserString} wrapping a Wiring {\b String}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{A pointer Wiring {\b String} object to write to. \cell }
{\row }
}
}{
Definition at line 623 of file JsonParserGeneratorRK.cpp.}\par
{
References buf, bufLen, length, and str.}\par
{
Referenced by JsonParser::getTokenJsonString(), and JsonParser::getTokenValue().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   623                                               : str(str), buf(0), bufLen(0), length(0)\{\par
  624 \}\par
}
}
{\xe \v JsonParserString\:JsonParserString}
{\xe \v JsonParserString\:JsonParserString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
JsonParserString::JsonParserString (char *  {\i buf}, size_t  {\i bufLen})}}
\par
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b JsonParserString} wrapping a buffer and length. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buf} \cell }{A pointer to a buffer\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bufLen} \cell }{The length of the buffer in bytes \cell }
{\row }
}
}{
Definition at line 626 of file JsonParserGeneratorRK.cpp.}\par
{
References buf, bufLen, length, and str.}\par
{
Referenced by JsonParser::getTokenJsonString(), and JsonParser::getTokenValue().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   626                                                            : str(0), buf(buf), bufLen(bufLen), length(0)\{\par
  627     if (buf && bufLen) \{\par
  628         memset(buf, 0, bufLen);\par
  629     \}\par
  630 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v append\:JsonParserString}
{\xe \v JsonParserString\:append}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonParserString::append (char  {\i ch})}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append a single char to the underlying string. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ch} \cell }{The char to append. \cell }
{\row }
}
}{
Definition at line 632 of file JsonParserGeneratorRK.cpp.}\par
{
References buf, bufLen, String::concat(), length, and str.}\par
{
Referenced by append(), JsonParser::appendUtf8(), and JsonParser::getTokenValue().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   632                                      \{\par
  633     if (str) \{\par
  634         str->concat(ch);\par
  635         length++;\par
  636     \}\par
  637     else \{\par
  638         if (buf && length < (bufLen - 1)) \{\par
  639             buf[length] = ch;\par
  640         \}\par
  641         length++;\par
  642     \}\par
  643 \}\par
}
}
{\xe \v append\:JsonParserString}
{\xe \v JsonParserString\:append}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonParserString::append (const char *  {\i str}, size_t  {\i len})}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append a buffer and length to the underlying string. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{A pointer to the character to add. Does not need to be null-terminated.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i len} \cell }{Length of the string to append in bytes. \cell }
{\row }
}
}{
Definition at line 645 of file JsonParserGeneratorRK.cpp.}\par
{
References append().}\par
{
Referenced by JsonParser::getTokenJsonString().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   645                                                          \{\par
  646     for(size_t ii = 0; ii < len; ii++) \{\par
  647         append(str[ii]);\par
  648     \}\par
  649 \}\par
}
}
{\xe \v getLength\:JsonParserString}
{\xe \v JsonParserString\:getLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t JsonParserString::getLength () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the length of the string. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The string length in bytes. If the string contains UTF-8 characters, it will be the number of bytes, not characters.\par
}For buffer and bufLenb, the maximum string length will be bufLen - 1 to leave room for the null terminator. \par
}{
Definition at line 134 of file JsonParserGeneratorRK.h.}\par
{
References length.}\par
{
Referenced by JsonParser::getTokenJsonString(), and JsonParser::getTokenValue().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   134 \{ return length; \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v buf\:JsonParserString}
{\xe \v JsonParserString\:buf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* JsonParserString::buf{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When writing to a buffer, the pointer to the buffer. Not used for {\b String}. }}\par
{
Definition at line 138 of file JsonParserGeneratorRK.h.}\par
{
Referenced by append(), and JsonParserString().}\par
}
{\xe \v bufLen\:JsonParserString}
{\xe \v JsonParserString\:bufLen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t JsonParserString::bufLen{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When writing to a buffer, the length of the buffer in bytes. Not used for {\b String}. }}\par
{
Definition at line 139 of file JsonParserGeneratorRK.h.}\par
{
Referenced by append(), and JsonParserString().}\par
}
{\xe \v length\:JsonParserString}
{\xe \v JsonParserString\:length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t JsonParserString::length{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The current offset being written to. }}\par
{
Definition at line 140 of file JsonParserGeneratorRK.h.}\par
{
Referenced by append(), getLength(), and JsonParserString().}\par
}
{\xe \v str\:JsonParserString}
{\xe \v JsonParserString\:str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String}* JsonParserString::str{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When writing to a {\b String}, the {\b String} object. }}\par
{
Definition at line 137 of file JsonParserGeneratorRK.h.}\par
{
Referenced by append(), and JsonParserString().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/src/{\b JsonParserGeneratorRK.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/src/{\b JsonParserGeneratorRK.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
JsonReference Class Reference\par \pard\plain 
{\tc\tcl2 \v JsonReference}
{\xe \v JsonReference}
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class provides a fluent-style API for easily traversing a tree of JSON objects to find a value. }}\par
{
{\f2 #include <JsonParserGeneratorRK.h>}}\par
Collaboration diagram for JsonReference:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_json_reference__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonReference} (const {\b JsonParser} *{\b parser})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs an object. Normally you use the {\b JsonParser} getReference() method to get one of these instead of constructing one. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~JsonReference} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. This does not affect the lifecycle of the {\b JsonParser}. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonReference} (const {\b JsonParser} *{\b parser}, const {\b JsonParserGeneratorRK::jsmntok_t} *{\b token})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs are {\b JsonReference} for a specific token within a {\b JsonParser}. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonReference} {\b key} (const char *name) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For {\b JsonReference} that refers to a JSON object, gets a new {\b JsonReference} to a value with the specified key name. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonReference} {\b index} (size_t index) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For a {\b JsonReference} that refers to a JSON array, gets a new {\b JsonReference} to a value in the array by index. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For a {\b JsonReference} that refers to a JSON array, gets the size of the array. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class T > bool {\b value} (T &result) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a value of the specified type for a given value for a specified key, or index for an array. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b valueBool} (bool defaultValue=false) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a boolean (bool) value for an object value for key, or array index. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b valueInt} (int defaultValue=0) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a integer (int) value for an object value for key, or array index. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b valueUnsignedLong} (unsigned long defaultValue=0) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a unsigned long integer for an object value for key, or array index. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b valueFloat} (float defaultValue=0.0) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a float value for an object value for key, or array index. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b valueDouble} (double defaultValue=0.0) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a double value for an object value for key, or array index. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} {\b valueString} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b String} value for an object value for key, or array index. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b JsonParser} * {\b parser}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b JsonParserGeneratorRK::jsmntok_t} * {\b token}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class provides a fluent-style API for easily traversing a tree of JSON objects to find a value. \par
}{
Definition at line 788 of file JsonParserGeneratorRK.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v JsonReference\:JsonReference}
{\xe \v JsonReference\:JsonReference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
JsonReference::JsonReference (const {\b JsonParser} *  {\i parser})}}
\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs an object. Normally you use the {\b JsonParser} getReference() method to get one of these instead of constructing one. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parser} \cell }{The {\b JsonParser} object you're traversing \cell }
{\row }
}
}{
Definition at line 546 of file JsonParserGeneratorRK.cpp.}\par
{
References parser, and token.}\par
{
Referenced by JsonParser::getReference(), index(), and key().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   546                                                      : parser(parser), token(0) \{\par
  547 \par
  548 \}\par
}
}
{\xe \v ~JsonReference\:JsonReference}
{\xe \v JsonReference\:~JsonReference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
JsonReference::~JsonReference (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. This does not affect the lifecycle of the {\b JsonParser}. }}\par
{
Definition at line 550 of file JsonParserGeneratorRK.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   550                               \{\par
  551 \}\par
}
}
{\xe \v JsonReference\:JsonReference}
{\xe \v JsonReference\:JsonReference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
JsonReference::JsonReference (const {\b JsonParser} *  {\i parser}, const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i token})}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs are {\b JsonReference} for a specific token within a {\b JsonParser}. }}\par
{
Definition at line 553 of file JsonParserGeneratorRK.cpp.}\par
{
References parser, and token.}\par
{
Referenced by JsonParser::getReference(), index(), and key().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   553                                                                                                   : parser(parser), token(token) \{\par
  554 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v index\:JsonReference}
{\xe \v JsonReference\:index}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b JsonReference} JsonReference::index (size_t  {\i index}) const}}
\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For a {\b JsonReference} that refers to a JSON array, gets a new {\b JsonReference} to a value in the array by index. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{The index to retrieve (0 = first item, 1 = second item, ...).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid A {\b JsonReference} to the value for this index. \par
}}{
Definition at line 567 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParser::getValueTokenByIndex(), JsonReference(), parser, and token.}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   567                                                      \{\par
  568     const JsonParserGeneratorRK::jsmntok_t *newToken;\par
  569 \par
  570     if (token && parser->getValueTokenByIndex(token, index, newToken)) \{\par
  571         return JsonReference(parser, newToken);\par
  572     \}\par
  573     else \{\par
  574         return JsonReference(parser);\par
  575     \}\par
  576 \}\par
}
}
{\xe \v key\:JsonReference}
{\xe \v JsonReference\:key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b JsonReference} JsonReference::key (const char *  {\i name}) const}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For {\b JsonReference} that refers to a JSON object, gets a new {\b JsonReference} to a value with the specified key name. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i name} \cell }{of the key to look for.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid A {\b JsonReference} to the value for this key. \par
}}{
Definition at line 556 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParser::getValueTokenByKey(), JsonReference(), parser, and token.}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   556                                                        \{\par
  557     const JsonParserGeneratorRK::jsmntok_t *newToken;\par
  558 \par
  559     if (token && parser->getValueTokenByKey(token, name, newToken)) \{\par
  560         return JsonReference(parser, newToken);\par
  561     \}\par
  562     else \{\par
  563         return JsonReference(parser);\par
  564     \}\par
  565 \}\par
}
}
{\xe \v size\:JsonReference}
{\xe \v JsonReference\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t JsonReference::size () const}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For a {\b JsonReference} that refers to a JSON array, gets the size of the array. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 = an empty array, 1 = one element, ... \par
}}{
Definition at line 578 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonParser::getArraySize(), parser, and token.}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   578                                  \{\par
  579     if (token) \{\par
  580         return parser->getArraySize(token);\par
  581     \}\par
  582     else \{\par
  583         return 0;\par
  584     \}\par
  585 \}\par
}
}
{\xe \v value\:JsonReference}
{\xe \v JsonReference\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > bool JsonReference::value (T &  {\i result}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get a value of the specified type for a given value for a specified key, or index for an array. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i result} \cell }{Filled in with the value. The value can be of type: bool, int, unsigned long, float, double, {\b String}, or (char *, size_t&).\cell }
{\row }
}
There are also type-specific versions like valueBool that return the value, instead of having to pass an object to hold the value, as in this call. \par
}{
Definition at line 843 of file JsonParserGeneratorRK.h.}\par
{
References parser, and token.}\par
{
Referenced by valueBool(), valueDouble(), valueFloat(), valueInt(), valueString(), and valueUnsignedLong().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   843                                 \{\par
  844         if (token && parser->getTokenValue(token, result)) \{\par
  845             return true;\par
  846         \}\par
  847         else \{\par
  848             return false;\par
  849         \}\par
  850     \}\par
}
}
{\xe \v valueBool\:JsonReference}
{\xe \v JsonReference\:valueBool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonReference::valueBool (bool  {\i defaultValue} = {\f2 false}) const}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a boolean (bool) value for an object value for key, or array index. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i defaultValue} \cell }{Optional value to use if the key or array index is not found. Default: false. \cell }
{\row }
}
}{
Definition at line 587 of file JsonParserGeneratorRK.cpp.}\par
{
References value().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   587                                                \{\par
  588     (void) value(result);\par
  589     return result;\par
  590 \}\par
}
}
{\xe \v valueDouble\:JsonReference}
{\xe \v JsonReference\:valueDouble}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double JsonReference::valueDouble (double  {\i defaultValue} = {\f2 0.0}) const}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a double value for an object value for key, or array index. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i defaultValue} \cell }{Optional value to use if the key or array index is not found. Default: 0.0. \cell }
{\row }
}
}{
Definition at line 607 of file JsonParserGeneratorRK.cpp.}\par
{
References value().}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   607                                                      \{\par
  608     (void) value(result);\par
  609     return result;\par
  610 \}\par
}
}
{\xe \v valueFloat\:JsonReference}
{\xe \v JsonReference\:valueFloat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float JsonReference::valueFloat (float  {\i defaultValue} = {\f2 0.0}) const}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a float value for an object value for key, or array index. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i defaultValue} \cell }{Optional value to use if the key or array index is not found. Default: 0.0. \cell }
{\row }
}
}{
Definition at line 602 of file JsonParserGeneratorRK.cpp.}\par
{
References value().}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   602                                                   \{\par
  603     (void) value(result);\par
  604     return result;\par
  605 \}\par
}
}
{\xe \v valueInt\:JsonReference}
{\xe \v JsonReference\:valueInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int JsonReference::valueInt (int  {\i defaultValue} = {\f2 0}) const}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a integer (int) value for an object value for key, or array index. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i defaultValue} \cell }{Optional value to use if the key or array index is not found. Default: 0. \cell }
{\row }
}
}{
Definition at line 592 of file JsonParserGeneratorRK.cpp.}\par
{
References value().}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   592                                             \{\par
  593     (void) value(result);\par
  594     return result;\par
  595 \}\par
}
}
{\xe \v valueString\:JsonReference}
{\xe \v JsonReference\:valueString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String} JsonReference::valueString () const}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b String} value for an object value for key, or array index. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The string value, or an empty string if the key or array index is not found. \par
}}{
Definition at line 612 of file JsonParserGeneratorRK.cpp.}\par
{
References value().}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   612                                         \{\par
  613     String result;\par
  614 \par
  615     (void) value(result);\par
  616     return result;\par
  617 \}\par
}
}
{\xe \v valueUnsignedLong\:JsonReference}
{\xe \v JsonReference\:valueUnsignedLong}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long JsonReference::valueUnsignedLong (unsigned long  {\i defaultValue} = {\f2 0}) const}}
\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a unsigned long integer for an object value for key, or array index. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i defaultValue} \cell }{Optional value to use if the key or array index is not found. Default: 0. \cell }
{\row }
}
}{
Definition at line 597 of file JsonParserGeneratorRK.cpp.}\par
{
References value().}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   597                                                                          \{\par
  598     (void) value(result);\par
  599     return result;\par
  600 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v parser\:JsonReference}
{\xe \v JsonReference\:parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b JsonParser}* JsonReference::parser{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 895 of file JsonParserGeneratorRK.h.}\par
{
Referenced by index(), JsonReference(), key(), size(), and value().}\par
}
{\xe \v token\:JsonReference}
{\xe \v JsonReference\:token}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b JsonParserGeneratorRK::jsmntok_t}* JsonReference::token{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 896 of file JsonParserGeneratorRK.h.}\par
{
Referenced by index(), JsonReference(), key(), size(), and value().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/src/{\b JsonParserGeneratorRK.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/src/{\b JsonParserGeneratorRK.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
JsonWriter Class Reference\par \pard\plain 
{\tc\tcl2 \v JsonWriter}
{\xe \v JsonWriter}
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for building a JSON string. }}\par
{
{\f2 #include <JsonParserGeneratorRK.h>}}\par
Inheritance diagram for JsonWriter:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_json_writer__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for JsonWriter:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_json_writer__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonWriter} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b JsonWriter} with a dynamically allocated buffer. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~JsonWriter} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroy the object. If the buffer was dynamically allocated it will be freed. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonWriter} (char *{\b buffer}, size_t {\b bufferLen})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b JsonWriter} to write to a static buffer. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reset the writer, clearing all data. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b startObject} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start a new JSON object. Make sure you finish it with {\b finishObjectOrArray()} }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b startArray} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start a new JSON array. Make sure you finish it with {\b finishObjectOrArray()} }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b finishObjectOrArray} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finsh an object or array started with {\b startObject()} or {\b startArray()} }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b insertValue} (bool value)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a boolean value ("true" or "false"). }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b insertValue} (int value)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts an integer value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b insertValue} (unsigned int value)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts an unsigned integer value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b insertValue} (long value)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a long integer value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b insertValue} (unsigned long value)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts an unsigned long integer value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b insertValue} (float value)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a floating point value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b insertValue} (double value)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a floating point double value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b insertValue} (const char *value)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a quoted string value. This escapes special characters and encodes utf-8. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b insertValue} (const {\b String} &value)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a quoted string value. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b insertKeyObject} (const char *key)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a new key and empty object. You must close the object using {\b finishObjectOrArray()}! }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b insertKeyArray} (const char *key)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a new key and empty array. You must close the object using {\b finishObjectOrArray()}! }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class T > void {\b insertKeyValue} (const char *key, T value)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a key/value pair into an object. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class T > void {\b insertArrayValue} (T value)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a value into an array. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class T > void {\b insertArray} (T *pArray, size_t numElem)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts an array of values into an array. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class T > void {\b insertKeyArray} (const char *key, T *pArray, size_t numElem)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a new key and vector of values. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class T > void {\b insertVector} (std::vector< T > vec)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts an array of values into an array. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class T > void {\b insertKeyVector} (const char *key, std::vector< T > vec)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a new key and vector of values. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isTruncated} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFloatPlaces} (int {\b floatPlaces})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the number of digits for formatting float and double values. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b insertCheckSeparator} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check to see if a separator needs to be inserted. Used internally. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b startObjectOrArray} (char startChar, char endChar)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally to start an object or array. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b insertChar} (char ch)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally to insert a character. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b insertString} (const char *s, bool quoted=false)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally to insert a string, quoted or not. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b insertsprintf} (const char *fmt,...)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally to insert using snprintf formatting. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b insertvsprintf} (const char *fmt, va_list ap)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally to insert using snprintf formatting with a va_list. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setIsFirst} (bool isFirst=true)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally to set the current isFirst flag in the context. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const size_t {\b MAX_NESTED_CONTEXT} = 9\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b contextIndex}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Index into the context for the current level of nesting. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonWriterContext} {\b context} [{\b MAX_NESTED_CONTEXT}]\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure for managing nested objects. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b truncated}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
true if data was added that didn't fit and was truncated }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b floatPlaces}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
default number of places to display for floating point numbers (default is -1, the default for sprintf) }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for building a JSON string. \par
}{
Definition at line 910 of file JsonParserGeneratorRK.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v JsonWriter\:JsonWriter}
{\xe \v JsonWriter\:JsonWriter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
JsonWriter::JsonWriter ()}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b JsonWriter} with a dynamically allocated buffer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The buffer will be resized as necessary but you can improve efficiency by using the {\b allocate()} method of {\b JsonBuffer} to pre-allocate space rather than have to incrementally make it bigger as it's written to.\par
Use {\b getBuffer()} to get the pointer to the buffer and {\b getOffset()} to get the buffer pointer and size. The buffer is not null-terminated! \par
}{
Definition at line 655 of file JsonParserGeneratorRK.cpp.}\par
{
References floatPlaces, init(), and JsonBuffer::JsonBuffer().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   655                        : JsonBuffer(), floatPlaces(-1) \{\par
  656     init();\par
  657 \}\par
}
}
{\xe \v ~JsonWriter\:JsonWriter}
{\xe \v JsonWriter\:~JsonWriter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
JsonWriter::~JsonWriter (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroy the object. If the buffer was dynamically allocated it will be freed. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the buffer was passed in using the buffer, bufferLen constructor the buffer is not freed by this call as it's likely statically allocated. \par
}{
Definition at line 659 of file JsonParserGeneratorRK.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   659                         \{\par
  660 \par
  661 \}\par
}
}
{\xe \v JsonWriter\:JsonWriter}
{\xe \v JsonWriter\:JsonWriter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
JsonWriter::JsonWriter (char *  {\i buffer}, size_t  {\i bufferLen})}}
\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b JsonWriter} to write to a static buffer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buffer} \cell }{Pointer to the buffer\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bufferLen} \cell }{Length of the buffer in bytes \cell }
{\row }
}
}{
Definition at line 663 of file JsonParserGeneratorRK.cpp.}\par
{
References floatPlaces, init(), and JsonBuffer::JsonBuffer().}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   663                                                      : JsonBuffer(buffer, bufferLen), floatPlaces(-1) \{\par
  664     init();\par
  665 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v finishObjectOrArray\:JsonWriter}
{\xe \v JsonWriter\:finishObjectOrArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonWriter::finishObjectOrArray ()}}
\par
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finsh an object or array started with {\b startObject()} or {\b startArray()} }}\par
{
Definition at line 695 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonBuffer::buffer, JsonBuffer::bufferLen, context, contextIndex, insertChar(), JsonBuffer::offset, and JsonWriterContext::terminator.}\par
{
Referenced by insertKeyArray(), insertKeyVector(), main(), JsonWriterAutoArray::~JsonWriterAutoArray(), and JsonWriterAutoObject::~JsonWriterAutoObject().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   695                                      \{\par
  696     if (contextIndex > 0) \{\par
  697         if (context[contextIndex].terminator != 0) \{\par
  698             insertChar(context[contextIndex].terminator);\par
  699         \}\par
  700         contextIndex--;\par
  701     \}\par
  702     // Make sure buffer is null terminated\par
  703     if (offset < bufferLen) \{\par
  704         buffer[offset] = 0;\par
  705     \}\par
  706     else \{\par
  707         buffer[bufferLen - 1] = 0;\par
  708     \}\par
  709 \}\par
}
}
{\xe \v init\:JsonWriter}
{\xe \v JsonWriter\:init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonWriter::init ()}}
\par
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reset the writer, clearing all data. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
You do not need to call {\b init()} as it's called from the two constructors. You can call it again if you want to reset the writer and reuse it, such as when you use {\b JsonWriterStatic} in a global variable. \par
}{
Definition at line 667 of file JsonParserGeneratorRK.cpp.}\par
{
References context, contextIndex, JsonWriterContext::isFirst, JsonBuffer::offset, JsonWriterContext::terminator, and truncated.}\par
{
Referenced by JsonWriter(), JsonModifier::startAppend(), and JsonModifier::startModify().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   667                       \{\par
  668     // Save start of insertion point for later\par
  669     offset = 0;\par
  670 \par
  671     contextIndex = 0;\par
  672     context[contextIndex].isFirst = true;\par
  673     context[contextIndex].terminator = 0;\par
  674 \par
  675     truncated = false;\par
  676 \par
  677 \}\par
}
}
{\xe \v insertArray\:JsonWriter}
{\xe \v JsonWriter\:insertArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void JsonWriter::insertArray (T *  {\i pArray}, size_t  {\i numElem}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts an array of values into an array. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Uses templates so you can pass any type object that's supported by {\b insertValue()} overloads, for example: bool, int, float, double, const char *. \par
}{
Definition at line 1091 of file JsonParserGeneratorRK.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1091                                                 \{\par
 1092         for(size_t ii = 0; ii < numElem; ii++) \{\par
 1093             insertArrayValue(pArray[ii]);\par
 1094         \}\par
 1095     \}\par
}
}
{\xe \v insertArrayValue\:JsonWriter}
{\xe \v JsonWriter\:insertArrayValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void JsonWriter::insertArrayValue (T  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a value into an array. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Uses templates so you can pass any type object that's supported by {\b insertValue()} overloads, for example: bool, int, float, double, const char *. \par
}{
Definition at line 1079 of file JsonParserGeneratorRK.h.}\par
{
References insertCheckSeparator().}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1079                                    \{\par
 1080         insertCheckSeparator();\par
 1081         insertValue(value);\par
 1082     \}\par
}
}
{\xe \v insertChar\:JsonWriter}
{\xe \v JsonWriter\:insertChar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonWriter::insertChar (char  {\i ch})}}
\par
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally to insert a character. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally. You should use {\b insertKeyValue()} or {\b insertArrayValue()} with a string instead. \par
}{
Definition at line 712 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonBuffer::buffer, JsonBuffer::bufferLen, JsonBuffer::offset, and truncated.}\par
{
Referenced by finishObjectOrArray(), insertCheckSeparator(), insertKeyArray(), insertKeyObject(), insertKeyValue(), insertString(), and startObjectOrArray().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   712                                    \{\par
  713     if (offset < bufferLen) \{\par
  714         buffer[offset++] = ch;\par
  715     \}\par
  716     else \{\par
  717         truncated = true;\par
  718     \}\par
  719 \}\par
}
}
{\xe \v insertCheckSeparator\:JsonWriter}
{\xe \v JsonWriter\:insertCheckSeparator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonWriter::insertCheckSeparator ()}}
\par
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check to see if a separator needs to be inserted. Used internally. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
You normally don't need to use this as it's called by {\b insertKeyValue()} and {\b insertArrayValue()}. \par
}{
Definition at line 823 of file JsonParserGeneratorRK.cpp.}\par
{
References context, contextIndex, insertChar(), and JsonWriterContext::isFirst.}\par
{
Referenced by insertArrayValue(), insertKeyArray(), insertKeyObject(), insertKeyValue(), main(), and startObjectOrArray().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   823                                       \{\par
  824     if (context[contextIndex].isFirst) \{\par
  825         context[contextIndex].isFirst = false;\par
  826     \}\par
  827     else \{\par
  828         insertChar(',');\par
  829     \}\par
  830 \}\par
}
}
{\xe \v insertKeyArray\:JsonWriter}
{\xe \v JsonWriter\:insertKeyArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonWriter::insertKeyArray (const char *  {\i key})}}
\par
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a new key and empty array. You must close the object using {\b finishObjectOrArray()}! }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i key} \cell }{the key name to insert \cell }
{\row }
}
}{
Definition at line 867 of file JsonParserGeneratorRK.cpp.}\par
{
References insertChar(), insertCheckSeparator(), insertValue(), setIsFirst(), and startArray().}\par
{
Referenced by insertKeyArray(), insertKeyVector(), and main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   867                                                \{\par
  868     insertCheckSeparator();\par
  869     insertValue(key);\par
  870     insertChar(':');\par
  871     setIsFirst();\par
  872     startArray();\par
  873 \}\par
}
}
{\xe \v insertKeyArray\:JsonWriter}
{\xe \v JsonWriter\:insertKeyArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void JsonWriter::insertKeyArray (const char *  {\i key}, T *  {\i pArray}, size_t  {\i numElem}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a new key and vector of values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i key} \cell }{the key name to insert\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{the vector to insert \cell }
{\row }
}
}{
Definition at line 1105 of file JsonParserGeneratorRK.h.}\par
{
References finishObjectOrArray(), and insertKeyArray().}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1105                                                                     \{\par
 1106         insertKeyArray(key);\par
 1107         insertArray(pArray, numElem);\par
 1108         finishObjectOrArray();\par
 1109     \}\par
}
}
{\xe \v insertKeyObject\:JsonWriter}
{\xe \v JsonWriter\:insertKeyObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonWriter::insertKeyObject (const char *  {\i key})}}
\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a new key and empty object. You must close the object using {\b finishObjectOrArray()}! }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i key} \cell }{the key name to insert \cell }
{\row }
}
}{
Definition at line 859 of file JsonParserGeneratorRK.cpp.}\par
{
References insertChar(), insertCheckSeparator(), insertValue(), setIsFirst(), and startObject().}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   859                                                 \{\par
  860     insertCheckSeparator();\par
  861     insertValue(key);\par
  862     insertChar(':');\par
  863     setIsFirst();\par
  864     startObject();\par
  865 \}\par
}
}
{\xe \v insertKeyValue\:JsonWriter}
{\xe \v JsonWriter\:insertKeyValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void JsonWriter::insertKeyValue (const char *  {\i key}, T  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a key/value pair into an object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Uses templates so you can pass any type object that's supported by {\b insertValue()} overloads, for example: bool, int, float, double, const char *. \par
}{
Definition at line 1065 of file JsonParserGeneratorRK.h.}\par
{
References insertChar(), insertCheckSeparator(), and insertValue().}\par
{
Referenced by main(), and runTest().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1065                                                   \{\par
 1066         insertCheckSeparator();\par
 1067         insertValue(key);\par
 1068         insertChar(':');\par
 1069         insertValue(value);\par
 1070     \}\par
}
}
{\xe \v insertKeyVector\:JsonWriter}
{\xe \v JsonWriter\:insertKeyVector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void JsonWriter::insertKeyVector (const char *  {\i key}, std::vector< T >  {\i vec}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a new key and vector of values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i key} \cell }{the key name to insert\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vec} \cell }{the vector to insert \cell }
{\row }
}
}{
Definition at line 1132 of file JsonParserGeneratorRK.h.}\par
{
References finishObjectOrArray(), and insertKeyArray().}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1132                                                             \{\par
 1133         insertKeyArray(key);\par
 1134         insertVector(vec);\par
 1135         finishObjectOrArray();\par
 1136     \}\par
}
}
{\xe \v insertsprintf\:JsonWriter}
{\xe \v JsonWriter\:insertsprintf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonWriter::insertsprintf (const char *  {\i fmt},   {\i ...})}}
\par
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally to insert using snprintf formatting. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally. You should use {\b insertKeyValue()} or {\b insertArrayValue()} with a string, float, or double instead.\par
This method does not quote or escape the string - it's used mainly for formatting numbers. \par
}{
Definition at line 802 of file JsonParserGeneratorRK.cpp.}\par
{
References insertvsprintf().}\par
{
Referenced by insertString(), insertValue(), and main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   802                                                    \{\par
  803     va_list ap;\par
  804     va_start(ap, fmt);\par
  805     insertvsprintf(fmt, ap);\par
  806     va_end(ap);\par
  807 \}\par
}
}
{\xe \v insertString\:JsonWriter}
{\xe \v JsonWriter\:insertString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonWriter::insertString (const char *  {\i s}, bool  {\i quoted} = {\f2 false})}}
\par
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally to insert a string, quoted or not. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally. You should use {\b insertKeyValue()} or {\b insertArrayValue()} with a string instead. \par
}{
Definition at line 721 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonBuffer::bufferLen, insertChar(), insertsprintf(), and JsonBuffer::offset.}\par
{
Referenced by insertValue(), and main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   721                                                         \{\par
  722     // 0x00000000 - 0x0000007F:\par
  723 \par
  724     // 0x00000080 - 0x000007FF:\par
  725     // 110xxxxx 10xxxxxx\par
  726 \par
  727     // 0x00000800 - 0x0000FFFF:\par
  728     // 1110xxxx 10xxxxxx 10xxxxxx\par
  729 \par
  730     if (quoted) \{\par
  731         insertChar('"');\par
  732     \}\par
  733 \par
  734     for(size_t ii = 0; s[ii] && offset < bufferLen; ii++) \{\par
  735         if (s[ii] & 0x80) \{\par
  736             // High bit set: convert UTF-8 to JSON Unicode escape\par
  737             if (((s[ii] & 0b11110000) == 0b11100000) && ((s[ii+1] & 0b11000000) == 0b10000000) && ((s[ii+2] & 0b11000000) == 0b10000000)) \{\par
  738                 // 3-byte\par
  739                 uint16_t utf16 = ((s[ii] & 0b1111) << 12) | ((s[ii+1] & 0b111111) << 6) | (s[ii+2] & 0b111111);\par
  740                 insertsprintf("\\\\u%04X", utf16);\par
  741                 ii += 2; // plus one more in loop increment\par
  742             \}\par
  743             else\par
  744             if (((s[ii] & 0b11100000) == 0b11000000) && ((s[ii+1] & 0b11000000) == 0b10000000)) \{\par
  745                 // 2-byte\par
  746                 uint16_t utf16 = ((s[ii] & 0b11111) << 6) | (s[ii+1] & 0b111111);\par
  747                 insertsprintf("\\\\u%04X", utf16);\par
  748                 ii++; // plus one more in loop increment\par
  749             \}\par
  750             else \{\par
  751                 // Not valid unicode, just pass characters through\par
  752                 insertChar(s[ii]);\par
  753             \}\par
  754         \}\par
  755         else \{\par
  756             switch(s[ii]) \{\par
  757             case '\\b':\par
  758                 insertChar('\\\\');\par
  759                 insertChar('b');\par
  760                 break;\par
  761 \par
  762             case '\\f':\par
  763                 insertChar('\\\\');\par
  764                 insertChar('f');\par
  765                 break;\par
  766 \par
  767             case '\\n':\par
  768                 insertChar('\\\\');\par
  769                 insertChar('n');\par
  770                 break;\par
  771 \par
  772             case '\\r':\par
  773                 insertChar('\\\\');\par
  774                 insertChar('r');\par
  775                 break;\par
  776 \par
  777             case '\\t':\par
  778                 insertChar('\\\\');\par
  779                 insertChar('t');\par
  780                 break;\par
  781 \par
  782             case '"':\par
  783             case '\\\\':\par
  784                 insertChar('\\\\');\par
  785                 insertChar(s[ii]);\par
  786                 break;\par
  787 \par
  788             default:\par
  789                 insertChar(s[ii]);\par
  790                 break;\par
  791             \}\par
  792         \}\par
  793     \}\par
  794     if (quoted) \{\par
  795         insertChar('"');\par
  796     \}\par
  797 \par
  798 \}\par
}
}
{\xe \v insertValue\:JsonWriter}
{\xe \v JsonWriter\:insertValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonWriter::insertValue (bool  {\i value})}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a boolean value ("true" or "false"). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
You would normally use {\b insertKeyValue()} or {\b insertArrayValue()} instead of calling this directly as those functions take care of inserting the separtators between items. \par
}{
Definition at line 832 of file JsonParserGeneratorRK.cpp.}\par
{
References insertString().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   832                                        \{\par
  833     if (value) \{\par
  834         insertString("true");\par
  835     \}\par
  836     else \{\par
  837         insertString("false");\par
  838     \}\par
  839 \}\par
}
}
{\xe \v insertValue\:JsonWriter}
{\xe \v JsonWriter\:insertValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonWriter::insertValue (int  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts an integer value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
You would normally use {\b insertKeyValue()} or {\b insertArrayValue()} instead of calling this directly as those functions take care of inserting the separators between items. \par
}{
Definition at line 979 of file JsonParserGeneratorRK.h.}\par
{
References insertsprintf().}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   979 \{ insertsprintf("%d", value); \}\par
}
}
{\xe \v insertValue\:JsonWriter}
{\xe \v JsonWriter\:insertValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonWriter::insertValue (unsigned int  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts an unsigned integer value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
You would normally use {\b insertKeyValue()} or {\b insertArrayValue()} instead of calling this directly as those functions take care of inserting the separators between items. \par
}{
Definition at line 987 of file JsonParserGeneratorRK.h.}\par
{
References insertsprintf().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   987 \{ insertsprintf("%u", value); \}\par
}
}
{\xe \v insertValue\:JsonWriter}
{\xe \v JsonWriter\:insertValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonWriter::insertValue (long  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a long integer value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
You would normally use {\b insertKeyValue()} or {\b insertArrayValue()} instead of calling this directly as those functions take care of inserting the separators between items. \par
}{
Definition at line 995 of file JsonParserGeneratorRK.h.}\par
{
References insertsprintf().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   995 \{ insertsprintf("%ld", value); \}\par
}
}
{\xe \v insertValue\:JsonWriter}
{\xe \v JsonWriter\:insertValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonWriter::insertValue (unsigned long  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts an unsigned long integer value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
You would normally use {\b insertKeyValue()} or {\b insertArrayValue()} instead of calling this directly as those functions take care of inserting the separators between items. \par
}{
Definition at line 1003 of file JsonParserGeneratorRK.h.}\par
{
References insertsprintf().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1003 \{ insertsprintf("%lu", value); \}\par
}
}
{\xe \v insertValue\:JsonWriter}
{\xe \v JsonWriter\:insertValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonWriter::insertValue (float  {\i value})}}
\par
{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a floating point value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Use {\b setFloatPlaces()} to set the number of decimal places to include.\par
You would normally use {\b insertKeyValue()} or {\b insertArrayValue()} instead of calling this directly as those functions take care of inserting the separtators between items. \par
}{
Definition at line 841 of file JsonParserGeneratorRK.cpp.}\par
{
References floatPlaces, and insertsprintf().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   841                                         \{\par
  842     if (floatPlaces >= 0) \{\par
  843         insertsprintf("%.*f", floatPlaces, value);\par
  844     \}\par
  845     else \{\par
  846         insertsprintf("%f", value);\par
  847     \}\par
  848 \}\par
}
}
{\xe \v insertValue\:JsonWriter}
{\xe \v JsonWriter\:insertValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonWriter::insertValue (double  {\i value})}}
\par
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a floating point double value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Use {\b setFloatPlaces()} to set the number of decimal places to include.\par
You would normally use {\b insertKeyValue()} or {\b insertArrayValue()} instead of calling this directly as those functions take care of inserting the separtators between items. \par
}{
Definition at line 849 of file JsonParserGeneratorRK.cpp.}\par
{
References floatPlaces, and insertsprintf().}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   849                                          \{\par
  850     if (floatPlaces >= 0) \{\par
  851         insertsprintf("%.*lf", floatPlaces, value);\par
  852     \}\par
  853     else \{\par
  854         insertsprintf("%lf", value);\par
  855     \}\par
  856 \}\par
}
}
{\xe \v insertValue\:JsonWriter}
{\xe \v JsonWriter\:insertValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonWriter::insertValue (const char *  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a quoted string value. This escapes special characters and encodes utf-8. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
You would normally use {\b insertKeyValue()} or {\b insertArrayValue()} instead of calling this directly as those functions take care of inserting the separtators between items. \par
}{
Definition at line 1031 of file JsonParserGeneratorRK.h.}\par
{
References insertString().}\par
{
Referenced by insertKeyArray(), insertKeyObject(), and insertKeyValue().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1031 \{ insertString(value, true); \}\par
}
}
{\xe \v insertValue\:JsonWriter}
{\xe \v JsonWriter\:insertValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonWriter::insertValue (const {\b String} &  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a quoted string value. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This escapes special characters and encodes utf-8. See also the version that takes a plain const char *.\par
You would normally use {\b insertKeyValue()} or {\b insertArrayValue()} instead of calling this directly as those functions take care of inserting the separtators between items. \par
}{
Definition at line 1042 of file JsonParserGeneratorRK.h.}\par
{
References String::c_str(), and insertString().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1042 \{ insertString(value.c_str(), true); \}\par
}
}
{\xe \v insertVector\:JsonWriter}
{\xe \v JsonWriter\:insertVector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void JsonWriter::insertVector (std::vector< T >  {\i vec}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts an array of values into an array. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Uses templates so you can pass any type object that's supported by {\b insertValue()} overloads, for example: bool, int, float, double, const char *. \par
}{
Definition at line 1118 of file JsonParserGeneratorRK.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1118                                         \{\par
 1119         for (auto it = vec.begin(); it != vec.end(); ++it) \{\par
 1120             insertArrayValue(*it);\par
 1121         \}\par
 1122     \}\par
}
}
{\xe \v insertvsprintf\:JsonWriter}
{\xe \v JsonWriter\:insertvsprintf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonWriter::insertvsprintf (const char *  {\i fmt}, va_list  {\i ap})}}
\par
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally to insert using snprintf formatting with a va_list. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally. You should use {\b insertKeyValue()} or {\b insertArrayValue()} with a string, float, or double instead.\par
This method does not quote or escape the string - it's used mainly for formatting numbers. \par
}{
Definition at line 809 of file JsonParserGeneratorRK.cpp.}\par
{
References JsonBuffer::buffer, JsonBuffer::bufferLen, JsonBuffer::offset, and truncated.}\par
{
Referenced by insertsprintf().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   809                                                            \{\par
  810     size_t spaceAvailable = bufferLen - offset;\par
  811 \par
  812     size_t count = vsnprintf(&buffer[offset], spaceAvailable, fmt, ap);\par
  813     if (count <= spaceAvailable) \{\par
  814         offset += count;\par
  815     \}\par
  816     else \{\par
  817         // Truncated, no more space left\par
  818         offset = bufferLen;\par
  819         truncated = true;\par
  820     \}\par
  821 \}\par
}
}
{\xe \v isTruncated\:JsonWriter}
{\xe \v JsonWriter\:isTruncated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonWriter::isTruncated () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If you try to insert more data than will fit in the buffer, the isTruncated flag will be set, and the buffer will likely not be valid JSON and should not be used. \par
}{
Definition at line 1142 of file JsonParserGeneratorRK.h.}\par
{
References truncated.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1142 \{ return truncated; \}\par
}
}
{\xe \v setFloatPlaces\:JsonWriter}
{\xe \v JsonWriter\:setFloatPlaces}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonWriter::setFloatPlaces (int  {\i floatPlaces}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the number of digits for formatting float and double values. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i floatPlaces} \cell }{The number of decimal places for float and double. Set it to -1 to use the default for snprintf. -1 is the default value if you don't call setFloatPlaces. \cell }
{\row }
}
}{
Definition at line 1150 of file JsonParserGeneratorRK.h.}\par
{
References floatPlaces.}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1150 \{ this->floatPlaces = floatPlaces; \}\par
}
}
{\xe \v setIsFirst\:JsonWriter}
{\xe \v JsonWriter\:setIsFirst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JsonWriter::setIsFirst (bool  {\i isFirst} = {\f2 true})}}
\par
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally to set the current isFirst flag in the context. }}\par
{
Definition at line 875 of file JsonParserGeneratorRK.cpp.}\par
{
References context, contextIndex, and JsonWriterContext::isFirst.}\par
{
Referenced by insertKeyArray(), insertKeyObject(), and JsonModifier::startAppend().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   875                                           \{\par
  876     context[contextIndex].isFirst = isFirst;\par
  877 \}\par
}
}
{\xe \v startArray\:JsonWriter}
{\xe \v JsonWriter\:startArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonWriter::startArray (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start a new JSON array. Make sure you finish it with {\b finishObjectOrArray()} }}\par
{
Definition at line 958 of file JsonParserGeneratorRK.h.}\par
{
References startObjectOrArray().}\par
{
Referenced by insertKeyArray(), JsonWriterAutoArray::JsonWriterAutoArray(), and main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   958 \{ return startObjectOrArray('[', ']'); \};\par
}
}
{\xe \v startObject\:JsonWriter}
{\xe \v JsonWriter\:startObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonWriter::startObject (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start a new JSON object. Make sure you finish it with {\b finishObjectOrArray()} }}\par
{
Definition at line 953 of file JsonParserGeneratorRK.h.}\par
{
References startObjectOrArray().}\par
{
Referenced by insertKeyObject(), JsonWriterAutoObject::JsonWriterAutoObject(), and main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   953 \{ return startObjectOrArray('\{', '\}'); \};\par
}
}
{\xe \v startObjectOrArray\:JsonWriter}
{\xe \v JsonWriter\:startObjectOrArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonWriter::startObjectOrArray (char  {\i startChar}, char  {\i endChar})}}
\par
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally to start an object or array. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally; you should use {\b startObject()} or {\b startArray()} instead. Make sure you finish any started object or array using {\b finishObjectOrArray()}. \par
}{
Definition at line 679 of file JsonParserGeneratorRK.cpp.}\par
{
References context, contextIndex, insertChar(), insertCheckSeparator(), JsonWriterContext::isFirst, MAX_NESTED_CONTEXT, and JsonWriterContext::terminator.}\par
{
Referenced by startArray(), and startObject().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   679                                                                 \{\par
  680     if ((contextIndex + 1) >= MAX_NESTED_CONTEXT) \{\par
  681         return false;\par
  682     \}\par
  683     insertCheckSeparator();\par
  684 \par
  685     contextIndex++;\par
  686 \par
  687     context[contextIndex].isFirst = true;\par
  688     context[contextIndex].terminator = endChar;\par
  689 \par
  690     insertChar(startChar);\par
  691     return true;\par
  692 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v context\:JsonWriter}
{\xe \v JsonWriter\:context}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b JsonWriterContext} JsonWriter::context[{\b MAX_NESTED_CONTEXT}]{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure for managing nested objects. }}\par
{
Definition at line 1217 of file JsonParserGeneratorRK.h.}\par
{
Referenced by finishObjectOrArray(), init(), insertCheckSeparator(), setIsFirst(), and startObjectOrArray().}\par
}
{\xe \v contextIndex\:JsonWriter}
{\xe \v JsonWriter\:contextIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t JsonWriter::contextIndex{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Index into the context for the current level of nesting. }}\par
{
Definition at line 1216 of file JsonParserGeneratorRK.h.}\par
{
Referenced by finishObjectOrArray(), init(), insertCheckSeparator(), setIsFirst(), and startObjectOrArray().}\par
}
{\xe \v floatPlaces\:JsonWriter}
{\xe \v JsonWriter\:floatPlaces}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int JsonWriter::floatPlaces{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
default number of places to display for floating point numbers (default is -1, the default for sprintf) }}\par
{
Definition at line 1219 of file JsonParserGeneratorRK.h.}\par
{
Referenced by insertValue(), JsonWriter(), and setFloatPlaces().}\par
}
{\xe \v MAX_NESTED_CONTEXT\:JsonWriter}
{\xe \v JsonWriter\:MAX_NESTED_CONTEXT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const size_t JsonWriter::MAX_NESTED_CONTEXT = 9{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This constant is the maximum number of nested objects that are supported; the actual number is one less than this so when set to 9 you can have eight objects nested in each other.\par
Overhead is 8 bytes per nested context, so 9 elements is 72 bytes. \par
}{
Definition at line 1213 of file JsonParserGeneratorRK.h.}\par
{
Referenced by startObjectOrArray().}\par
}
{\xe \v truncated\:JsonWriter}
{\xe \v JsonWriter\:truncated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonWriter::truncated{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
true if data was added that didn't fit and was truncated }}\par
{
Definition at line 1218 of file JsonParserGeneratorRK.h.}\par
{
Referenced by init(), insertChar(), insertvsprintf(), and isTruncated().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/src/{\b JsonParserGeneratorRK.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/src/{\b JsonParserGeneratorRK.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
JsonWriterAutoArray Class Reference\par \pard\plain 
{\tc\tcl2 \v JsonWriterAutoArray}
{\xe \v JsonWriterAutoArray}
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for creating a JSON array with {\b JsonWriter}. }}\par
{
{\f2 #include <JsonParserGeneratorRK.h>}}\par
Collaboration diagram for JsonWriterAutoArray:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_json_writer_auto_array__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonWriterAutoArray} ({\b JsonWriter} *{\b jw})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start a new array. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~JsonWriterAutoArray} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
End the array. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonWriter} * {\b jw}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b JsonWriter} to write to. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for creating a JSON array with {\b JsonWriter}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When you create an object, you must call startArray() to start and finishObjectOrArray() to complete it.\par
This class is instantiated on the stack to automatically start and finish for you. \par
}{
Definition at line 1285 of file JsonParserGeneratorRK.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v JsonWriterAutoArray\:JsonWriterAutoArray}
{\xe \v JsonWriterAutoArray\:JsonWriterAutoArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
JsonWriterAutoArray::JsonWriterAutoArray ({\b JsonWriter} *  {\i jw}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start a new array. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i jw} \cell }{The {\b JsonWriter} object to insert the array into \cell }
{\row }
}
}{
Definition at line 1292 of file JsonParserGeneratorRK.h.}\par
{
References jw, and JsonWriter::startArray().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1292                                         : jw(jw) \{\par
 1293         jw->startArray();\par
 1294     \}\par
}
}
{\xe \v ~JsonWriterAutoArray\:JsonWriterAutoArray}
{\xe \v JsonWriterAutoArray\:~JsonWriterAutoArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
JsonWriterAutoArray::~JsonWriterAutoArray (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
End the array. }}\par
{
Definition at line 1299 of file JsonParserGeneratorRK.h.}\par
{
References JsonWriter::finishObjectOrArray(), and jw.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1299                            \{\par
 1300         jw->finishObjectOrArray();\par
 1301     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v jw\:JsonWriterAutoArray}
{\xe \v JsonWriterAutoArray\:jw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b JsonWriter}* JsonWriterAutoArray::jw{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b JsonWriter} to write to. }}\par
{
Definition at line 1304 of file JsonParserGeneratorRK.h.}\par
{
Referenced by JsonWriterAutoArray(), and ~JsonWriterAutoArray().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/src/{\b JsonParserGeneratorRK.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
JsonWriterAutoObject Class Reference\par \pard\plain 
{\tc\tcl2 \v JsonWriterAutoObject}
{\xe \v JsonWriterAutoObject}
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for creating a JSON object with {\b JsonWriter}. }}\par
{
{\f2 #include <JsonParserGeneratorRK.h>}}\par
Collaboration diagram for JsonWriterAutoObject:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_json_writer_auto_object__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonWriterAutoObject} ({\b JsonWriter} *{\b jw})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start a new object. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~JsonWriterAutoObject} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
End the object. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonWriter} * {\b jw}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b JsonWriter} to write to. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for creating a JSON object with {\b JsonWriter}. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
When you create an object, you must call startObject() to start and finishObjectOrArray() to complete it.\par
This class is instantiated on the stack to automatically start and finish for you. \par
}{
Definition at line 1256 of file JsonParserGeneratorRK.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v JsonWriterAutoObject\:JsonWriterAutoObject}
{\xe \v JsonWriterAutoObject\:JsonWriterAutoObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
JsonWriterAutoObject::JsonWriterAutoObject ({\b JsonWriter} *  {\i jw}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Start a new object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i jw} \cell }{The {\b JsonWriter} object to insert the object into \cell }
{\row }
}
}{
Definition at line 1263 of file JsonParserGeneratorRK.h.}\par
{
References jw, and JsonWriter::startObject().}\par
{
Referenced by runTest().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1263                                          : jw(jw) \{\par
 1264         jw->startObject();\par
 1265     \}\par
}
}
{\xe \v ~JsonWriterAutoObject\:JsonWriterAutoObject}
{\xe \v JsonWriterAutoObject\:~JsonWriterAutoObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
JsonWriterAutoObject::~JsonWriterAutoObject (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
End the object. }}\par
{
Definition at line 1270 of file JsonParserGeneratorRK.h.}\par
{
References JsonWriter::finishObjectOrArray(), and jw.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1270                             \{\par
 1271         jw->finishObjectOrArray();\par
 1272     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v jw\:JsonWriterAutoObject}
{\xe \v JsonWriterAutoObject\:jw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b JsonWriter}* JsonWriterAutoObject::jw{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b JsonWriter} to write to. }}\par
{
Definition at line 1275 of file JsonParserGeneratorRK.h.}\par
{
Referenced by JsonWriterAutoObject(), and ~JsonWriterAutoObject().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/src/{\b JsonParserGeneratorRK.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
JsonWriterContext Struct Reference\par \pard\plain 
{\tc\tcl2 \v JsonWriterContext}
{\xe \v JsonWriterContext}
{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally by {\b JsonWriter}. }}\par
{
{\f2 #include <JsonParserGeneratorRK.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isFirst}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
True if this the first element in this object or array and doesn't need a comma before it. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b terminator}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The character that will terminate the object or array when ended. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally by {\b JsonWriter}. \par
}{
Definition at line 902 of file JsonParserGeneratorRK.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v isFirst\:JsonWriterContext}
{\xe \v JsonWriterContext\:isFirst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JsonWriterContext::isFirst}}
\par
{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
True if this the first element in this object or array and doesn't need a comma before it. }}\par
{
Definition at line 903 of file JsonParserGeneratorRK.h.}\par
{
Referenced by JsonWriter::init(), JsonWriter::insertCheckSeparator(), JsonWriter::setIsFirst(), and JsonWriter::startObjectOrArray().}\par
}
{\xe \v terminator\:JsonWriterContext}
{\xe \v JsonWriterContext\:terminator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char JsonWriterContext::terminator}}
\par
{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The character that will terminate the object or array when ended. }}\par
{
Definition at line 904 of file JsonParserGeneratorRK.h.}\par
{
Referenced by JsonWriter::finishObjectOrArray(), JsonWriter::init(), and JsonWriter::startObjectOrArray().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/src/{\b JsonParserGeneratorRK.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
JsonWriterStatic< BUFFER_SIZE > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v JsonWriterStatic< BUFFER_SIZE >}
{\xe \v JsonWriterStatic< BUFFER_SIZE >}
{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a {\b JsonWriter} with a statically allocated buffer. }}\par
{
{\f2 #include <JsonParserGeneratorRK.h>}}\par
Inheritance diagram for JsonWriterStatic< BUFFER_SIZE >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_json_writer_static__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for JsonWriterStatic< BUFFER_SIZE >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_json_writer_static__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonWriterStatic} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b staticBuffer} [BUFFER_SIZE]\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
static buffer to write to }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<size_t BUFFER_SIZE>\par
class JsonWriterStatic< BUFFER_SIZE >\par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a {\b JsonWriter} with a statically allocated buffer. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
You typically do this when you want to create a buffer as a global variable.\par
Example:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid JsonWriterStatic<256> jsonWriter;\par
}
\par
Creates a 256 byte buffer to write JSON to. You'd normally do this as a global variable, but for smaller buffers (256 and smaller should be fine) in the loop thread, you can allocate one on the stack as a local variable.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s60\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i BUFFER_SIZE} \cell }{The size of the buffer to reserve. \cell }
{\row }
}
}{
Definition at line 1241 of file JsonParserGeneratorRK.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v JsonWriterStatic\:JsonWriterStatic}
{\xe \v JsonWriterStatic\:JsonWriterStatic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<size_t BUFFER_SIZE> {\b JsonWriterStatic}< BUFFER_SIZE >::{\b JsonWriterStatic} (){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1243 of file JsonParserGeneratorRK.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1243 : JsonWriter(staticBuffer, BUFFER_SIZE) \{\};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v staticBuffer\:JsonWriterStatic}
{\xe \v JsonWriterStatic\:staticBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<size_t BUFFER_SIZE> char {\b JsonWriterStatic}< BUFFER_SIZE >::staticBuffer[BUFFER_SIZE]{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
static buffer to write to }}\par
{
Definition at line 1243 of file JsonParserGeneratorRK.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/src/{\b JsonParserGeneratorRK.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MFRC522 Class Reference\par \pard\plain 
{\tc\tcl2 \v MFRC522}
{\xe \v MFRC522}
{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
\par
{
{\f2 #include <MFRC522.h>}}\par
Collaboration diagram for MFRC522:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_f_r_c522__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MIFARE_Key}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Uid}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b PCD_Register} \{ {\b CommandReg} = 0x01 << 1, 
{\b ComIEnReg} = 0x02 << 1, 
{\b DivIEnReg} = 0x03 << 1, 
{\b ComIrqReg} = 0x04 << 1, 
{\b DivIrqReg} = 0x05 << 1, 
{\b ErrorReg} = 0x06 << 1, 
{\b Status1Reg} = 0x07 << 1, 
{\b Status2Reg} = 0x08 << 1, 
{\b FIFODataReg} = 0x09 << 1, 
{\b FIFOLevelReg} = 0x0A << 1, 
{\b WaterLevelReg} = 0x0B << 1, 
{\b ControlReg} = 0x0C << 1, 
{\b BitFramingReg} = 0x0D << 1, 
{\b CollReg} = 0x0E << 1, 
{\b ModeReg} = 0x11 << 1, 
{\b TxModeReg} = 0x12 << 1, 
{\b RxModeReg} = 0x13 << 1, 
{\b TxControlReg} = 0x14 << 1, 
{\b TxASKReg} = 0x15 << 1, 
{\b TxSelReg} = 0x16 << 1, 
{\b RxSelReg} = 0x17 << 1, 
{\b RxThresholdReg} = 0x18 << 1, 
{\b DemodReg} = 0x19 << 1, 
{\b MfTxReg} = 0x1C << 1, 
{\b MfRxReg} = 0x1D << 1, 
{\b SerialSpeedReg} = 0x1F << 1, 
{\b CRCResultRegH} = 0x21 << 1, 
{\b CRCResultRegL} = 0x22 << 1, 
{\b ModWidthReg} = 0x24 << 1, 
{\b RFCfgReg} = 0x26 << 1, 
{\b GsNReg} = 0x27 << 1, 
{\b CWGsPReg} = 0x28 << 1, 
{\b ModGsPReg} = 0x29 << 1, 
{\b TModeReg} = 0x2A << 1, 
{\b TPrescalerReg} = 0x2B << 1, 
{\b TReloadRegH} = 0x2C << 1, 
{\b TReloadRegL} = 0x2D << 1, 
{\b TCounterValueRegH} = 0x2E << 1, 
{\b TCounterValueRegL} = 0x2F << 1, 
{\b TestSel1Reg} = 0x31 << 1, 
{\b TestSel2Reg} = 0x32 << 1, 
{\b TestPinEnReg} = 0x33 << 1, 
{\b TestPinValueReg} = 0x34 << 1, 
{\b TestBusReg} = 0x35 << 1, 
{\b AutoTestReg} = 0x36 << 1, 
{\b VersionReg} = 0x37 << 1, 
{\b AnalogTestReg} = 0x38 << 1, 
{\b TestDAC1Reg} = 0x39 << 1, 
{\b TestDAC2Reg} = 0x3A << 1, 
{\b TestADCReg} = 0x3B << 1
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b PCD_Command} \{ {\b PCD_Idle} = 0x00, 
{\b PCD_Mem} = 0x01, 
{\b PCD_GenerateRandomID} = 0x02, 
{\b PCD_CalcCRC} = 0x03, 
{\b PCD_Transmit} = 0x04, 
{\b PCD_NoCmdChange} = 0x07, 
{\b PCD_Receive} = 0x08, 
{\b PCD_Transceive} = 0x0C, 
{\b PCD_MFAuthent} = 0x0E, 
{\b PCD_SoftReset} = 0x0F
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b PCD_RxGain} \{ {\b RxGain_18dB} = 0x00 << 4, 
{\b RxGain_23dB} = 0x01 << 4, 
{\b RxGain_18dB_2} = 0x02 << 4, 
{\b RxGain_23dB_2} = 0x03 << 4, 
{\b RxGain_33dB} = 0x04 << 4, 
{\b RxGain_38dB} = 0x05 << 4, 
{\b RxGain_43dB} = 0x06 << 4, 
{\b RxGain_48dB} = 0x07 << 4, 
{\b RxGain_min} = 0x00 << 4, 
{\b RxGain_avg} = 0x04 << 4, 
{\b RxGain_max} = 0x07 << 4
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b PICC_Command} \{ {\b PICC_CMD_REQA} = 0x26, 
{\b PICC_CMD_WUPA} = 0x52, 
{\b PICC_CMD_CT} = 0x88, 
{\b PICC_CMD_SEL_CL1} = 0x93, 
{\b PICC_CMD_SEL_CL2} = 0x95, 
{\b PICC_CMD_SEL_CL3} = 0x97, 
{\b PICC_CMD_HLTA} = 0x50, 
{\b PICC_CMD_MF_AUTH_KEY_A} = 0x60, 
{\b PICC_CMD_MF_AUTH_KEY_B} = 0x61, 
{\b PICC_CMD_MF_READ} = 0x30, 
{\b PICC_CMD_MF_WRITE} = 0xA0, 
{\b PICC_CMD_MF_DECREMENT} = 0xC0, 
{\b PICC_CMD_MF_INCREMENT} = 0xC1, 
{\b PICC_CMD_MF_RESTORE} = 0xC2, 
{\b PICC_CMD_MF_TRANSFER} = 0xB0, 
{\b PICC_CMD_UL_WRITE} = 0xA2
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b MIFARE_Misc} \{ {\b MF_ACK} = 0xA, 
{\b MF_KEY_SIZE} = 6
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b PICC_Type} \{ {\b PICC_TYPE_UNKNOWN} = 0, 
{\b PICC_TYPE_ISO_14443_4} = 1, 
{\b PICC_TYPE_ISO_18092} = 2, 
{\b PICC_TYPE_MIFARE_MINI} = 3, 
{\b PICC_TYPE_MIFARE_1K} = 4, 
{\b PICC_TYPE_MIFARE_4K} = 5, 
{\b PICC_TYPE_MIFARE_UL} = 6, 
{\b PICC_TYPE_MIFARE_PLUS} = 7, 
{\b PICC_TYPE_TNP3XXX} = 8, 
{\b PICC_TYPE_NOT_COMPLETE} = 255
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b StatusCode} \{ {\b STATUS_OK} = 1, 
{\b STATUS_ERROR} = 2, 
{\b STATUS_COLLISION} = 3, 
{\b STATUS_TIMEOUT} = 4, 
{\b STATUS_NO_ROOM} = 5, 
{\b STATUS_INTERNAL_ERROR} = 6, 
{\b STATUS_INVALID} = 7, 
{\b STATUS_CRC_WRONG} = 8, 
{\b STATUS_MIFARE_NACK} = 9
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MFRC522} (byte chipSelectPin, byte resetPowerDownPin)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSPIConfig} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PCD_WriteRegister} (byte reg, byte value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PCD_WriteRegister} (byte reg, byte count, byte *values)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b PCD_ReadRegister} (byte reg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PCD_ReadRegister} (byte reg, byte count, byte *values, byte rxAlign=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBitMask} (unsigned char reg, unsigned char mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PCD_SetRegisterBitMask} (byte reg, byte mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PCD_ClearRegisterBitMask} (byte reg, byte mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b PCD_CalculateCRC} (byte *data, byte length, byte *result)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PCD_Init} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PCD_Reset} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PCD_AntennaOn} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PCD_AntennaOff} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b PCD_GetAntennaGain} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PCD_SetAntennaGain} (byte mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b PCD_TransceiveData} (byte *sendData, byte sendLen, byte *backData, byte *backLen, byte *validBits=NULL, byte rxAlign=0, bool checkCRC=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b PCD_CommunicateWithPICC} (byte command, byte waitIRq, byte *sendData, byte sendLen, byte *backData=NULL, byte *backLen=NULL, byte *validBits=NULL, byte rxAlign=0, bool checkCRC=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b PICC_RequestA} (byte *bufferATQA, byte *bufferSize)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b PICC_WakeupA} (byte *bufferATQA, byte *bufferSize)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b PICC_REQA_or_WUPA} (byte command, byte *bufferATQA, byte *bufferSize)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b PICC_Select} ({\b Uid} *{\b uid}, byte validBits=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b PICC_HaltA} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b PCD_Authenticate} (byte command, byte blockAddr, {\b MIFARE_Key} *key, {\b Uid} *{\b uid})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PCD_StopCrypto1} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b MIFARE_Read} (byte blockAddr, byte *buffer, byte *bufferSize)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b MIFARE_Write} (byte blockAddr, byte *buffer, byte bufferSize)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b MIFARE_Decrement} (byte blockAddr, long delta)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b MIFARE_Increment} (byte blockAddr, long delta)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b MIFARE_Restore} (byte blockAddr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b MIFARE_Transfer} (byte blockAddr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b MIFARE_Ultralight_Write} (byte page, byte *buffer, byte bufferSize)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b MIFARE_GetValue} (byte blockAddr, long *value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b MIFARE_SetValue} (byte blockAddr, long value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b PCD_MIFARE_Transceive} (byte *sendData, byte sendLen, bool acceptTimeout=false)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b GetStatusCodeName} (byte code)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b PICC_GetType} (byte sak)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b PICC_GetTypeName} (byte type)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PICC_DumpToSerial} ({\b Uid} *{\b uid})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PICC_DumpMifareClassicToSerial} ({\b Uid} *{\b uid}, byte piccType, {\b MIFARE_Key} *key)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PICC_DumpMifareClassicSectorToSerial} ({\b Uid} *{\b uid}, {\b MIFARE_Key} *key, byte sector)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PICC_DumpMifareUltralightToSerial} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MIFARE_SetAccessBits} (byte *accessBitBuffer, byte g0, byte g1, byte g2, byte g3)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MIFARE_OpenUidBackdoor} (bool logErrors)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MIFARE_SetUid} (byte *newUid, byte uidSize, bool logErrors)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b MIFARE_UnbrickUidSector} (bool logErrors)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b PICC_IsNewCardPresent} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b PICC_ReadCardSerial} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Uid} {\b uid}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const byte {\b FIFO_SIZE} = 64\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b MIFARE_TwoStepHelper} (byte command, byte blockAddr, long data)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b _chipSelectPin}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b _resetPowerDownPin}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 86 of file MFRC522.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v MIFARE_Misc\:MFRC522}
{\xe \v MFRC522\:MIFARE_Misc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b MFRC522::MIFARE_Misc}}}
\par
{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v MF_ACK\:MFRC522}
{\xe \v MFRC522\:MF_ACK}
{\qr MF_ACK{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
\cell }{\cell }{\row }
{\xe \v MF_KEY_SIZE\:MFRC522}
{\xe \v MFRC522\:MF_KEY_SIZE}
{\qr MF_KEY_SIZE{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
\cell }{\cell }{\row }
}
\par
{
Definition at line 221 of file MFRC522.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   221                      \{\par
  222         MF_ACK                  = 0xA,      // The MIFARE Classic uses a 4 bit ACK/NAK. Any other value than 0xA is NAK.\par
  223         MF_KEY_SIZE             = 6         // A Mifare Crypto1 key is 6 bytes.\par
  224     \};\par
}
}
{\xe \v PCD_Command\:MFRC522}
{\xe \v MFRC522\:PCD_Command}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b MFRC522::PCD_Command}}}
\par
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v PCD_Idle\:MFRC522}
{\xe \v MFRC522\:PCD_Idle}
{\qr PCD_Idle{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
\cell }{\cell }{\row }
{\xe \v PCD_Mem\:MFRC522}
{\xe \v MFRC522\:PCD_Mem}
{\qr PCD_Mem{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
\cell }{\cell }{\row }
{\xe \v PCD_GenerateRandomID\:MFRC522}
{\xe \v MFRC522\:PCD_GenerateRandomID}
{\qr PCD_GenerateRandomID{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
\cell }{\cell }{\row }
{\xe \v PCD_CalcCRC\:MFRC522}
{\xe \v MFRC522\:PCD_CalcCRC}
{\qr PCD_CalcCRC{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
\cell }{\cell }{\row }
{\xe \v PCD_Transmit\:MFRC522}
{\xe \v MFRC522\:PCD_Transmit}
{\qr PCD_Transmit{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
\cell }{\cell }{\row }
{\xe \v PCD_NoCmdChange\:MFRC522}
{\xe \v MFRC522\:PCD_NoCmdChange}
{\qr PCD_NoCmdChange{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
\cell }{\cell }{\row }
{\xe \v PCD_Receive\:MFRC522}
{\xe \v MFRC522\:PCD_Receive}
{\qr PCD_Receive{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
\cell }{\cell }{\row }
{\xe \v PCD_Transceive\:MFRC522}
{\xe \v MFRC522\:PCD_Transceive}
{\qr PCD_Transceive{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
\cell }{\cell }{\row }
{\xe \v PCD_MFAuthent\:MFRC522}
{\xe \v MFRC522\:PCD_MFAuthent}
{\qr PCD_MFAuthent{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
\cell }{\cell }{\row }
{\xe \v PCD_SoftReset\:MFRC522}
{\xe \v MFRC522\:PCD_SoftReset}
{\qr PCD_SoftReset{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
\cell }{\cell }{\row }
}
\par
{
Definition at line 165 of file MFRC522.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   165                      \{\par
  166         PCD_Idle                = 0x00,     // no action, cancels current command execution\par
  167         PCD_Mem                 = 0x01,     // stores 25 bytes into the internal buffer\par
  168         PCD_GenerateRandomID    = 0x02,     // generates a 10-byte random ID number\par
  169         PCD_CalcCRC             = 0x03,     // activates the CRC coprocessor or performs a self test\par
  170         PCD_Transmit            = 0x04,     // transmits data from the FIFO buffer\par
  171         PCD_NoCmdChange         = 0x07,     // no command change, can be used to modify the CommandReg register bits without affecting the command, for example, the PowerDown bit\par
  172         PCD_Receive             = 0x08,     // activates the receiver circuits\par
  173         PCD_Transceive          = 0x0C,     // transmits data from FIFO buffer to antenna and automatically activates the receiver after transmission\par
  174         PCD_MFAuthent           = 0x0E,     // performs the MIFARE standard authentication as a reader\par
  175         PCD_SoftReset           = 0x0F      // resets the MFRC522\par
  176     \};\par
}
}
{\xe \v PCD_Register\:MFRC522}
{\xe \v MFRC522\:PCD_Register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b MFRC522::PCD_Register}}}
\par
{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v CommandReg\:MFRC522}
{\xe \v MFRC522\:CommandReg}
{\qr CommandReg{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
\cell }{\cell }{\row }
{\xe \v ComIEnReg\:MFRC522}
{\xe \v MFRC522\:ComIEnReg}
{\qr ComIEnReg{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
\cell }{\cell }{\row }
{\xe \v DivIEnReg\:MFRC522}
{\xe \v MFRC522\:DivIEnReg}
{\qr DivIEnReg{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
\cell }{\cell }{\row }
{\xe \v ComIrqReg\:MFRC522}
{\xe \v MFRC522\:ComIrqReg}
{\qr ComIrqReg{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
\cell }{\cell }{\row }
{\xe \v DivIrqReg\:MFRC522}
{\xe \v MFRC522\:DivIrqReg}
{\qr DivIrqReg{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
\cell }{\cell }{\row }
{\xe \v ErrorReg\:MFRC522}
{\xe \v MFRC522\:ErrorReg}
{\qr ErrorReg{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
\cell }{\cell }{\row }
{\xe \v Status1Reg\:MFRC522}
{\xe \v MFRC522\:Status1Reg}
{\qr Status1Reg{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
\cell }{\cell }{\row }
{\xe \v Status2Reg\:MFRC522}
{\xe \v MFRC522\:Status2Reg}
{\qr Status2Reg{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
\cell }{\cell }{\row }
{\xe \v FIFODataReg\:MFRC522}
{\xe \v MFRC522\:FIFODataReg}
{\qr FIFODataReg{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
\cell }{\cell }{\row }
{\xe \v FIFOLevelReg\:MFRC522}
{\xe \v MFRC522\:FIFOLevelReg}
{\qr FIFOLevelReg{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
\cell }{\cell }{\row }
{\xe \v WaterLevelReg\:MFRC522}
{\xe \v MFRC522\:WaterLevelReg}
{\qr WaterLevelReg{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
\cell }{\cell }{\row }
{\xe \v ControlReg\:MFRC522}
{\xe \v MFRC522\:ControlReg}
{\qr ControlReg{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
\cell }{\cell }{\row }
{\xe \v BitFramingReg\:MFRC522}
{\xe \v MFRC522\:BitFramingReg}
{\qr BitFramingReg{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
\cell }{\cell }{\row }
{\xe \v CollReg\:MFRC522}
{\xe \v MFRC522\:CollReg}
{\qr CollReg{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
\cell }{\cell }{\row }
{\xe \v ModeReg\:MFRC522}
{\xe \v MFRC522\:ModeReg}
{\qr ModeReg{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
\cell }{\cell }{\row }
{\xe \v TxModeReg\:MFRC522}
{\xe \v MFRC522\:TxModeReg}
{\qr TxModeReg{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
\cell }{\cell }{\row }
{\xe \v RxModeReg\:MFRC522}
{\xe \v MFRC522\:RxModeReg}
{\qr RxModeReg{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
\cell }{\cell }{\row }
{\xe \v TxControlReg\:MFRC522}
{\xe \v MFRC522\:TxControlReg}
{\qr TxControlReg{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
\cell }{\cell }{\row }
{\xe \v TxASKReg\:MFRC522}
{\xe \v MFRC522\:TxASKReg}
{\qr TxASKReg{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
\cell }{\cell }{\row }
{\xe \v TxSelReg\:MFRC522}
{\xe \v MFRC522\:TxSelReg}
{\qr TxSelReg{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
\cell }{\cell }{\row }
{\xe \v RxSelReg\:MFRC522}
{\xe \v MFRC522\:RxSelReg}
{\qr RxSelReg{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
\cell }{\cell }{\row }
{\xe \v RxThresholdReg\:MFRC522}
{\xe \v MFRC522\:RxThresholdReg}
{\qr RxThresholdReg{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
\cell }{\cell }{\row }
{\xe \v DemodReg\:MFRC522}
{\xe \v MFRC522\:DemodReg}
{\qr DemodReg{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
\cell }{\cell }{\row }
{\xe \v MfTxReg\:MFRC522}
{\xe \v MFRC522\:MfTxReg}
{\qr MfTxReg{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
\cell }{\cell }{\row }
{\xe \v MfRxReg\:MFRC522}
{\xe \v MFRC522\:MfRxReg}
{\qr MfRxReg{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
\cell }{\cell }{\row }
{\xe \v SerialSpeedReg\:MFRC522}
{\xe \v MFRC522\:SerialSpeedReg}
{\qr SerialSpeedReg{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
\cell }{\cell }{\row }
{\xe \v CRCResultRegH\:MFRC522}
{\xe \v MFRC522\:CRCResultRegH}
{\qr CRCResultRegH{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
\cell }{\cell }{\row }
{\xe \v CRCResultRegL\:MFRC522}
{\xe \v MFRC522\:CRCResultRegL}
{\qr CRCResultRegL{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
\cell }{\cell }{\row }
{\xe \v ModWidthReg\:MFRC522}
{\xe \v MFRC522\:ModWidthReg}
{\qr ModWidthReg{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
\cell }{\cell }{\row }
{\xe \v RFCfgReg\:MFRC522}
{\xe \v MFRC522\:RFCfgReg}
{\qr RFCfgReg{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
\cell }{\cell }{\row }
{\xe \v GsNReg\:MFRC522}
{\xe \v MFRC522\:GsNReg}
{\qr GsNReg{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
\cell }{\cell }{\row }
{\xe \v CWGsPReg\:MFRC522}
{\xe \v MFRC522\:CWGsPReg}
{\qr CWGsPReg{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
\cell }{\cell }{\row }
{\xe \v ModGsPReg\:MFRC522}
{\xe \v MFRC522\:ModGsPReg}
{\qr ModGsPReg{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
\cell }{\cell }{\row }
{\xe \v TModeReg\:MFRC522}
{\xe \v MFRC522\:TModeReg}
{\qr TModeReg{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
\cell }{\cell }{\row }
{\xe \v TPrescalerReg\:MFRC522}
{\xe \v MFRC522\:TPrescalerReg}
{\qr TPrescalerReg{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
\cell }{\cell }{\row }
{\xe \v TReloadRegH\:MFRC522}
{\xe \v MFRC522\:TReloadRegH}
{\qr TReloadRegH{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
\cell }{\cell }{\row }
{\xe \v TReloadRegL\:MFRC522}
{\xe \v MFRC522\:TReloadRegL}
{\qr TReloadRegL{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
\cell }{\cell }{\row }
{\xe \v TCounterValueRegH\:MFRC522}
{\xe \v MFRC522\:TCounterValueRegH}
{\qr TCounterValueRegH{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
\cell }{\cell }{\row }
{\xe \v TCounterValueRegL\:MFRC522}
{\xe \v MFRC522\:TCounterValueRegL}
{\qr TCounterValueRegL{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
\cell }{\cell }{\row }
{\xe \v TestSel1Reg\:MFRC522}
{\xe \v MFRC522\:TestSel1Reg}
{\qr TestSel1Reg{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
\cell }{\cell }{\row }
{\xe \v TestSel2Reg\:MFRC522}
{\xe \v MFRC522\:TestSel2Reg}
{\qr TestSel2Reg{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
\cell }{\cell }{\row }
{\xe \v TestPinEnReg\:MFRC522}
{\xe \v MFRC522\:TestPinEnReg}
{\qr TestPinEnReg{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
\cell }{\cell }{\row }
{\xe \v TestPinValueReg\:MFRC522}
{\xe \v MFRC522\:TestPinValueReg}
{\qr TestPinValueReg{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
\cell }{\cell }{\row }
{\xe \v TestBusReg\:MFRC522}
{\xe \v MFRC522\:TestBusReg}
{\qr TestBusReg{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
\cell }{\cell }{\row }
{\xe \v AutoTestReg\:MFRC522}
{\xe \v MFRC522\:AutoTestReg}
{\qr AutoTestReg{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
\cell }{\cell }{\row }
{\xe \v VersionReg\:MFRC522}
{\xe \v MFRC522\:VersionReg}
{\qr VersionReg{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
\cell }{\cell }{\row }
{\xe \v AnalogTestReg\:MFRC522}
{\xe \v MFRC522\:AnalogTestReg}
{\qr AnalogTestReg{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
\cell }{\cell }{\row }
{\xe \v TestDAC1Reg\:MFRC522}
{\xe \v MFRC522\:TestDAC1Reg}
{\qr TestDAC1Reg{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
\cell }{\cell }{\row }
{\xe \v TestDAC2Reg\:MFRC522}
{\xe \v MFRC522\:TestDAC2Reg}
{\qr TestDAC2Reg{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
\cell }{\cell }{\row }
{\xe \v TestADCReg\:MFRC522}
{\xe \v MFRC522\:TestADCReg}
{\qr TestADCReg{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
\cell }{\cell }{\row }
}
\par
{
Definition at line 90 of file MFRC522.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    90                       \{\par
   91         // Page 0: Command and status\par
   92         //                        0x00          // reserved for future use\par
   93         CommandReg              = 0x01 << 1,    // starts and stops command execution\par
   94         ComIEnReg               = 0x02 << 1,    // enable and disable interrupt request control bits\par
   95         DivIEnReg               = 0x03 << 1,    // enable and disable interrupt request control bits\par
   96         ComIrqReg               = 0x04 << 1,    // interrupt request bits\par
   97         DivIrqReg               = 0x05 << 1,    // interrupt request bits\par
   98         ErrorReg                = 0x06 << 1,    // error bits showing the error status of the last command executed \par
   99         Status1Reg              = 0x07 << 1,    // communication status bits\par
  100         Status2Reg              = 0x08 << 1,    // receiver and transmitter status bits\par
  101         FIFODataReg             = 0x09 << 1,    // input and output of 64 byte FIFO buffer\par
  102         FIFOLevelReg            = 0x0A << 1,    // number of bytes stored in the FIFO buffer\par
  103         WaterLevelReg           = 0x0B << 1,    // level for FIFO underflow and overflow warning\par
  104         ControlReg              = 0x0C << 1,    // miscellaneous control registers\par
  105         BitFramingReg           = 0x0D << 1,    // adjustments for bit-oriented frames\par
  106         CollReg                 = 0x0E << 1,    // bit position of the first bit-collision detected on the RF interface\par
  107         //                        0x0F          // reserved for future use\par
  108         \par
  109         // Page 1:Command\par
  110         //                        0x10          // reserved for future use\par
  111         ModeReg                 = 0x11 << 1,    // defines general modes for transmitting and receiving \par
  112         TxModeReg               = 0x12 << 1,    // defines transmission data rate and framing\par
  113         RxModeReg               = 0x13 << 1,    // defines reception data rate and framing\par
  114         TxControlReg            = 0x14 << 1,    // controls the logical behavior of the antenna driver pins TX1 and TX2\par
  115         TxASKReg                = 0x15 << 1,    // controls the setting of the transmission modulation\par
  116         TxSelReg                = 0x16 << 1,    // selects the internal sources for the antenna driver\par
  117         RxSelReg                = 0x17 << 1,    // selects internal receiver settings\par
  118         RxThresholdReg          = 0x18 << 1,    // selects thresholds for the bit decoder\par
  119         DemodReg                = 0x19 << 1,    // defines demodulator settings\par
  120         //                        0x1A          // reserved for future use\par
  121         //                        0x1B          // reserved for future use\par
  122         MfTxReg                 = 0x1C << 1,    // controls some MIFARE communication transmit parameters\par
  123         MfRxReg                 = 0x1D << 1,    // controls some MIFARE communication receive parameters\par
  124         //                        0x1E          // reserved for future use\par
  125         SerialSpeedReg          = 0x1F << 1,    // selects the speed of the serial UART interface\par
  126         \par
  127         // Page 2: Configuration\par
  128         //                      0x20            // reserved for future use\par
  129         CRCResultRegH           = 0x21 << 1,    // shows the MSB and LSB values of the CRC calculation\par
  130         CRCResultRegL           = 0x22 << 1,\par
  131         //                        0x23          // reserved for future use\par
  132         ModWidthReg             = 0x24 << 1,    // controls the ModWidth setting?\par
  133         //                        0x25          // reserved for future use\par
  134         RFCfgReg                = 0x26 << 1,    // configures the receiver gain\par
  135         GsNReg                  = 0x27 << 1,    // selects the conductance of the antenna driver pins TX1 and TX2 for modulation \par
  136         CWGsPReg                = 0x28 << 1,    // defines the conductance of the p-driver output during periods of no modulation\par
  137         ModGsPReg               = 0x29 << 1,    // defines the conductance of the p-driver output during periods of modulation\par
  138         TModeReg                = 0x2A << 1,    // defines settings for the internal timer\par
  139         TPrescalerReg           = 0x2B << 1,    // the lower 8 bits of the TPrescaler value. The 4 high bits are in TModeReg.\par
  140         TReloadRegH             = 0x2C << 1,    // defines the 16-bit timer reload value\par
  141         TReloadRegL             = 0x2D << 1,\par
  142         TCounterValueRegH       = 0x2E << 1,    // shows the 16-bit timer value\par
  143         TCounterValueRegL       = 0x2F << 1,\par
  144         \par
  145         // Page 3:Test Registers\par
  146         //                        0x30          // reserved for future use\par
  147         TestSel1Reg             = 0x31 << 1,    // general test signal configuration\par
  148         TestSel2Reg             = 0x32 << 1,    // general test signal configuration\par
  149         TestPinEnReg            = 0x33 << 1,    // enables pin output driver on pins D1 to D7\par
  150         TestPinValueReg         = 0x34 << 1,    // defines the values for D1 to D7 when it is used as an I/O bus\par
  151         TestBusReg              = 0x35 << 1,    // shows the status of the internal test bus\par
  152         AutoTestReg             = 0x36 << 1,    // controls the digital self test\par
  153         VersionReg              = 0x37 << 1,    // shows the software version\par
  154         AnalogTestReg           = 0x38 << 1,    // controls the pins AUX1 and AUX2\par
  155         TestDAC1Reg             = 0x39 << 1,    // defines the test value for TestDAC1\par
  156         TestDAC2Reg             = 0x3A << 1,    // defines the test value for TestDAC2\par
  157         TestADCReg              = 0x3B << 1     // shows the value of ADC I and Q channels\par
  158         //                        0x3C          // reserved for production tests\par
  159         //                        0x3D          // reserved for production tests\par
  160         //                        0x3E          // reserved for production tests\par
  161         //                        0x3F          // reserved for production tests\par
  162     \};\par
}
}
{\xe \v PCD_RxGain\:MFRC522}
{\xe \v MFRC522\:PCD_RxGain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b MFRC522::PCD_RxGain}}}
\par
{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v RxGain_18dB\:MFRC522}
{\xe \v MFRC522\:RxGain_18dB}
{\qr RxGain_18dB{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
\cell }{\cell }{\row }
{\xe \v RxGain_23dB\:MFRC522}
{\xe \v MFRC522\:RxGain_23dB}
{\qr RxGain_23dB{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
\cell }{\cell }{\row }
{\xe \v RxGain_18dB_2\:MFRC522}
{\xe \v MFRC522\:RxGain_18dB_2}
{\qr RxGain_18dB_2{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
\cell }{\cell }{\row }
{\xe \v RxGain_23dB_2\:MFRC522}
{\xe \v MFRC522\:RxGain_23dB_2}
{\qr RxGain_23dB_2{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
\cell }{\cell }{\row }
{\xe \v RxGain_33dB\:MFRC522}
{\xe \v MFRC522\:RxGain_33dB}
{\qr RxGain_33dB{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
\cell }{\cell }{\row }
{\xe \v RxGain_38dB\:MFRC522}
{\xe \v MFRC522\:RxGain_38dB}
{\qr RxGain_38dB{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
\cell }{\cell }{\row }
{\xe \v RxGain_43dB\:MFRC522}
{\xe \v MFRC522\:RxGain_43dB}
{\qr RxGain_43dB{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
\cell }{\cell }{\row }
{\xe \v RxGain_48dB\:MFRC522}
{\xe \v MFRC522\:RxGain_48dB}
{\qr RxGain_48dB{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
\cell }{\cell }{\row }
{\xe \v RxGain_min\:MFRC522}
{\xe \v MFRC522\:RxGain_min}
{\qr RxGain_min{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
\cell }{\cell }{\row }
{\xe \v RxGain_avg\:MFRC522}
{\xe \v MFRC522\:RxGain_avg}
{\qr RxGain_avg{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
\cell }{\cell }{\row }
{\xe \v RxGain_max\:MFRC522}
{\xe \v MFRC522\:RxGain_max}
{\qr RxGain_max{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
\cell }{\cell }{\row }
}
\par
{
Definition at line 180 of file MFRC522.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   180                     \{\par
  181         RxGain_18dB             = 0x00 << 4,    // 000b - 18 dB, minimum\par
  182         RxGain_23dB             = 0x01 << 4,    // 001b - 23 dB\par
  183         RxGain_18dB_2           = 0x02 << 4,    // 010b - 18 dB, it seems 010b is a duplicate for 000b\par
  184         RxGain_23dB_2           = 0x03 << 4,    // 011b - 23 dB, it seems 011b is a duplicate for 001b\par
  185         RxGain_33dB             = 0x04 << 4,    // 100b - 33 dB, average, and typical default\par
  186         RxGain_38dB             = 0x05 << 4,    // 101b - 38 dB\par
  187         RxGain_43dB             = 0x06 << 4,    // 110b - 43 dB\par
  188         RxGain_48dB             = 0x07 << 4,    // 111b - 48 dB, maximum\par
  189         RxGain_min              = 0x00 << 4,    // 000b - 18 dB, minimum, convenience for RxGain_18dB\par
  190         RxGain_avg              = 0x04 << 4,    // 100b - 33 dB, average, convenience for RxGain_33dB\par
  191         RxGain_max              = 0x07 << 4     // 111b - 48 dB, maximum, convenience for RxGain_48dB\par
  192     \};\par
}
}
{\xe \v PICC_Command\:MFRC522}
{\xe \v MFRC522\:PICC_Command}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b MFRC522::PICC_Command}}}
\par
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v PICC_CMD_REQA\:MFRC522}
{\xe \v MFRC522\:PICC_CMD_REQA}
{\qr PICC_CMD_REQA{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
\cell }{\cell }{\row }
{\xe \v PICC_CMD_WUPA\:MFRC522}
{\xe \v MFRC522\:PICC_CMD_WUPA}
{\qr PICC_CMD_WUPA{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
\cell }{\cell }{\row }
{\xe \v PICC_CMD_CT\:MFRC522}
{\xe \v MFRC522\:PICC_CMD_CT}
{\qr PICC_CMD_CT{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
\cell }{\cell }{\row }
{\xe \v PICC_CMD_SEL_CL1\:MFRC522}
{\xe \v MFRC522\:PICC_CMD_SEL_CL1}
{\qr PICC_CMD_SEL_CL1{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
\cell }{\cell }{\row }
{\xe \v PICC_CMD_SEL_CL2\:MFRC522}
{\xe \v MFRC522\:PICC_CMD_SEL_CL2}
{\qr PICC_CMD_SEL_CL2{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
\cell }{\cell }{\row }
{\xe \v PICC_CMD_SEL_CL3\:MFRC522}
{\xe \v MFRC522\:PICC_CMD_SEL_CL3}
{\qr PICC_CMD_SEL_CL3{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
\cell }{\cell }{\row }
{\xe \v PICC_CMD_HLTA\:MFRC522}
{\xe \v MFRC522\:PICC_CMD_HLTA}
{\qr PICC_CMD_HLTA{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
\cell }{\cell }{\row }
{\xe \v PICC_CMD_MF_AUTH_KEY_A\:MFRC522}
{\xe \v MFRC522\:PICC_CMD_MF_AUTH_KEY_A}
{\qr PICC_CMD_MF_AUTH_KEY_A{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
\cell }{\cell }{\row }
{\xe \v PICC_CMD_MF_AUTH_KEY_B\:MFRC522}
{\xe \v MFRC522\:PICC_CMD_MF_AUTH_KEY_B}
{\qr PICC_CMD_MF_AUTH_KEY_B{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
\cell }{\cell }{\row }
{\xe \v PICC_CMD_MF_READ\:MFRC522}
{\xe \v MFRC522\:PICC_CMD_MF_READ}
{\qr PICC_CMD_MF_READ{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
\cell }{\cell }{\row }
{\xe \v PICC_CMD_MF_WRITE\:MFRC522}
{\xe \v MFRC522\:PICC_CMD_MF_WRITE}
{\qr PICC_CMD_MF_WRITE{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
\cell }{\cell }{\row }
{\xe \v PICC_CMD_MF_DECREMENT\:MFRC522}
{\xe \v MFRC522\:PICC_CMD_MF_DECREMENT}
{\qr PICC_CMD_MF_DECREMENT{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
\cell }{\cell }{\row }
{\xe \v PICC_CMD_MF_INCREMENT\:MFRC522}
{\xe \v MFRC522\:PICC_CMD_MF_INCREMENT}
{\qr PICC_CMD_MF_INCREMENT{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
\cell }{\cell }{\row }
{\xe \v PICC_CMD_MF_RESTORE\:MFRC522}
{\xe \v MFRC522\:PICC_CMD_MF_RESTORE}
{\qr PICC_CMD_MF_RESTORE{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
\cell }{\cell }{\row }
{\xe \v PICC_CMD_MF_TRANSFER\:MFRC522}
{\xe \v MFRC522\:PICC_CMD_MF_TRANSFER}
{\qr PICC_CMD_MF_TRANSFER{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
\cell }{\cell }{\row }
{\xe \v PICC_CMD_UL_WRITE\:MFRC522}
{\xe \v MFRC522\:PICC_CMD_UL_WRITE}
{\qr PICC_CMD_UL_WRITE{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
\cell }{\cell }{\row }
}
\par
{
Definition at line 195 of file MFRC522.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   195                       \{\par
  196         // The commands used by the PCD to manage communication with several PICCs (ISO 14443-3, Type A, section 6.4)\par
  197         PICC_CMD_REQA           = 0x26,     // REQuest command, Type A. Invites PICCs in state IDLE to go to READY and prepare for anticollision or selection. 7 bit frame.\par
  198         PICC_CMD_WUPA           = 0x52,     // Wake-UP command, Type A. Invites PICCs in state IDLE and HALT to go to READY(*) and prepare for anticollision or selection. 7 bit frame.\par
  199         PICC_CMD_CT             = 0x88,     // Cascade Tag. Not really a command, but used during anti collision.\par
  200         PICC_CMD_SEL_CL1        = 0x93,     // Anti collision/Select, Cascade Level 1\par
  201         PICC_CMD_SEL_CL2        = 0x95,     // Anti collision/Select, Cascade Level 1\par
  202         PICC_CMD_SEL_CL3        = 0x97,     // Anti collision/Select, Cascade Level 1\par
  203         PICC_CMD_HLTA           = 0x50,     // HaLT command, Type A. Instructs an ACTIVE PICC to go to state HALT.\par
  204         // The commands used for MIFARE Classic (from http://www.nxp.com/documents/data_sheet/MF1S503x.pdf, Section 9)\par
  205         // Use PCD_MFAuthent to authenticate access to a sector, then use these commands to read/write/modify the blocks on the sector.\par
  206         // The read/write commands can also be used for MIFARE Ultralight.\par
  207         PICC_CMD_MF_AUTH_KEY_A  = 0x60,     // Perform authentication with Key A\par
  208         PICC_CMD_MF_AUTH_KEY_B  = 0x61,     // Perform authentication with Key B\par
  209         PICC_CMD_MF_READ        = 0x30,     // Reads one 16 byte block from the authenticated sector of the PICC. Also used for MIFARE Ultralight.\par
  210         PICC_CMD_MF_WRITE       = 0xA0,     // Writes one 16 byte block to the authenticated sector of the PICC. Called "COMPATIBILITY WRITE" for MIFARE Ultralight.\par
  211         PICC_CMD_MF_DECREMENT   = 0xC0,     // Decrements the contents of a block and stores the result in the internal data register.\par
  212         PICC_CMD_MF_INCREMENT   = 0xC1,     // Increments the contents of a block and stores the result in the internal data register.\par
  213         PICC_CMD_MF_RESTORE     = 0xC2,     // Reads the contents of a block into the internal data register.\par
  214         PICC_CMD_MF_TRANSFER    = 0xB0,     // Writes the contents of the internal data register to a block.\par
  215         // The commands used for MIFARE Ultralight (from http://www.nxp.com/documents/data_sheet/MF0ICU1.pdf, Section 8.6)\par
  216         // The PICC_CMD_MF_READ and PICC_CMD_MF_WRITE can also be used for MIFARE Ultralight.\par
  217         PICC_CMD_UL_WRITE       = 0xA2      // Writes one 4 byte page to the PICC.\par
  218     \};\par
}
}
{\xe \v PICC_Type\:MFRC522}
{\xe \v MFRC522\:PICC_Type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b MFRC522::PICC_Type}}}
\par
{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v PICC_TYPE_UNKNOWN\:MFRC522}
{\xe \v MFRC522\:PICC_TYPE_UNKNOWN}
{\qr PICC_TYPE_UNKNOWN{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
\cell }{\cell }{\row }
{\xe \v PICC_TYPE_ISO_14443_4\:MFRC522}
{\xe \v MFRC522\:PICC_TYPE_ISO_14443_4}
{\qr PICC_TYPE_ISO_14443_4{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
\cell }{\cell }{\row }
{\xe \v PICC_TYPE_ISO_18092\:MFRC522}
{\xe \v MFRC522\:PICC_TYPE_ISO_18092}
{\qr PICC_TYPE_ISO_18092{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
\cell }{\cell }{\row }
{\xe \v PICC_TYPE_MIFARE_MINI\:MFRC522}
{\xe \v MFRC522\:PICC_TYPE_MIFARE_MINI}
{\qr PICC_TYPE_MIFARE_MINI{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
\cell }{\cell }{\row }
{\xe \v PICC_TYPE_MIFARE_1K\:MFRC522}
{\xe \v MFRC522\:PICC_TYPE_MIFARE_1K}
{\qr PICC_TYPE_MIFARE_1K{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
\cell }{\cell }{\row }
{\xe \v PICC_TYPE_MIFARE_4K\:MFRC522}
{\xe \v MFRC522\:PICC_TYPE_MIFARE_4K}
{\qr PICC_TYPE_MIFARE_4K{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
\cell }{\cell }{\row }
{\xe \v PICC_TYPE_MIFARE_UL\:MFRC522}
{\xe \v MFRC522\:PICC_TYPE_MIFARE_UL}
{\qr PICC_TYPE_MIFARE_UL{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
\cell }{\cell }{\row }
{\xe \v PICC_TYPE_MIFARE_PLUS\:MFRC522}
{\xe \v MFRC522\:PICC_TYPE_MIFARE_PLUS}
{\qr PICC_TYPE_MIFARE_PLUS{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
\cell }{\cell }{\row }
{\xe \v PICC_TYPE_TNP3XXX\:MFRC522}
{\xe \v MFRC522\:PICC_TYPE_TNP3XXX}
{\qr PICC_TYPE_TNP3XXX{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
\cell }{\cell }{\row }
{\xe \v PICC_TYPE_NOT_COMPLETE\:MFRC522}
{\xe \v MFRC522\:PICC_TYPE_NOT_COMPLETE}
{\qr PICC_TYPE_NOT_COMPLETE{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
\cell }{\cell }{\row }
}
\par
{
Definition at line 227 of file MFRC522.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   227                    \{\par
  228         PICC_TYPE_UNKNOWN       = 0,\par
  229         PICC_TYPE_ISO_14443_4   = 1,    // PICC compliant with ISO/IEC 14443-4 \par
  230         PICC_TYPE_ISO_18092     = 2,    // PICC compliant with ISO/IEC 18092 (NFC)\par
  231         PICC_TYPE_MIFARE_MINI   = 3,    // MIFARE Classic protocol, 320 bytes\par
  232         PICC_TYPE_MIFARE_1K     = 4,    // MIFARE Classic protocol, 1KB\par
  233         PICC_TYPE_MIFARE_4K     = 5,    // MIFARE Classic protocol, 4KB\par
  234         PICC_TYPE_MIFARE_UL     = 6,    // MIFARE Ultralight or Ultralight C\par
  235         PICC_TYPE_MIFARE_PLUS   = 7,    // MIFARE Plus\par
  236         PICC_TYPE_TNP3XXX       = 8,    // Only mentioned in NXP AN 10833 MIFARE Type Identification Procedure\par
  237         PICC_TYPE_NOT_COMPLETE  = 255   // SAK indicates UID is not complete.\par
  238     \};\par
}
}
{\xe \v StatusCode\:MFRC522}
{\xe \v MFRC522\:StatusCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b MFRC522::StatusCode}}}
\par
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v STATUS_OK\:MFRC522}
{\xe \v MFRC522\:STATUS_OK}
{\qr STATUS_OK{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
\cell }{\cell }{\row }
{\xe \v STATUS_ERROR\:MFRC522}
{\xe \v MFRC522\:STATUS_ERROR}
{\qr STATUS_ERROR{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
\cell }{\cell }{\row }
{\xe \v STATUS_COLLISION\:MFRC522}
{\xe \v MFRC522\:STATUS_COLLISION}
{\qr STATUS_COLLISION{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
\cell }{\cell }{\row }
{\xe \v STATUS_TIMEOUT\:MFRC522}
{\xe \v MFRC522\:STATUS_TIMEOUT}
{\qr STATUS_TIMEOUT{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
\cell }{\cell }{\row }
{\xe \v STATUS_NO_ROOM\:MFRC522}
{\xe \v MFRC522\:STATUS_NO_ROOM}
{\qr STATUS_NO_ROOM{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
\cell }{\cell }{\row }
{\xe \v STATUS_INTERNAL_ERROR\:MFRC522}
{\xe \v MFRC522\:STATUS_INTERNAL_ERROR}
{\qr STATUS_INTERNAL_ERROR{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
\cell }{\cell }{\row }
{\xe \v STATUS_INVALID\:MFRC522}
{\xe \v MFRC522\:STATUS_INVALID}
{\qr STATUS_INVALID{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
\cell }{\cell }{\row }
{\xe \v STATUS_CRC_WRONG\:MFRC522}
{\xe \v MFRC522\:STATUS_CRC_WRONG}
{\qr STATUS_CRC_WRONG{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
\cell }{\cell }{\row }
{\xe \v STATUS_MIFARE_NACK\:MFRC522}
{\xe \v MFRC522\:STATUS_MIFARE_NACK}
{\qr STATUS_MIFARE_NACK{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
\cell }{\cell }{\row }
}
\par
{
Definition at line 241 of file MFRC522.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   241                     \{\par
  242         STATUS_OK               = 1,    // Success\par
  243         STATUS_ERROR            = 2,    // Error in communication\par
  244         STATUS_COLLISION        = 3,    // Collission detected\par
  245         STATUS_TIMEOUT          = 4,    // Timeout in communication.\par
  246         STATUS_NO_ROOM          = 5,    // A buffer is not big enough.\par
  247         STATUS_INTERNAL_ERROR   = 6,    // Internal error in the code. Should not happen ;-)\par
  248         STATUS_INVALID          = 7,    // Invalid argument.\par
  249         STATUS_CRC_WRONG        = 8,    // The CRC_A does not match\par
  250         STATUS_MIFARE_NACK      = 9     // A MIFARE PICC responded with NAK.\par
  251     \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v MFRC522\:MFRC522}
{\xe \v MFRC522\:MFRC522}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MFRC522::MFRC522 (byte  {\i chipSelectPin}, byte  {\i resetPowerDownPin})}}
\par
{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor. Prepares the output pins. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i chipSelectPin} \cell }{Arduino pin connected to {\b MFRC522}'s SPI slave select input (Pin 24, NSS, active low) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i resetPowerDownPin} \cell }{Arduino pin connected to {\b MFRC522}'s reset and power down input (Pin 6, NRSTPD, active low) \cell }
{\row }
}
}{
Definition at line 18 of file MFRC522.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    20                   \{\par
   21     // Set the chipSelectPin as digital output, do not select the slave yet\par
   22     _chipSelectPin = chipSelectPin;\par
   23     pinMode(_chipSelectPin, OUTPUT);\par
   24     digitalWrite(_chipSelectPin, HIGH);\par
   25     \par
   26     // Set the resetPowerDownPin as digital output, do not reset or power down.\par
   27     _resetPowerDownPin = resetPowerDownPin;\par
   28     pinMode(_resetPowerDownPin, OUTPUT);\par
   29     digitalWrite(_resetPowerDownPin, LOW);\par
   30     \par
   31     // Set SPI bus to work with MFRC522 chip.\par
   32     //setSPIConfig();\par
   33 \} // End constructor\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v GetStatusCodeName\:MFRC522}
{\xe \v MFRC522\:GetStatusCodeName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * MFRC522::GetStatusCodeName (byte  {\i code})}}
\par
{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a string pointer to a status code name. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i code} \cell }{One of the StatusCode enums. \cell }
{\row }
}
}{
Definition at line 1077 of file MFRC522.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1078                                           \{\par
 1079     switch (code) \{\par
 1080         case STATUS_OK:             return "Success."; break;\par
 1081         case STATUS_ERROR:          return "Error in communication."; break;\par
 1082         case STATUS_COLLISION:      return "Collission detected."; break;\par
 1083         case STATUS_TIMEOUT:        return "Timeout in communication."; break;\par
 1084         case STATUS_NO_ROOM:        return "A buffer is not big enough."; break;\par
 1085         case STATUS_INTERNAL_ERROR: return "Internal error in the code. Should not happen."; break;\par
 1086         case STATUS_INVALID:        return "Invalid argument."; break;\par
 1087         case STATUS_CRC_WRONG:      return "The CRC_A does not match."; break;\par
 1088         case STATUS_MIFARE_NACK:    return "A MIFARE PICC responded with NAK."; break;\par
 1089         default:\par
 1090             return "Unknown error";\par
 1091             break;\par
 1092     \}\par
 1093 \} // End GetStatusCodeName()\par
}
}
{\xe \v MIFARE_Decrement\:MFRC522}
{\xe \v MFRC522\:MIFARE_Decrement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::MIFARE_Decrement (byte  {\i blockAddr}, long  {\i delta})}}
\par
{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
MIFARE Decrement subtracts the delta from the value of the addressed block, and stores the result in a volatile memory. For MIFARE Classic only. The sector containing the block must be authenticated before calling this function. Only for blocks in "value block" mode, ie with access bits [C1 C2 C3] = [110] or [001]. Use {\b MIFARE_Transfer()} to store the result in a block.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid STATUS_OK on success, STATUS_??? otherwise. \par
}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i blockAddr} \cell }{The block (0-0xff) number. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i delta} \cell }{This number is subtracted from the value of block blockAddr. \cell }
{\row }
}
}{
Definition at line 877 of file MFRC522.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   879                               \{\par
  880     return MIFARE_TwoStepHelper(PICC_CMD_MF_DECREMENT, blockAddr, delta);\par
  881 \} // End MIFARE_Decrement()\par
}
}
{\xe \v MIFARE_GetValue\:MFRC522}
{\xe \v MFRC522\:MIFARE_GetValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::MIFARE_GetValue (byte  {\i blockAddr}, long *  {\i value})}}
\par
{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper routine to read the current value from a Value Block.\par
Only for MIFARE Classic and only for blocks in "value block" mode, that is: with access bits [C1 C2 C3] = [110] or [001]. The sector containing the block must be authenticated before calling this function.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i blockAddr} \cell }{The block (0x00-0xff) number. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{out\cell }{{\i value} \cell }{Current value of the Value Block. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid STATUS_OK on success, STATUS_??? otherwise. \par
}}{
Definition at line 975 of file MFRC522.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   975                                                          \{\par
  976     byte status;\par
  977     byte buffer[18];\par
  978     byte size = sizeof(buffer);\par
  979 \par
  980     // Read the block\par
  981     status = MIFARE_Read(blockAddr, buffer, &size);\par
  982     if (status == STATUS_OK) \{\par
  983       // Extract the value\par
  984       *value = (long(buffer[3])<<24) | (long(buffer[2])<<16) | (long(buffer[1])<<8) | long(buffer[0]);\par
  985     \}\par
  986     return status;\par
  987 \} // End MIFARE_GetValue()\par
}
}
{\xe \v MIFARE_Increment\:MFRC522}
{\xe \v MFRC522\:MIFARE_Increment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::MIFARE_Increment (byte  {\i blockAddr}, long  {\i delta})}}
\par
{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
MIFARE Increment adds the delta to the value of the addressed block, and stores the result in a volatile memory. For MIFARE Classic only. The sector containing the block must be authenticated before calling this function. Only for blocks in "value block" mode, ie with access bits [C1 C2 C3] = [110] or [001]. Use {\b MIFARE_Transfer()} to store the result in a block.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid STATUS_OK on success, STATUS_??? otherwise. \par
}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i blockAddr} \cell }{The block (0-0xff) number. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i delta} \cell }{This number is added to the value of block blockAddr. \cell }
{\row }
}
}{
Definition at line 891 of file MFRC522.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   893                               \{\par
  894     return MIFARE_TwoStepHelper(PICC_CMD_MF_INCREMENT, blockAddr, delta);\par
  895 \} // End MIFARE_Increment()\par
}
}
{\xe \v MIFARE_OpenUidBackdoor\:MFRC522}
{\xe \v MFRC522\:MIFARE_OpenUidBackdoor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MFRC522::MIFARE_OpenUidBackdoor (bool  {\i logErrors})}}
\par
{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs the "magic sequence" needed to get Chinese UID changeable Mifare cards to allow writing to sector 0, where the card UID is stored.\par
Note that you do not need to have selected the card through REQA or WUPA, this sequence works immediately when the card is in the reader vicinity. This means you can use this method even on "bricked" cards that your reader does not recognise anymore (see {\b MFRC522::MIFARE_UnbrickUidSector}).\par
Of course with non-bricked devices, you're free to select them before calling this function. \par
}{
Definition at line 1445 of file MFRC522.cpp.}\par
{
Referenced by MIFARE_SetUid(), and MIFARE_UnbrickUidSector().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1445                                                    \{\par
 1446     // Magic sequence:\par
 1447     // > 50 00 57 CD (HALT + CRC)\par
 1448     // > 40 (7 bits only)\par
 1449     // < A (4 bits only)\par
 1450     // > 43\par
 1451     // < A (4 bits only)\par
 1452     // Then you can write to sector 0 without authenticating\par
 1453     \par
 1454     PICC_HaltA(); // 50 00 57 CD\par
 1455     \par
 1456     byte cmd = 0x40;\par
 1457     byte validBits = 7; /* Our command is only 7 bits. After receiving card response,\par
 1458                           this will contain amount of valid response bits. */\par
 1459     byte response[32]; // Card's response is written here\par
 1460     byte received;\par
 1461     byte status = PCD_TransceiveData(&cmd, (byte)1, response, &received, &validBits, (byte)0, false); // 40\par
 1462     if( status != STATUS_OK ) \{\par
 1463         if( logErrors ) \{\par
 1464             Serial.println("Card did not respond to 0x40 after HALT command. Are you sure it is a UID changeable one?");\par
 1465             Serial.print("Error name: ");\par
 1466             Serial.println(GetStatusCodeName(status));\par
 1467         \}\par
 1468         return false;\par
 1469     \}\par
 1470     if ( received != 1 || response[0] != 0x0A ) \{\par
 1471         if ( logErrors ) \{\par
 1472             Serial.print("Got bad response on backdoor 0x40 command: ");\par
 1473             Serial.print(response[0], HEX);\par
 1474             Serial.print(" (");\par
 1475             Serial.print(validBits);\par
 1476             Serial.print(" valid bits)\\r\\n");\par
 1477         \}\par
 1478         return false;\par
 1479     \}\par
 1480     \par
 1481     cmd = 0x43;\par
 1482     validBits = 8;\par
 1483     status = PCD_TransceiveData(&cmd, (byte)1, response, &received, &validBits, (byte)0, false); // 43\par
 1484     if( status != STATUS_OK ) \{\par
 1485         if( logErrors ) \{\par
 1486             Serial.println("Error in communication at command 0x43, after successfully executing 0x40");\par
 1487             Serial.print("Error name: ");\par
 1488             Serial.println(GetStatusCodeName(status));\par
 1489         \}\par
 1490         return false;\par
 1491     \}\par
 1492     if ( received != 1 || response[0] != 0x0A ) \{\par
 1493         if ( logErrors ) \{\par
 1494             Serial.print("Got bad response on backdoor 0x43 command: ");\par
 1495             Serial.print(response[0], HEX);\par
 1496             Serial.print(" (");\par
 1497             Serial.print(validBits);\par
 1498             Serial.print(" valid bits)\\r\\n");\par
 1499         \}\par
 1500         return false;\par
 1501     \}\par
 1502     \par
 1503     // You can now write to sector 0 without authenticating!\par
 1504     return true;\par
 1505 \} // End MIFARE_OpenUidBackdoor()\par
}
}
{\xe \v MIFARE_Read\:MFRC522}
{\xe \v MFRC522\:MIFARE_Read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::MIFARE_Read (byte  {\i blockAddr}, byte *  {\i buffer}, byte *  {\i bufferSize})}}
\par
{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads 16 bytes (+ 2 bytes CRC_A) from the active PICC.\par
For MIFARE Classic the sector containing the block must be authenticated before calling this function.\par
For MIFARE Ultralight only addresses 00h to 0Fh are decoded. The MF0ICU1 returns a NAK for higher addresses. The MF0ICU1 responds to the READ command by sending 16 bytes starting from the page address defined by the command argument. For example; if blockAddr is 03h then pages 03h, 04h, 05h, 06h are returned. A roll-back is implemented: If blockAddr is 0Eh, then the contents of pages 0Eh, 0Fh, 00h and 01h are returned.\par
The buffer must be at least 18 bytes because a CRC_A is also returned. Checks the CRC_A before returning STATUS_OK.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid STATUS_OK on success, STATUS_??? otherwise. \par
}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i blockAddr} \cell }{MIFARE Classic: The block (0-0xff) number. MIFARE Ultralight: The first page to return data from. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buffer} \cell }{The buffer to store the data in \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bufferSize} \cell }{Buffer size, at least 18 bytes. Also number of bytes returned if STATUS_OK. \cell }
{\row }
}
}{
Definition at line 774 of file MFRC522.cpp.}\par
{
References STATUS_NO_ROOM.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   777                           \{\par
  778     byte result;\par
  779     \par
  780     // Sanity check\par
  781     if (buffer == NULL || *bufferSize < 18) \{\par
  782         return STATUS_NO_ROOM;\par
  783     \}\par
  784 \par
  785     // Build command buffer\par
  786     buffer[0] = PICC_CMD_MF_READ;\par
  787     buffer[1] = blockAddr;\par
  788     // Calculate CRC_A\par
  789     result = PCD_CalculateCRC(buffer, 2, &buffer[2]);\par
  790     if (result != STATUS_OK) \{\par
  791         return result;\par
  792     \}\par
  793     \par
  794     // Transmit the buffer and receive the response, validate CRC_A.\par
  795     return PCD_TransceiveData(buffer, 4, buffer, bufferSize, NULL, 0, true);\par
  796 \} // End MIFARE_Read()\par
}
}
{\xe \v MIFARE_Restore\:MFRC522}
{\xe \v MFRC522\:MIFARE_Restore}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::MIFARE_Restore (byte  {\i blockAddr})}}
\par
{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
MIFARE Restore copies the value of the addressed block into a volatile memory. For MIFARE Classic only. The sector containing the block must be authenticated before calling this function. Only for blocks in "value block" mode, ie with access bits [C1 C2 C3] = [110] or [001]. Use {\b MIFARE_Transfer()} to store the result in a block.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid STATUS_OK on success, STATUS_??? otherwise. \par
}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i blockAddr} \cell }{The block (0-0xff) number. \cell }
{\row }
}
}{
Definition at line 905 of file MFRC522.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   906                               \{\par
  907     // The datasheet describes Restore as a two step operation, but does not explain what data to transfer in step 2.\par
  908     // Doing only a single step does not work, so I chose to transfer 0L in step two.\par
  909     return MIFARE_TwoStepHelper(PICC_CMD_MF_RESTORE, blockAddr, 0L);\par
  910 \} // End MIFARE_Restore()\par
}
}
{\xe \v MIFARE_SetAccessBits\:MFRC522}
{\xe \v MFRC522\:MIFARE_SetAccessBits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MFRC522::MIFARE_SetAccessBits (byte *  {\i accessBitBuffer}, byte  {\i g0}, byte  {\i g1}, byte  {\i g2}, byte  {\i g3})}}
\par
{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the bit pattern needed for the specified access bits. In the [C1 C2 C3] tupples C1 is MSB (=4) and C3 is LSB (=1). \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i accessBitBuffer} \cell }{Pointer to byte 6, 7 and 8 in the sector trailer. Bytes [0..2] will be set. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i g0} \cell }{Access bits [C1 C2 C3] for block 0 (for sectors 0-31) or blocks 0-4 (for sectors 32-39) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i g1} \cell }{Access bits C1 C2 C3] for block 1 (for sectors 0-31) or blocks 5-9 (for sectors 32-39) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i g2} \cell }{Access bits C1 C2 C3] for block 2 (for sectors 0-31) or blocks 10-14 (for sectors 32-39) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i g3} \cell }{Access bits C1 C2 C3] for the sector trailer, block 3 (for sectors 0-31) or block 15 (for sectors 32-39) \cell }
{\row }
}
}{
Definition at line 1419 of file MFRC522.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1424                                   \{\par
 1425     byte c1 = ((g3 & 4) << 1) | ((g2 & 4) << 0) | ((g1 & 4) >> 1) | ((g0 & 4) >> 2);\par
 1426     byte c2 = ((g3 & 2) << 2) | ((g2 & 2) << 1) | ((g1 & 2) << 0) | ((g0 & 2) >> 1);\par
 1427     byte c3 = ((g3 & 1) << 3) | ((g2 & 1) << 2) | ((g1 & 1) << 1) | ((g0 & 1) << 0);\par
 1428     \par
 1429     accessBitBuffer[0] = (~c2 & 0xF) << 4 | (~c1 & 0xF);\par
 1430     accessBitBuffer[1] =          c1 << 4 | (~c3 & 0xF);\par
 1431     accessBitBuffer[2] =          c3 << 4 | c2;\par
 1432 \} // End MIFARE_SetAccessBits()\par
}
}
{\xe \v MIFARE_SetUid\:MFRC522}
{\xe \v MFRC522\:MIFARE_SetUid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MFRC522::MIFARE_SetUid (byte *  {\i newUid}, byte  {\i uidSize}, bool  {\i logErrors})}}
\par
{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads entire block 0, including all manufacturer data, and overwrites that block with the new UID, a freshly calculated BCC, and the original manufacturer data.\par
It assumes a default KEY A of 0xFFFFFFFFFFFF. Make sure to have selected the card before this function is called. \par
}{
Definition at line 1515 of file MFRC522.cpp.}\par
{
References MIFARE_OpenUidBackdoor(), PCD_StopCrypto1(), PICC_IsNewCardPresent(), and PICC_ReadCardSerial().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1515                                                                       \{\par
 1516     \par
 1517     // UID + BCC byte can not be larger than 16 together\par
 1518     if ( !newUid || !uidSize || uidSize > 15) \{\par
 1519         if ( logErrors ) \{\par
 1520             Serial.println("New UID buffer empty, size 0, or size > 15 given");\par
 1521         \}\par
 1522         return false;\par
 1523     \}\par
 1524     \par
 1525     // Authenticate for reading\par
 1526     MIFARE_Key key = \{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\};\par
 1527     byte status = PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_A, (byte)1, &key, &uid);\par
 1528     if ( status != STATUS_OK ) \{\par
 1529         \par
 1530         if ( status == STATUS_TIMEOUT ) \{\par
 1531             // We get a read timeout if no card is selected yet, so let's select one\par
 1532             \par
 1533             // Wake the card up again if sleeping\par
 1534 //            byte atqa_answer[2];\par
 1535 //            byte atqa_size = 2;\par
 1536 //            PICC_WakeupA(atqa_answer, &atqa_size);\par
 1537             \par
 1538             if ( !PICC_IsNewCardPresent() || !PICC_ReadCardSerial() ) \{\par
 1539                 Serial.println("No card was previously selected, and none are available. Failed to set UID.");\par
 1540                 return false;\par
 1541             \}\par
 1542             \par
 1543             status = PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_A, (byte)1, &key, &uid);\par
 1544             if ( status != STATUS_OK ) \{\par
 1545                 // We tried, time to give up\par
 1546                 if ( logErrors ) \{\par
 1547                     Serial.println("Failed to authenticate to card for reading, could not set UID: ");\par
 1548                     Serial.println(GetStatusCodeName(status));\par
 1549                 \}\par
 1550                 return false;\par
 1551             \}\par
 1552         \}\par
 1553         else \{\par
 1554             if ( logErrors ) \{\par
 1555                 Serial.print("PCD_Authenticate() failed: ");\par
 1556                 Serial.println(GetStatusCodeName(status));\par
 1557             \}\par
 1558             return false;\par
 1559         \}\par
 1560     \}\par
 1561     \par
 1562     // Read block 0\par
 1563     byte block0_buffer[18];\par
 1564     byte byteCount = sizeof(block0_buffer);\par
 1565     status = MIFARE_Read((byte)0, block0_buffer, &byteCount);\par
 1566     if ( status != STATUS_OK ) \{\par
 1567         if ( logErrors ) \{\par
 1568             Serial.print("MIFARE_Read() failed: ");\par
 1569             Serial.println(GetStatusCodeName(status));\par
 1570             Serial.println("Are you sure your KEY A for sector 0 is 0xFFFFFFFFFFFF?");\par
 1571         \}\par
 1572         return false;\par
 1573     \}\par
 1574     \par
 1575     // Write new UID to the data we just read, and calculate BCC byte\par
 1576     byte bcc = 0;\par
 1577     for ( int i = 0; i < uidSize; i++ ) \{\par
 1578         block0_buffer[i] = newUid[i];\par
 1579         bcc ^= newUid[i];\par
 1580     \}\par
 1581     \par
 1582     // Write BCC byte to buffer\par
 1583     block0_buffer[uidSize] = bcc;\par
 1584     \par
 1585     // Stop encrypted traffic so we can send raw bytes\par
 1586     PCD_StopCrypto1();\par
 1587     \par
 1588     // Activate UID backdoor\par
 1589     if ( !MIFARE_OpenUidBackdoor(logErrors) ) \{\par
 1590         if ( logErrors ) \{\par
 1591             Serial.println("Activating the UID backdoor failed.");\par
 1592         \}\par
 1593         return false;\par
 1594     \}\par
 1595     \par
 1596     // Write modified block 0 back to card\par
 1597     status = MIFARE_Write((byte)0, block0_buffer, (byte)16);\par
 1598     if (status != STATUS_OK) \{\par
 1599         if ( logErrors ) \{\par
 1600             Serial.print("MIFARE_Write() failed: ");\par
 1601             Serial.println(GetStatusCodeName(status));\par
 1602         \}\par
 1603         return false;\par
 1604     \}\par
 1605     \par
 1606     // Wake the card up again\par
 1607     byte atqa_answer[2];\par
 1608     byte atqa_size = 2;\par
 1609     PICC_WakeupA(atqa_answer, &atqa_size);\par
 1610     \par
 1611     return true;\par
 1612 \}\par
}
}
{\xe \v MIFARE_SetValue\:MFRC522}
{\xe \v MFRC522\:MIFARE_SetValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::MIFARE_SetValue (byte  {\i blockAddr}, long  {\i value})}}
\par
{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper routine to write a specific value into a Value Block.\par
Only for MIFARE Classic and only for blocks in "value block" mode, that is: with access bits [C1 C2 C3] = [110] or [001]. The sector containing the block must be authenticated before calling this function.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i blockAddr} \cell }{The block (0x00-0xff) number. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i value} \cell }{New value of the Value Block. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid STATUS_OK on success, STATUS_??? otherwise. \par
}}{
Definition at line 1000 of file MFRC522.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1000                                                         \{\par
 1001     byte buffer[18];\par
 1002 \par
 1003     // Translate the long into 4 bytes; repeated 2x in value block\par
 1004     buffer[0] = buffer[ 8] = (value & 0xFF);\par
 1005     buffer[1] = buffer[ 9] = (value & 0xFF00) >> 8;\par
 1006     buffer[2] = buffer[10] = (value & 0xFF0000) >> 16;\par
 1007     buffer[3] = buffer[11] = (value & 0xFF000000) >> 24;\par
 1008     // Inverse 4 bytes also found in value block\par
 1009     buffer[4] = ~buffer[0];\par
 1010     buffer[5] = ~buffer[1];\par
 1011     buffer[6] = ~buffer[2];\par
 1012     buffer[7] = ~buffer[3];\par
 1013     // Address 2x with inverse address 2x\par
 1014     buffer[12] = buffer[14] = blockAddr;\par
 1015     buffer[13] = buffer[15] = ~blockAddr;\par
 1016 \par
 1017     // Write the whole data block\par
 1018     return MIFARE_Write(blockAddr, buffer, 16);\par
 1019 \} // End MIFARE_SetValue()\par
}
}
{\xe \v MIFARE_Transfer\:MFRC522}
{\xe \v MFRC522\:MIFARE_Transfer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::MIFARE_Transfer (byte  {\i blockAddr})}}
\par
{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
MIFARE Transfer writes the value stored in the volatile memory into one MIFARE Classic block. For MIFARE Classic only. The sector containing the block must be authenticated before calling this function. Only for blocks in "value block" mode, ie with access bits [C1 C2 C3] = [110] or [001].\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid STATUS_OK on success, STATUS_??? otherwise. \par
}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i blockAddr} \cell }{The block (0-0xff) number. \cell }
{\row }
}
}{
Definition at line 948 of file MFRC522.cpp.}\par
{
References STATUS_OK.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   949                               \{\par
  950     byte result;\par
  951     byte cmdBuffer[2]; // We only need room for 2 bytes.\par
  952 \par
  953     // Tell the PICC we want to transfer the result into block blockAddr.\par
  954     cmdBuffer[0] = PICC_CMD_MF_TRANSFER;\par
  955     cmdBuffer[1] = blockAddr;\par
  956     result = PCD_MIFARE_Transceive( cmdBuffer, 2); // Adds CRC_A and checks that the response is MF_ACK.\par
  957     if (result != STATUS_OK) \{\par
  958         return result;\par
  959     \}\par
  960     return STATUS_OK;\par
  961 \} // End MIFARE_Transfer()\par
}
}
{\xe \v MIFARE_TwoStepHelper\:MFRC522}
{\xe \v MFRC522\:MIFARE_TwoStepHelper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::MIFARE_TwoStepHelper (byte  {\i command}, byte  {\i blockAddr}, long  {\i data}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper function for the two-step MIFARE Classic protocol operations Decrement, Increment and Restore.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid STATUS_OK on success, STATUS_??? otherwise. \par
}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i command} \cell }{The command to use \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i blockAddr} \cell }{The block (0-0xff) number. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{The data to transfer in step 2 \cell }
{\row }
}
}{
Definition at line 917 of file MFRC522.cpp.}\par
{
References STATUS_OK.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   920                                       \{\par
  921     byte result;\par
  922     byte cmdBuffer[2]; // We only need room for 2 bytes.\par
  923 \par
  924     // Step 1: Tell the PICC the command and block address\par
  925     cmdBuffer[0] = command;\par
  926     cmdBuffer[1] = blockAddr;\par
  927     result = PCD_MIFARE_Transceive( cmdBuffer, 2); // Adds CRC_A and checks that the response is MF_ACK.\par
  928     if (result != STATUS_OK) \{\par
  929         return result;\par
  930     \}\par
  931 \par
  932     // Step 2: Transfer the data\par
  933     result = PCD_MIFARE_Transceive( (byte *)&data, 4, true); // Adds CRC_A and accept timeout as success.\par
  934     if (result != STATUS_OK) \{\par
  935         return result;\par
  936     \}\par
  937 \par
  938     return STATUS_OK;\par
  939 \} // End MIFARE_TwoStepHelper()\par
}
}
{\xe \v MIFARE_Ultralight_Write\:MFRC522}
{\xe \v MFRC522\:MIFARE_Ultralight_Write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::MIFARE_Ultralight_Write (byte  {\i page}, byte *  {\i buffer}, byte  {\i bufferSize})}}
\par
{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Writes a 4 byte page to the active MIFARE Ultralight PICC.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid STATUS_OK on success, STATUS_??? otherwise. \par
}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i page} \cell }{The page (2-15) to write to. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buffer} \cell }{The 4 bytes to write to the PICC \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bufferSize} \cell }{Buffer size, must be at least 4 bytes. Exactly 4 bytes are written. \cell }
{\row }
}
}{
Definition at line 844 of file MFRC522.cpp.}\par
{
References STATUS_INVALID, and STATUS_OK.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   847                                       \{\par
  848     byte result;\par
  849 \par
  850     // Sanity check\par
  851     if (buffer == NULL || bufferSize < 4) \{\par
  852         return STATUS_INVALID;\par
  853     \}\par
  854 \par
  855     // Build commmand buffer\par
  856     byte cmdBuffer[6];\par
  857     cmdBuffer[0] = PICC_CMD_UL_WRITE;\par
  858     cmdBuffer[1] = page;\par
  859     memcpy(&cmdBuffer[2], buffer, 4);\par
  860     \par
  861     // Perform the write\par
  862     result = PCD_MIFARE_Transceive(cmdBuffer, 6); // Adds CRC_A and checks that the response is MF_ACK.\par
  863     if (result != STATUS_OK) \{\par
  864         return result;\par
  865     \}\par
  866     return STATUS_OK;\par
  867 \} // End MIFARE_Ultralight_Write()\par
}
}
{\xe \v MIFARE_UnbrickUidSector\:MFRC522}
{\xe \v MFRC522\:MIFARE_UnbrickUidSector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MFRC522::MIFARE_UnbrickUidSector (bool  {\i logErrors})}}
\par
{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resets entire sector 0 to zeroes, so the card can be read again by readers. \par
}{
Definition at line 1617 of file MFRC522.cpp.}\par
{
References MIFARE_OpenUidBackdoor().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1617                                                     \{\par
 1618     MIFARE_OpenUidBackdoor( logErrors );\par
 1619     \par
 1620     byte block0_buffer[] = \{0x01, 0x02, 0x03, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\};\par
 1621     \par
 1622     // Write modified block 0 back to card\par
 1623     byte status = MIFARE_Write((byte)0, block0_buffer, (byte)16);\par
 1624     if (status != STATUS_OK) \{\par
 1625         if ( logErrors ) \{\par
 1626             Serial.print("MIFARE_Write() failed: ");\par
 1627             Serial.println(GetStatusCodeName(status));\par
 1628         \}\par
 1629         return false;\par
 1630     \}\par
 1631 \}\par
}
}
{\xe \v MIFARE_Write\:MFRC522}
{\xe \v MFRC522\:MIFARE_Write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::MIFARE_Write (byte  {\i blockAddr}, byte *  {\i buffer}, byte  {\i bufferSize})}}
\par
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Writes 16 bytes to the active PICC.\par
For MIFARE Classic the sector containing the block must be authenticated before calling this function.\par
For MIFARE Ultralight the opretaion is called "COMPATIBILITY WRITE". Even though 16 bytes are transferred to the Ultralight PICC, only the least significant 4 bytes (bytes 0 to 3) are written to the specified address. It is recommended to set the remaining bytes 04h to 0Fh to all logic 0.{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s63\li1080\widctlpar\ql\adjustright \fs20\cgrid STATUS_OK on success, STATUS_??? otherwise. \par
}\par}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i blockAddr} \cell }{MIFARE Classic: The block (0-0xff) number. MIFARE Ultralight: The page (2-15) to write to. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buffer} \cell }{The 16 bytes to write to the PICC \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bufferSize} \cell }{Buffer size, must be at least 16 bytes. Exactly 16 bytes are written. \cell }
{\row }
}
}{
Definition at line 809 of file MFRC522.cpp.}\par
{
References STATUS_INVALID, and STATUS_OK.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   812                           \{\par
  813     byte result;\par
  814 \par
  815     // Sanity check\par
  816     if (buffer == NULL || bufferSize < 16) \{\par
  817         return STATUS_INVALID;\par
  818     \}\par
  819 \par
  820     // Mifare Classic protocol requires two communications to perform a write.\par
  821     // Step 1: Tell the PICC we want to write to block blockAddr.\par
  822     byte cmdBuffer[2];\par
  823     cmdBuffer[0] = PICC_CMD_MF_WRITE;\par
  824     cmdBuffer[1] = blockAddr;\par
  825     result = PCD_MIFARE_Transceive(cmdBuffer, 2); // Adds CRC_A and checks that the response is MF_ACK.\par
  826     if (result != STATUS_OK) \{\par
  827         return result;\par
  828     \}\par
  829 \par
  830     // Step 2: Transfer the data\par
  831     result = PCD_MIFARE_Transceive( buffer, bufferSize); // Adds CRC_A and checks that the response is MF_ACK.\par
  832     if (result != STATUS_OK) \{\par
  833         return result;\par
  834     \}\par
  835 \par
  836     return STATUS_OK;\par
  837 \} // End MIFARE_Write()\par
}
}
{\xe \v PCD_AntennaOff\:MFRC522}
{\xe \v MFRC522\:PCD_AntennaOff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MFRC522::PCD_AntennaOff ()}}
\par
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Turns the antenna off by disabling pins TX1 and TX2. \par
}{
Definition at line 250 of file MFRC522.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   250                              \{\par
  251     PCD_ClearRegisterBitMask(RFCfgReg, 0x03);\par
  252 \} // End PCD_AntennaOff()\par
}
}
{\xe \v PCD_AntennaOn\:MFRC522}
{\xe \v MFRC522\:PCD_AntennaOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MFRC522::PCD_AntennaOn ()}}
\par
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Turns the antenna on by enabling pins TX1 and TX2. After a reset these pins disabled. \par
}{
Definition at line 240 of file MFRC522.cpp.}\par
{
Referenced by PCD_Init().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   240                             \{\par
  241     byte value = PCD_ReadRegister(TxControlReg);\par
  242     if ((value & 0x03) != 0x03) \{\par
  243         PCD_WriteRegister(TxControlReg, value | 0x03);\par
  244     \}\par
  245 \} // End PCD_AntennaOn()\par
}
}
{\xe \v PCD_Authenticate\:MFRC522}
{\xe \v MFRC522\:PCD_Authenticate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::PCD_Authenticate (byte  {\i command}, byte  {\i blockAddr}, {\b MIFARE_Key} *  {\i key}, {\b Uid} *  {\i uid})}}
\par
{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Executes the {\b MFRC522} MFAuthent command. This command manages MIFARE authentication to enable a secure communication to any MIFARE Mini, MIFARE 1K and MIFARE 4K card. The authentication is described in the {\b MFRC522} datasheet section 10.3.1.9 and {\f2 http://www.nxp.com/documents/data_sheet/MF1S503x.pdf} section 10.1. For use with MIFARE Classic PICCs. The PICC must be selected - ie in state ACTIVE(*) - before calling this function. Remember to call {\b PCD_StopCrypto1()} after communicating with the authenticated PICC - otherwise no new communications can start.\par
All keys are set to FFFFFFFFFFFFh at chip delivery.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid STATUS_OK on success, STATUS_??? otherwise. Probably STATUS_TIMEOUT if you supply the wrong key. \par
}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i command} \cell }{PICC_CMD_MF_AUTH_KEY_A or PICC_CMD_MF_AUTH_KEY_B \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i blockAddr} \cell }{The block number. See numbering in the comments in the .h file. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i key} \cell }{Pointer to the Crypteo1 key to use (6 bytes) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uid} \cell }{Pointer to {\b Uid} struct. The first 4 bytes of the UID is used. \cell }
{\row }
}
}{
Definition at line 727 of file MFRC522.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   731                                   \{\par
  732     byte waitIRq = 0x10;        // IdleIRq\par
  733     \par
  734     // Build command buffer\par
  735     byte sendData[12];\par
  736     sendData[0] = command;\par
  737     sendData[1] = blockAddr;\par
  738     for (byte i = 0; i < MF_KEY_SIZE; i++) \{    // 6 key bytes\par
  739         sendData[2+i] = key->keyByte[i];\par
  740     \}\par
  741     for (byte i = 0; i < 4; i++) \{              // The first 4 bytes of the UID\par
  742         sendData[8+i] = uid->uidByte[i];\par
  743     \}\par
  744     \par
  745     // Start the authentication.\par
  746     return PCD_CommunicateWithPICC(PCD_MFAuthent, waitIRq, &sendData[0], sizeof(sendData));\par
  747 \} // End PCD_Authenticate()\par
}
}
{\xe \v PCD_CalculateCRC\:MFRC522}
{\xe \v MFRC522\:PCD_CalculateCRC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::PCD_CalculateCRC (byte *  {\i data}, byte  {\i length}, byte *  {\i result})}}
\par
{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Use the CRC coprocessor in the {\b MFRC522} to calculate a CRC_A.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid STATUS_OK on success, STATUS_??? otherwise. \par
}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{In: Pointer to the data to transfer to the FIFO for CRC calculation. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i length} \cell }{In: The number of bytes to transfer. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i result} \cell }{Out: Pointer to result buffer. Result is written to result[0..1], low byte first. \cell }
{\row }
}
}{
Definition at line 160 of file MFRC522.cpp.}\par
{
References STATUS_OK, and STATUS_TIMEOUT.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   163                        \{\par
  164     PCD_WriteRegister(CommandReg, PCD_Idle);            // Stop any active command.\par
  165     PCD_WriteRegister(DivIrqReg, 0x04);                 // Clear the CRCIRq interrupt request bit\par
  166     PCD_SetRegisterBitMask(FIFOLevelReg, 0x80);     // FlushBuffer = 1, FIFO initialization\par
  167     PCD_WriteRegister(FIFODataReg, length, data);       // Write data to the FIFO\par
  168     PCD_WriteRegister(CommandReg, PCD_CalcCRC);     // Start the calculation\par
  169     \par
  170     // Wait for the CRC calculation to complete. Each iteration of the while-loop takes 17.73\'EF\'BF\'BDs.\par
  171     word i = 5000;\par
  172     byte n;\par
  173     while (1) \{\par
  174         n = PCD_ReadRegister(DivIrqReg);    // DivIrqReg[7..0] bits are: Set2 reserved reserved MfinActIRq   reserved CRCIRq reserved reserved\par
  175         if (n & 0x04) \{                     // CRCIRq bit set - calculation done\par
  176             break;\par
  177         \}\par
  178         if (--i == 0) \{                     // The emergency break. We will eventually terminate on this one after 89ms. Communication with the MFRC522 might be down.\par
  179             return STATUS_TIMEOUT;\par
  180         \}\par
  181     \}\par
  182     PCD_WriteRegister(CommandReg, PCD_Idle);            // Stop calculating CRC for new content in the FIFO.\par
  183     \par
  184     // Transfer the result from the registers to the result buffer\par
  185     result[0] = PCD_ReadRegister(CRCResultRegL);\par
  186     result[1] = PCD_ReadRegister(CRCResultRegH);\par
  187     return STATUS_OK;\par
  188 \} // End PCD_CalculateCRC()\par
}
}
{\xe \v PCD_ClearRegisterBitMask\:MFRC522}
{\xe \v MFRC522\:PCD_ClearRegisterBitMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MFRC522::PCD_ClearRegisterBitMask (byte  {\i reg}, byte  {\i mask})}}
\par
{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears the bits given in mask from register reg. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i reg} \cell }{The register to update. One of the PCD_Register enums. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i mask} \cell }{The bits to clear. \cell }
{\row }
}
}{
Definition at line 146 of file MFRC522.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   148                                         \{\par
  149     byte tmp;\par
  150     tmp = PCD_ReadRegister(reg);\par
  151     PCD_WriteRegister(reg, tmp & (~mask));      // clear bit mask\par
  152 \} // End PCD_ClearRegisterBitMask()\par
}
}
{\xe \v PCD_CommunicateWithPICC\:MFRC522}
{\xe \v MFRC522\:PCD_CommunicateWithPICC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::PCD_CommunicateWithPICC (byte  {\i command}, byte  {\i waitIRq}, byte *  {\i sendData}, byte  {\i sendLen}, byte *  {\i backData} = {\f2 NULL}, byte *  {\i backLen} = {\f2 NULL}, byte *  {\i validBits} = {\f2 NULL}, byte  {\i rxAlign} = {\f2 0}, bool  {\i checkCRC} = {\f2 false})}}
\par
{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Transfers data to the {\b MFRC522} FIFO, executes a commend, waits for completion and transfers data back from the FIFO. CRC validation can only be done if backData and backLen are specified.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid STATUS_OK on success, STATUS_??? otherwise. \par
}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i command} \cell }{The command to execute. One of the PCD_Command enums. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i waitIRq} \cell }{The bits in the ComIrqReg register that signals successful completion of the command. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sendData} \cell }{Pointer to the data to transfer to the FIFO. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sendLen} \cell }{Number of bytes to transfer to the FIFO. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i backData} \cell }{NULL or pointer to buffer if data should be read back after executing the command. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i backLen} \cell }{In: Max number of bytes to write to *backData. Out: The number of bytes returned. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i validBits} \cell }{In/Out: The number of valid bits in the last byte. 0 for 8 valid bits. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rxAlign} \cell }{In: Defines the bit position in backData[0] for the first bit received. Default 0. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i checkCRC} \cell }{In: True => The last two bytes of the response is assumed to be a CRC_A that must be validated. \cell }
{\row }
}
}{
Definition at line 305 of file MFRC522.cpp.}\par
{
References STATUS_COLLISION, STATUS_CRC_WRONG, STATUS_ERROR, STATUS_MIFARE_NACK, STATUS_NO_ROOM, STATUS_OK, and STATUS_TIMEOUT.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   314                                        \{\par
  315     byte n, _validBits;\par
  316     unsigned int i;\par
  317 \par
  318     // Prepare values for BitFramingReg\par
  319     byte txLastBits = validBits ? *validBits : 0;\par
  320     byte bitFraming = (rxAlign << 4) + txLastBits;      // RxAlign = BitFramingReg[6..4]. TxLastBits = BitFramingReg[2..0]\par
  321     \par
  322     PCD_WriteRegister(CommandReg, PCD_Idle);            // Stop any active command.\par
  323     PCD_WriteRegister(ComIrqReg, 0x7F);                 // Clear all seven interrupt request bits\par
  324     PCD_SetRegisterBitMask(FIFOLevelReg, 0x80);     // FlushBuffer = 1, FIFO initialization\par
  325     PCD_WriteRegister(FIFODataReg, sendLen, sendData);  // Write sendData to the FIFO\par
  326     PCD_WriteRegister(BitFramingReg, bitFraming);       // Bit adjustments\par
  327     PCD_WriteRegister(CommandReg, command);         // Execute the command\par
  328     if (command == PCD_Transceive)  \{\par
  329         PCD_SetRegisterBitMask(BitFramingReg, 0x80);    // StartSend=1, transmission of data starts\par
  330     \}\par
  331     \par
  332     // Wait for the command to complete.\par
  333     // In PCD_Init() we set the TAuto flag in TModeReg. This means the timer automatically starts when the PCD stops transmitting.\par
  334     // Each iteration of the do-while-loop takes 17.86\'EF\'BF\'BDs.\par
  335     i = 2000;\par
  336     while (1) \{\par
  337         n = PCD_ReadRegister(ComIrqReg);    // ComIrqReg[7..0] bits are: Set1 TxIRq RxIRq IdleIRq   HiAlertIRq LoAlertIRq ErrIRq TimerIRq\par
  338         if (n & waitIRq) \{                  // One of the interrupts that signal success has been set.\par
  339             break;\par
  340         \}\par
  341         if (n & 0x01) \{                     // Timer interrupt - nothing received in 25ms\par
  342             return STATUS_TIMEOUT;\par
  343         \}\par
  344         if (--i == 0) \{                     // The emergency break. If all other condions fail we will eventually terminate on this one after 35.7ms. Communication with the MFRC522 might be down.\par
  345             return STATUS_TIMEOUT;\par
  346         \}\par
  347     \}\par
  348     \par
  349     // Stop now if any errors except collisions were detected.\par
  350     byte errorRegValue = PCD_ReadRegister(ErrorReg); // ErrorReg[7..0] bits are: WrErr TempErr reserved BufferOvfl   CollErr CRCErr ParityErr ProtocolErr\par
  351     if (errorRegValue & 0x13) \{  // BufferOvfl ParityErr ProtocolErr\par
  352         return STATUS_ERROR;\par
  353     \}   \par
  354 \par
  355     // If the caller wants data back, get it from the MFRC522.\par
  356     if (backData && backLen) \{\par
  357         n = PCD_ReadRegister(FIFOLevelReg);                     // Number of bytes in the FIFO\par
  358         if (n > *backLen) \{\par
  359             return STATUS_NO_ROOM;\par
  360         \}\par
  361         *backLen = n;                                               // Number of bytes returned\par
  362         PCD_ReadRegister(FIFODataReg, n, backData, rxAlign);        // Get received data from FIFO\par
  363         _validBits = PCD_ReadRegister(ControlReg) & 0x07;   // RxLastBits[2:0] indicates the number of valid bits in the last received byte. If this value is 000b, the whole byte is valid.\par
  364         if (validBits) \{\par
  365             *validBits = _validBits;\par
  366         \}\par
  367     \}\par
  368     \par
  369     // Tell about collisions\par
  370     if (errorRegValue & 0x08) \{ // CollErr\par
  371         return STATUS_COLLISION;\par
  372     \}\par
  373     \par
  374     // Perform CRC_A validation if requested.\par
  375     if (backData && backLen && checkCRC) \{\par
  376         // In this case a MIFARE Classic NAK is not OK.\par
  377         if (*backLen == 1 && _validBits == 4) \{\par
  378             return STATUS_MIFARE_NACK;\par
  379         \}\par
  380         // We need at least the CRC_A value and all 8 bits of the last byte must be received.\par
  381         if (*backLen < 2 || _validBits != 0) \{\par
  382             return STATUS_CRC_WRONG;\par
  383         \}\par
  384         // Verify CRC_A - do our own calculation and store the control in controlBuffer.\par
  385         byte controlBuffer[2]; \par
  386         n = PCD_CalculateCRC(&backData[0], *backLen - 2, &controlBuffer[0]);\par
  387         if (n != STATUS_OK) \{\par
  388             return n;\par
  389         \}\par
  390         if ((backData[*backLen - 2] != controlBuffer[0]) || (backData[*backLen - 1] != controlBuffer[1])) \{\par
  391             return STATUS_CRC_WRONG;\par
  392         \}\par
  393     \}\par
  394     \par
  395     return STATUS_OK;\par
  396 \} // End PCD_CommunicateWithPICC()\par
}
}
{\xe \v PCD_GetAntennaGain\:MFRC522}
{\xe \v MFRC522\:PCD_GetAntennaGain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::PCD_GetAntennaGain ()}}
\par
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the current {\b MFRC522} Receiver Gain (RxGain[2:0]) value. See 9.3.3.6 / table 98 in {\f2 http://www.nxp.com/documents/data_sheet/MFRC522.pdf} NOTE: Return value scrubbed with (0x07<<4)=01110000b as RCFfgReg may use reserved bits.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Value of the RxGain, scrubbed to the 3 bits used. \par
}}{
Definition at line 261 of file MFRC522.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   261                                  \{\par
  262     return PCD_ReadRegister(RFCfgReg) & (0x07<<4);\par
  263 \} // End PCD_GetAntennaGain()\par
}
}
{\xe \v PCD_Init\:MFRC522}
{\xe \v MFRC522\:PCD_Init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MFRC522::PCD_Init ()}}
\par
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes the {\b MFRC522} chip. \par
}{
Definition at line 198 of file MFRC522.cpp.}\par
{
References PCD_AntennaOn(), and PCD_Reset().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   198                        \{\par
  199     if (digitalRead(_resetPowerDownPin) == LOW) \{ //The MFRC522 chip is in power down mode.\par
  200         digitalWrite(_resetPowerDownPin, HIGH); // Exit power down mode. This triggers a hard reset.\par
  201         // Section 8.8.2 in the datasheet says the oscillator start-up time is the start up time of the crystal + 37,74\'EF\'BF\'BDs. Let us be generous: 50ms.\par
  202         delay(50);\par
  203     \}\par
  204     else \{ // Perform a soft reset\par
  205         PCD_Reset();\par
  206     \}\par
  207     \par
  208     // When communicating with a PICC we need a timeout if something goes wrong.\par
  209     // f_timer = 13.56 MHz / (2*TPreScaler+1) where TPreScaler = [TPrescaler_Hi:TPrescaler_Lo].\par
  210     // TPrescaler_Hi are the four low bits in TModeReg. TPrescaler_Lo is TPrescalerReg.\par
  211     PCD_WriteRegister(TModeReg, 0x80);          // TAuto=1; timer starts automatically at the end of the transmission in all communication modes at all speeds\par
  212     PCD_WriteRegister(TPrescalerReg, 0xA9); // TPreScaler = TModeReg[3..0]:TPrescalerReg, ie 0x0A9 = 169 => f_timer=40kHz, ie a timer period of 25\'EF\'BF\'BDs.\par
  213     PCD_WriteRegister(TReloadRegH, 0x03);       // Reload timer with 0x3E8 = 1000, ie 25ms before timeout.\par
  214     PCD_WriteRegister(TReloadRegL, 0xE8);\par
  215     \par
  216     PCD_WriteRegister(TxASKReg, 0x40);      // Default 0x00. Force a 100 % ASK modulation independent of the ModGsPReg register setting\par
  217     PCD_WriteRegister(ModeReg, 0x3D);       // Default 0x3F. Set the preset value for the CRC coprocessor for the CalcCRC command to 0x6363 (ISO 14443-3 part 6.2.4)\par
  218     PCD_AntennaOn();                        // Enable the antenna driver pins TX1 and TX2 (they were disabled by the reset)\par
  219 \} // End PCD_Init()\par
}
}
{\xe \v PCD_MIFARE_Transceive\:MFRC522}
{\xe \v MFRC522\:PCD_MIFARE_Transceive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::PCD_MIFARE_Transceive (byte *  {\i sendData}, byte  {\i sendLen}, bool  {\i acceptTimeout} = {\f2 false})}}
\par
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wrapper for MIFARE protocol communication. Adds CRC_A, executes the Transceive command and checks that the response is MF_ACK or a timeout.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid STATUS_OK on success, STATUS_??? otherwise. \par
}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sendData} \cell }{Pointer to the data to transfer to the FIFO. Do NOT include the CRC_A. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sendLen} \cell }{Number of bytes in sendData. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i acceptTimeout} \cell }{True => A timeout is also success \cell }
{\row }
}
}{
Definition at line 1032 of file MFRC522.cpp.}\par
{
References STATUS_ERROR, STATUS_INVALID, STATUS_MIFARE_NACK, and STATUS_OK.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1035                                       \{\par
 1036     byte result;\par
 1037     byte cmdBuffer[18]; // We need room for 16 bytes data and 2 bytes CRC_A.\par
 1038 \par
 1039     // Sanity check\par
 1040     if (sendData == NULL || sendLen > 16) \{\par
 1041         return STATUS_INVALID;\par
 1042     \}\par
 1043     \par
 1044     // Copy sendData[] to cmdBuffer[] and add CRC_A\par
 1045     memcpy(cmdBuffer, sendData, sendLen);\par
 1046     result = PCD_CalculateCRC(cmdBuffer, sendLen, &cmdBuffer[sendLen]);\par
 1047     if (result != STATUS_OK) \{ \par
 1048         return result;\par
 1049     \}\par
 1050     sendLen += 2;\par
 1051     \par
 1052     // Transceive the data, store the reply in cmdBuffer[]\par
 1053     byte waitIRq = 0x30;        // RxIRq and IdleIRq\par
 1054     byte cmdBufferSize = sizeof(cmdBuffer);\par
 1055     byte validBits = 0;\par
 1056     result = PCD_CommunicateWithPICC(PCD_Transceive, waitIRq, cmdBuffer, sendLen, cmdBuffer, &cmdBufferSize, &validBits);\par
 1057     if (acceptTimeout && result == STATUS_TIMEOUT) \{\par
 1058         return STATUS_OK;\par
 1059     \}\par
 1060     if (result != STATUS_OK) \{\par
 1061         return result;\par
 1062     \}\par
 1063     // The PICC must reply with a 4 bit ACK\par
 1064     if (cmdBufferSize != 1 || validBits != 4) \{\par
 1065         return STATUS_ERROR;\par
 1066     \}\par
 1067     if (cmdBuffer[0] != MF_ACK) \{\par
 1068         return STATUS_MIFARE_NACK;\par
 1069     \}\par
 1070     return STATUS_OK;\par
 1071 \} // End PCD_MIFARE_Transceive()\par
}
}
{\xe \v PCD_ReadRegister\:MFRC522}
{\xe \v MFRC522\:PCD_ReadRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::PCD_ReadRegister (byte  {\i reg})}}
\par
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a byte from the specified register in the {\b MFRC522} chip. The interface is described in the datasheet section 8.1.2. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i reg} \cell }{The register to read from. One of the PCD_Register enums. \cell }
{\row }
}
}{
Definition at line 83 of file MFRC522.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    84                                   \{\par
   85     byte value;\par
   86     digitalWrite(_chipSelectPin, LOW);          // Select slave\par
   87     SPI.transfer(0x80 | (reg & 0x7E));          // MSB == 1 is for reading. LSB is not used in address. Datasheet section 8.1.2.3.\par
   88     value = SPI.transfer(0);                    // Read the value back. Send 0 to stop reading.\par
   89     digitalWrite(_chipSelectPin, HIGH);         // Release slave again\par
   90     return value;\par
   91 \} // End PCD_ReadRegister()\par
}
}
{\xe \v PCD_ReadRegister\:MFRC522}
{\xe \v MFRC522\:PCD_ReadRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MFRC522::PCD_ReadRegister (byte  {\i reg}, byte  {\i count}, byte *  {\i values}, byte  {\i rxAlign} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads a number of bytes from the specified register in the {\b MFRC522} chip. The interface is described in the datasheet section 8.1.2. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i reg} \cell }{The register to read from. One of the PCD_Register enums. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i count} \cell }{The number of bytes to read \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i values} \cell }{Byte array to store the values in. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rxAlign} \cell }{Only bit positions rxAlign..7 in values[0] are updated. \cell }
{\row }
}
}{
Definition at line 97 of file MFRC522.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   101                                   \{\par
  102     if (count == 0) \{\par
  103         return;\par
  104     \}\par
  105     //Serial.print("Reading ");     Serial.print(count); Serial.println(" bytes from register.");\par
  106     byte address = 0x80 | (reg & 0x7E);     // MSB == 1 is for reading. LSB is not used in address. Datasheet section 8.1.2.3.\par
  107     byte index = 0;                         // Index in values array.\par
  108     digitalWrite(_chipSelectPin, LOW);      // Select slave\par
  109     count--;                                // One read is performed outside of the loop\par
  110     SPI.transfer(address);                  // Tell MFRC522 which address we want to read\par
  111     while (index < count) \{\par
  112         if (index == 0 && rxAlign) \{ // Only update bit positions rxAlign..7 in values[0]\par
  113             // Create bit mask for bit positions rxAlign..7\par
  114             byte mask = 0;\par
  115             for (byte i = rxAlign; i <= 7; i++) \{\par
  116                 mask |= (1 << i);\par
  117             \}\par
  118             // Read value and tell that we want to read the same address again.\par
  119             byte value = SPI.transfer(address); \par
  120             // Apply mask to both current value of values[0] and the new data in value.\par
  121             values[0] = (values[index] & ~mask) | (value & mask);\par
  122         \}\par
  123         else \{ // Normal case\par
  124             values[index] = SPI.transfer(address);  // Read value and tell that we want to read the same address again.\par
  125         \}\par
  126         index++;\par
  127     \}\par
  128     values[index] = SPI.transfer(0);            // Read the final byte. Send 0 to stop reading.\par
  129     digitalWrite(_chipSelectPin, HIGH);         // Release slave again\par
  130 \} // End PCD_ReadRegister()\par
}
}
{\xe \v PCD_Reset\:MFRC522}
{\xe \v MFRC522\:PCD_Reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MFRC522::PCD_Reset ()}}
\par
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs a soft reset on the {\b MFRC522} chip and waits for it to be ready again. \par
}{
Definition at line 224 of file MFRC522.cpp.}\par
{
Referenced by PCD_Init().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   224                         \{\par
  225     PCD_WriteRegister(CommandReg, PCD_SoftReset);   // Issue the SoftReset command.\par
  226     // The datasheet does not mention how long the SoftRest command takes to complete.\par
  227     // But the MFRC522 might have been in soft power-down mode (triggered by bit 4 of CommandReg) \par
  228     // Section 8.8.2 in the datasheet says the oscillator start-up time is the start up time of the crystal + 37,74\'EF\'BF\'BDs. Let us be generous: 50ms.\par
  229     delay(50);\par
  230     // Wait for the PowerDown bit in CommandReg to be cleared\par
  231     while (PCD_ReadRegister(CommandReg) & (1<<4)) \{\par
  232         // PCD still restarting - unlikely after waiting 50ms, but better safe than sorry.\par
  233     \}\par
  234 \} // End PCD_Reset()\par
}
}
{\xe \v PCD_SetAntennaGain\:MFRC522}
{\xe \v MFRC522\:PCD_SetAntennaGain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MFRC522::PCD_SetAntennaGain (byte  {\i mask})}}
\par
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the {\b MFRC522} Receiver Gain (RxGain) to value specified by given mask. See 9.3.3.6 / table 98 in {\f2 http://www.nxp.com/documents/data_sheet/MFRC522.pdf} NOTE: Given mask is scrubbed with (0x07<<4)=01110000b as RCFfgReg may use reserved bits. \par
}{
Definition at line 270 of file MFRC522.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   270                                           \{\par
  271     if (PCD_GetAntennaGain() != mask) \{                     // only bother if there is a change\par
  272         PCD_ClearRegisterBitMask(RFCfgReg, (0x07<<4));      // clear needed to allow 000 pattern\par
  273         PCD_SetRegisterBitMask(RFCfgReg, mask & (0x07<<4)); // only set RxGain[2:0] bits\par
  274     \}\par
  275 \} // End PCD_SetAntennaGain()\par
}
}
{\xe \v PCD_SetRegisterBitMask\:MFRC522}
{\xe \v MFRC522\:PCD_SetRegisterBitMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MFRC522::PCD_SetRegisterBitMask (byte  {\i reg}, byte  {\i mask})}}
\par
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the bits given in mask in register reg. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i reg} \cell }{The register to update. One of the PCD_Register enums. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i mask} \cell }{The bits to set. \cell }
{\row }
}
}{
Definition at line 135 of file MFRC522.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   137                                       \{ \par
  138     byte tmp;\par
  139     tmp = PCD_ReadRegister(reg);\par
  140     PCD_WriteRegister(reg, tmp | mask);         // set bit mask\par
  141 \} // End PCD_SetRegisterBitMask()\par
}
}
{\xe \v PCD_StopCrypto1\:MFRC522}
{\xe \v MFRC522\:PCD_StopCrypto1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MFRC522::PCD_StopCrypto1 ()}}
\par
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used to exit the PCD from its authenticated state. Remember to call this function after communicating with an authenticated PICC - otherwise no new communications can start. \par
}{
Definition at line 753 of file MFRC522.cpp.}\par
{
Referenced by MIFARE_SetUid(), and PICC_DumpMifareClassicToSerial().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   753                               \{\par
  754     // Clear MFCrypto1On bit\par
  755     PCD_ClearRegisterBitMask(Status2Reg, 0x08); // Status2Reg[7..0] bits are: TempSensClear I2CForceHS reserved reserved   MFCrypto1On ModemState[2:0]\par
  756 \} // End PCD_StopCrypto1()\par
}
}
{\xe \v PCD_TransceiveData\:MFRC522}
{\xe \v MFRC522\:PCD_TransceiveData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::PCD_TransceiveData (byte *  {\i sendData}, byte  {\i sendLen}, byte *  {\i backData}, byte *  {\i backLen}, byte *  {\i validBits} = {\f2 NULL}, byte  {\i rxAlign} = {\f2 0}, bool  {\i checkCRC} = {\f2 false})}}
\par
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Executes the Transceive command. CRC validation can only be done if backData and backLen are specified.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid STATUS_OK on success, STATUS_??? otherwise. \par
}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sendData} \cell }{Pointer to the data to transfer to the FIFO. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sendLen} \cell }{Number of bytes to transfer to the FIFO. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i backData} \cell }{NULL or pointer to buffer if data should be read back after executing the command. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i backLen} \cell }{In: Max number of bytes to write to *backData. Out: The number of bytes returned. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i validBits} \cell }{In/Out: The number of valid bits in the last byte. 0 for 8 valid bits. Default NULL. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rxAlign} \cell }{In: Defines the bit position in backData[0] for the first bit received. Default 0. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i checkCRC} \cell }{In: True => The last two bytes of the response is assumed to be a CRC_A that must be validated. \cell }
{\row }
}
}{
Definition at line 287 of file MFRC522.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   294                                    \{\par
  295     byte waitIRq = 0x30;        // RxIRq and IdleIRq\par
  296     return PCD_CommunicateWithPICC(PCD_Transceive, waitIRq, sendData, sendLen, backData, backLen, validBits, rxAlign, checkCRC);\par
  297 \} // End PCD_TransceiveData()\par
}
}
{\xe \v PCD_WriteRegister\:MFRC522}
{\xe \v MFRC522\:PCD_WriteRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MFRC522::PCD_WriteRegister (byte  {\i reg}, byte  {\i value})}}
\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Writes a byte to the specified register in the {\b MFRC522} chip. The interface is described in the datasheet section 8.1.2. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i reg} \cell }{The register to write to. One of the PCD_Register enums. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{The value to write. \cell }
{\row }
}
}{
Definition at line 54 of file MFRC522.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    56                                   \{\par
   57     digitalWrite(_chipSelectPin, LOW);      // Select slave\par
   58     SPI.transfer(reg & 0x7E);                   // MSB == 0 is for writing. LSB is not used in address. Datasheet section 8.1.2.3.\par
   59     SPI.transfer(value);\par
   60     digitalWrite(_chipSelectPin, HIGH);     // Release slave again\par
   61 \} // End PCD_WriteRegister()\par
}
}
{\xe \v PCD_WriteRegister\:MFRC522}
{\xe \v MFRC522\:PCD_WriteRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MFRC522::PCD_WriteRegister (byte  {\i reg}, byte  {\i count}, byte *  {\i values})}}
\par
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Writes a number of bytes to the specified register in the {\b MFRC522} chip. The interface is described in the datasheet section 8.1.2. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i reg} \cell }{The register to write to. One of the PCD_Register enums. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i count} \cell }{The number of bytes to write to the register \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i values} \cell }{The values to write. Byte array. \cell }
{\row }
}
}{
Definition at line 67 of file MFRC522.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    70                                   \{\par
   71     digitalWrite(_chipSelectPin, LOW);      // Select slave\par
   72     SPI.transfer(reg & 0x7E);               // MSB == 0 is for writing. LSB is not used in address. Datasheet section 8.1.2.3.\par
   73     for (byte index = 0; index < count; index++) \{\par
   74         SPI.transfer(values[index]);\par
   75     \}\par
   76     digitalWrite(_chipSelectPin, HIGH);     // Release slave again\par
   77 \} // End PCD_WriteRegister()\par
}
}
{\xe \v PICC_DumpMifareClassicSectorToSerial\:MFRC522}
{\xe \v MFRC522\:PICC_DumpMifareClassicSectorToSerial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MFRC522::PICC_DumpMifareClassicSectorToSerial ({\b Uid} *  {\i uid}, {\b MIFARE_Key} *  {\i key}, byte  {\i sector})}}
\par
{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dumps memory contents of a sector of a MIFARE Classic PICC. Uses {\b PCD_Authenticate()}, {\b MIFARE_Read()} and PCD_StopCrypto1. Always uses PICC_CMD_MF_AUTH_KEY_A because only Key A can always read the sector trailer access bits. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uid} \cell }{Pointer to {\b Uid} struct returned from a successful {\b PICC_Select()}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i key} \cell }{Key A for the sector. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sector} \cell }{The sector to dump, 0..39. \cell }
{\row }
}
}{
Definition at line 1249 of file MFRC522.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1252                                                       \{\par
 1253     byte status;\par
 1254     byte firstBlock;        // Address of lowest address to dump actually last block dumped)\par
 1255     byte no_of_blocks;      // Number of blocks in sector\par
 1256     bool isSectorTrailer;   // Set to true while handling the "last" (ie highest address) in the sector.\par
 1257 \par
 1258     // The access bits are stored in a peculiar fashion.\par
 1259     // There are four groups:\par
 1260     //      g[3]    Access bits for the sector trailer, block 3 (for sectors 0-31) or block 15 (for sectors 32-39)\par
 1261     //      g[2]    Access bits for block 2 (for sectors 0-31) or blocks 10-14 (for sectors 32-39)\par
 1262     //      g[1]    Access bits for block 1 (for sectors 0-31) or blocks 5-9 (for sectors 32-39)\par
 1263     //      g[0]    Access bits for block 0 (for sectors 0-31) or blocks 0-4 (for sectors 32-39)\par
 1264     // Each group has access bits [C1 C2 C3]. In this code C1 is MSB and C3 is LSB.\par
 1265     // The four CX bits are stored together in a nible cx and an inverted nible cx_.\par
 1266     byte c1, c2, c3;        // Nibbles\par
 1267     byte c1_, c2_, c3_;     // Inverted nibbles\par
 1268     bool invertedError;     // True if one of the inverted nibbles did not match\par
 1269     byte g[4];              // Access bits for each of the four groups.\par
 1270     byte group;             // 0-3 - active group for access bits\par
 1271     bool firstInGroup;      // True for the first block dumped in the group\par
 1272 \par
 1273     // Determine position and size of sector.\par
 1274     if (sector < 32) \{ // Sectors 0..31 has 4 blocks each\par
 1275         no_of_blocks = 4;\par
 1276         firstBlock = sector * no_of_blocks;\par
 1277     \}\par
 1278     else if (sector < 40) \{ // Sectors 32-39 has 16 blocks each\par
 1279         no_of_blocks = 16;\par
 1280         firstBlock = 128 + (sector - 32) * no_of_blocks;\par
 1281     \}\par
 1282     else \{ // Illegal input, no MIFARE Classic PICC has more than 40 sectors.\par
 1283         return;\par
 1284     \}\par
 1285         \par
 1286     // Dump blocks, highest address first.\par
 1287     byte byteCount;\par
 1288     byte buffer[18];\par
 1289     byte blockAddr;\par
 1290     isSectorTrailer = true;\par
 1291     for (int8_t blockOffset = no_of_blocks - 1; blockOffset >= 0; blockOffset--) \{\par
 1292         blockAddr = firstBlock + blockOffset;\par
 1293         // Sector number - only on first line\par
 1294         if (isSectorTrailer) \{\par
 1295             Serial.print(sector < 10 ? "   " : "  "); // Pad with spaces\par
 1296             Serial.print(sector);\par
 1297             Serial.print("   ");\par
 1298         \}\par
 1299         else \{\par
 1300             Serial.print("       ");\par
 1301         \}\par
 1302         // Block number\par
 1303         Serial.print(blockAddr < 10 ? "   " : (blockAddr < 100 ? "  "    : " ")); // Pad with spaces\par
 1304         Serial.print(blockAddr);\par
 1305         Serial.print("  ");\par
 1306         // Establish encrypted communications before reading the first block\par
 1307         if (isSectorTrailer) \{\par
 1308             status = PCD_Authenticate(PICC_CMD_MF_AUTH_KEY_A, firstBlock, key, uid);\par
 1309             if (status != STATUS_OK) \{\par
 1310                 Serial.print("PCD_Authenticate() failed: ");\par
 1311                 Serial.println(GetStatusCodeName(status));\par
 1312                 return;\par
 1313             \}\par
 1314         \}\par
 1315         // Read block\par
 1316         byteCount = sizeof(buffer);\par
 1317         status = MIFARE_Read(blockAddr, buffer, &byteCount);\par
 1318         if (status != STATUS_OK) \{\par
 1319             Serial.print("MIFARE_Read() failed: ");\par
 1320             Serial.println(GetStatusCodeName(status));\par
 1321             continue;\par
 1322         \}\par
 1323         // Dump data\par
 1324         for (byte index = 0; index < 16; index++) \{\par
 1325             Serial.print(buffer[index] < 0x10 ? " 0" : " ");\par
 1326             Serial.print(buffer[index], HEX);\par
 1327             if ((index % 4) == 3) \{\par
 1328                 Serial.print(" ");\par
 1329             \}\par
 1330         \}\par
 1331         // Parse sector trailer data\par
 1332         if (isSectorTrailer) \{\par
 1333             c1  = buffer[7] >> 4;\par
 1334             c2  = buffer[8] & 0xF;\par
 1335             c3  = buffer[8] >> 4;\par
 1336             c1_ = buffer[6] & 0xF;\par
 1337             c2_ = buffer[6] >> 4;\par
 1338             c3_ = buffer[7] & 0xF;\par
 1339             invertedError = (c1 != (~c1_ & 0xF)) || (c2 != (~c2_ & 0xF)) || (c3 != (~c3_ & 0xF));\par
 1340             g[0] = ((c1 & 1) << 2) | ((c2 & 1) << 1) | ((c3 & 1) << 0);\par
 1341             g[1] = ((c1 & 2) << 1) | ((c2 & 2) << 0) | ((c3 & 2) >> 1);\par
 1342             g[2] = ((c1 & 4) << 0) | ((c2 & 4) >> 1) | ((c3 & 4) >> 2);\par
 1343             g[3] = ((c1 & 8) >> 1) | ((c2 & 8) >> 2) | ((c3 & 8) >> 3);\par
 1344             isSectorTrailer = false;\par
 1345         \}\par
 1346 \par
 1347         // Which access group is this block in?\par
 1348         if (no_of_blocks == 4) \{\par
 1349             group = blockOffset;\par
 1350             firstInGroup = true;\par
 1351         \}\par
 1352         else \{\par
 1353             group = blockOffset / 5;\par
 1354             firstInGroup = (group == 3) || (group != (blockOffset + 1) / 5);\par
 1355         \}\par
 1356         \par
 1357         if (firstInGroup) \{\par
 1358             // Print access bits\par
 1359             Serial.print(" [ ");\par
 1360             Serial.print((g[group] >> 2) & 1, DEC); Serial.print(" ");\par
 1361             Serial.print((g[group] >> 1) & 1, DEC); Serial.print(" ");\par
 1362             Serial.print((g[group] >> 0) & 1, DEC);\par
 1363             Serial.print(" ] ");\par
 1364             if (invertedError) \{\par
 1365                 Serial.print(" Inverted access bits did not match! ");\par
 1366             \}\par
 1367         \}\par
 1368         \par
 1369         if (group != 3 && (g[group] == 1 || g[group] == 6)) \{ // Not a sector trailer, a value block\par
 1370             long value = (long(buffer[3])<<24) | (long(buffer[2])<<16) | (long(buffer[1])<<8) | long(buffer[0]);\par
 1371             Serial.print(" Value=0x"); Serial.print(value, HEX);\par
 1372             Serial.print(" Adr=0x"); Serial.print(buffer[12], HEX);\par
 1373         \}\par
 1374         Serial.println();\par
 1375     \}\par
 1376     \par
 1377     return;\par
 1378 \} // End PICC_DumpMifareClassicSectorToSerial()\par
}
}
{\xe \v PICC_DumpMifareClassicToSerial\:MFRC522}
{\xe \v MFRC522\:PICC_DumpMifareClassicToSerial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MFRC522::PICC_DumpMifareClassicToSerial ({\b Uid} *  {\i uid}, byte  {\i piccType}, {\b MIFARE_Key} *  {\i key})}}
\par
{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dumps memory contents of a MIFARE Classic PICC. On success the PICC is halted after dumping the data. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uid} \cell }{Pointer to {\b Uid} struct returned from a successful {\b PICC_Select()}. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i piccType} \cell }{One of the PICC_Type enums. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i key} \cell }{Key A used for all sectors. \cell }
{\row }
}
}{
Definition at line 1208 of file MFRC522.cpp.}\par
{
References PCD_StopCrypto1().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1211                                               \{\par
 1212     byte no_of_sectors = 0;\par
 1213     switch (piccType) \{\par
 1214         case PICC_TYPE_MIFARE_MINI:\par
 1215             // Has 5 sectors * 4 blocks/sector * 16 bytes/block = 320 bytes.\par
 1216             no_of_sectors = 5;\par
 1217             break;\par
 1218             \par
 1219         case PICC_TYPE_MIFARE_1K:\par
 1220             // Has 16 sectors * 4 blocks/sector * 16 bytes/block = 1024 bytes.\par
 1221             no_of_sectors = 16;\par
 1222             break;\par
 1223             \par
 1224         case PICC_TYPE_MIFARE_4K:\par
 1225             // Has (32 sectors * 4 blocks/sector + 8 sectors * 16 blocks/sector) * 16 bytes/block = 4096 bytes.\par
 1226             no_of_sectors = 40;\par
 1227             break;\par
 1228             \par
 1229         default: // Should not happen. Ignore.\par
 1230             break; \par
 1231     \}\par
 1232     \par
 1233     // Dump sectors, highest address first.\par
 1234     if (no_of_sectors) \{\par
 1235         Serial.println("Sector Block   0  1  2  3   4  5  6  7   8  9 10 11  12 13 14 15  AccessBits");\par
 1236         for (int8_t i = no_of_sectors - 1; i >= 0; i--) \{\par
 1237             PICC_DumpMifareClassicSectorToSerial(uid, key, i);\par
 1238         \}\par
 1239     \}\par
 1240     PICC_HaltA(); // Halt the PICC before stopping the encrypted session.\par
 1241     PCD_StopCrypto1();\par
 1242 \} // End PICC_DumpMifareClassicToSerial()\par
}
}
{\xe \v PICC_DumpMifareUltralightToSerial\:MFRC522}
{\xe \v MFRC522\:PICC_DumpMifareUltralightToSerial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MFRC522::PICC_DumpMifareUltralightToSerial ()}}
\par
{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dumps memory contents of a MIFARE Ultralight PICC. \par
}{
Definition at line 1383 of file MFRC522.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1383                                                 \{\par
 1384     byte status;\par
 1385     byte byteCount;\par
 1386     byte buffer[18];\par
 1387     byte i;\par
 1388 \par
 1389     Serial.println("Page  0  1  2  3");\par
 1390     // Try the mpages of the original Ultralight. Ultralight C has more pages.\par
 1391     for (byte page = 0; page < 16; page +=4) \{ // Read returns data for 4 pages at a time.\par
 1392         // Read pages\par
 1393         byteCount = sizeof(buffer);\par
 1394         status = MIFARE_Read(page, buffer, &byteCount);\par
 1395         if (status != STATUS_OK) \{\par
 1396             Serial.print("MIFARE_Read() failed: ");\par
 1397             Serial.println(GetStatusCodeName(status));\par
 1398             break;\par
 1399         \}\par
 1400         // Dump data\par
 1401         for (byte offset = 0; offset < 4; offset++) \{\par
 1402             i = page + offset;\par
 1403             Serial.print(i < 10 ? "  " : " "); // Pad with spaces\par
 1404             Serial.print(i);\par
 1405             Serial.print("  ");\par
 1406             for (byte index = 0; index < 4; index++) \{\par
 1407                 i = 4 * offset + index;\par
 1408                 Serial.print(buffer[i] < 0x10 ? " 0" : " ");\par
 1409                 Serial.print(buffer[i], HEX);\par
 1410             \}\par
 1411             Serial.println();\par
 1412         \}\par
 1413     \}\par
 1414 \} // End PICC_DumpMifareUltralightToSerial()\par
}
}
{\xe \v PICC_DumpToSerial\:MFRC522}
{\xe \v MFRC522\:PICC_DumpToSerial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MFRC522::PICC_DumpToSerial ({\b Uid} *  {\i uid})}}
\par
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dumps debug info about the selected PICC to Serial. On success the PICC is halted after dumping the data. For MIFARE Classic the factory default key of 0xFFFFFFFFFFFF is tried. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uid} \cell }{Pointer to {\b Uid} struct returned from a successful {\b PICC_Select()}. \cell }
{\row }
}
}{
Definition at line 1154 of file MFRC522.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1155                                   \{\par
 1156     MIFARE_Key key;\par
 1157     \par
 1158     // UID\par
 1159     Serial.print("Card UID:");\par
 1160     for (byte i = 0; i < uid->size; i++) \{\par
 1161         Serial.print(uid->uidByte[i] < 0x10 ? " 0" : " ");\par
 1162         Serial.print(uid->uidByte[i], HEX);\par
 1163     \} \par
 1164     Serial.println();\par
 1165 \par
 1166     // PICC type\par
 1167     byte piccType = PICC_GetType(uid->sak);\par
 1168     Serial.print("PICC type: ");\par
 1169     Serial.println(PICC_GetTypeName(piccType));\par
 1170     \par
 1171     // Dump contents\par
 1172     switch (piccType) \{\par
 1173         case PICC_TYPE_MIFARE_MINI:\par
 1174         case PICC_TYPE_MIFARE_1K:\par
 1175         case PICC_TYPE_MIFARE_4K:\par
 1176             // All keys are set to FFFFFFFFFFFFh at chip delivery from the factory.\par
 1177             for (byte i = 0; i < 6; i++) \{\par
 1178                 key.keyByte[i] = 0xFF;\par
 1179             \}\par
 1180             PICC_DumpMifareClassicToSerial(uid, piccType, &key);\par
 1181             break;\par
 1182             \par
 1183         case PICC_TYPE_MIFARE_UL:\par
 1184             PICC_DumpMifareUltralightToSerial();\par
 1185             break;\par
 1186             \par
 1187         case PICC_TYPE_ISO_14443_4: \par
 1188         case PICC_TYPE_ISO_18092:\par
 1189         case PICC_TYPE_MIFARE_PLUS:\par
 1190         case PICC_TYPE_TNP3XXX:\par
 1191             Serial.println("Dumping memory contents not implemented for that PICC type.");\par
 1192             break;\par
 1193             \par
 1194         case PICC_TYPE_UNKNOWN:\par
 1195         case PICC_TYPE_NOT_COMPLETE:\par
 1196         default:\par
 1197             break; // No memory dump here\par
 1198     \}\par
 1199 \par
 1200     Serial.println();\par
 1201     PICC_HaltA(); // Already done if it was a MIFARE Classic PICC.\par
 1202 \} // End PICC_DumpToSerial()\par
}
}
{\xe \v PICC_GetType\:MFRC522}
{\xe \v MFRC522\:PICC_GetType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::PICC_GetType (byte  {\i sak})}}
\par
{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Translates the SAK (Select Acknowledge) to a PICC type.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid PICC_Type \par
}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sak} \cell }{The SAK byte returned from {\b PICC_Select()}. \cell }
{\row }
}
}{
Definition at line 1100 of file MFRC522.cpp.}\par
{
References PICC_TYPE_ISO_14443_4, PICC_TYPE_ISO_18092, PICC_TYPE_NOT_COMPLETE, and PICC_TYPE_UNKNOWN.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1101                               \{\par
 1102     if (sak & 0x04) \{ // UID not complete\par
 1103         return PICC_TYPE_NOT_COMPLETE;\par
 1104     \}\par
 1105     \par
 1106     switch (sak) \{\par
 1107         case 0x09:  return PICC_TYPE_MIFARE_MINI;   break;\par
 1108         case 0x08:  return PICC_TYPE_MIFARE_1K;     break;\par
 1109         case 0x18:  return PICC_TYPE_MIFARE_4K;     break;\par
 1110         case 0x00:  return PICC_TYPE_MIFARE_UL;     break;\par
 1111         case 0x10:\par
 1112         case 0x11:  return PICC_TYPE_MIFARE_PLUS;   break;\par
 1113         case 0x01:  return PICC_TYPE_TNP3XXX;       break;\par
 1114         default:    break;\par
 1115     \}\par
 1116     \par
 1117     if (sak & 0x20) \{\par
 1118         return PICC_TYPE_ISO_14443_4;\par
 1119     \}\par
 1120     \par
 1121     if (sak & 0x40) \{\par
 1122         return PICC_TYPE_ISO_18092;\par
 1123     \}\par
 1124     \par
 1125     return PICC_TYPE_UNKNOWN;\par
 1126 \} // End PICC_GetType()\par
}
}
{\xe \v PICC_GetTypeName\:MFRC522}
{\xe \v MFRC522\:PICC_GetTypeName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * MFRC522::PICC_GetTypeName (byte  {\i piccType})}}
\par
{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a string pointer to the PICC type name. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i piccType} \cell }{One of the PICC_Type enums. \cell }
{\row }
}
}{
Definition at line 1132 of file MFRC522.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1133                                           \{\par
 1134     switch (piccType) \{\par
 1135         case PICC_TYPE_ISO_14443_4:     return "PICC compliant with ISO/IEC 14443-4";       break;\par
 1136         case PICC_TYPE_ISO_18092:       return "PICC compliant with ISO/IEC 18092 (NFC)";   break;\par
 1137         case PICC_TYPE_MIFARE_MINI:     return "MIFARE Mini, 320 bytes";                    break;\par
 1138         case PICC_TYPE_MIFARE_1K:       return "MIFARE 1KB";                                break;\par
 1139         case PICC_TYPE_MIFARE_4K:       return "MIFARE 4KB";                                break;\par
 1140         case PICC_TYPE_MIFARE_UL:       return "MIFARE Ultralight or Ultralight C";         break;\par
 1141         case PICC_TYPE_MIFARE_PLUS:     return "MIFARE Plus";                               break;\par
 1142         case PICC_TYPE_TNP3XXX:         return "MIFARE TNP3XXX";                            break;\par
 1143         case PICC_TYPE_NOT_COMPLETE:    return "SAK indicates UID is not complete.";        break;\par
 1144         case PICC_TYPE_UNKNOWN:\par
 1145         default:                        return "Unknown type";                              break;\par
 1146     \}\par
 1147 \} // End PICC_GetTypeName()\par
}
}
{\xe \v PICC_HaltA\:MFRC522}
{\xe \v MFRC522\:PICC_HaltA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::PICC_HaltA ()}}
\par
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Instructs a PICC in state ACTIVE(*) to go to state HALT.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid STATUS_OK on success, STATUS_??? otherwise. \par
}}{
Definition at line 682 of file MFRC522.cpp.}\par
{
References STATUS_ERROR, and STATUS_OK.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   682                          \{\par
  683     byte result;\par
  684     byte buffer[4]; \par
  685 \par
  686     // Build command buffer\par
  687     buffer[0] = PICC_CMD_HLTA;\par
  688     buffer[1] = 0;\par
  689     // Calculate CRC_A\par
  690     result = PCD_CalculateCRC(buffer, 2, &buffer[2]);\par
  691     if (result != STATUS_OK) \{\par
  692         return result;\par
  693     \}\par
  694 \par
  695     // Send the command.\par
  696     // The standard says:\par
  697     //      If the PICC responds with any modulation during a period of 1 ms after the end of the frame containing the\par
  698     //      HLTA command, this response shall be interpreted as 'not acknowledge'.\par
  699     // We interpret that this way: Only STATUS_TIMEOUT is an success.\par
  700     result = PCD_TransceiveData(buffer, sizeof(buffer), NULL, 0);\par
  701     if (result == STATUS_TIMEOUT) \{\par
  702         return STATUS_OK;\par
  703     \}\par
  704     if (result == STATUS_OK) \{ // That is ironically NOT ok in this case ;-)\par
  705         return STATUS_ERROR;\par
  706     \}\par
  707     return result;\par
  708 \} // End PICC_HaltA()\par
}
}
{\xe \v PICC_IsNewCardPresent\:MFRC522}
{\xe \v MFRC522\:PICC_IsNewCardPresent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MFRC522::PICC_IsNewCardPresent ()}}
\par
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if a PICC responds to PICC_CMD_REQA. Only "new" cards in state IDLE are invited. Sleeping cards in state HALT are ignored.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid bool \par
}}{
Definition at line 1643 of file MFRC522.cpp.}\par
{
Referenced by MIFARE_SetUid().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1643                                     \{\par
 1644     byte bufferATQA[2];\par
 1645     byte bufferSize = sizeof(bufferATQA);\par
 1646     byte result = PICC_RequestA(bufferATQA, &bufferSize);\par
 1647     return (result == STATUS_OK || result == STATUS_COLLISION);\par
 1648 \} // End PICC_IsNewCardPresent()\par
}
}
{\xe \v PICC_ReadCardSerial\:MFRC522}
{\xe \v MFRC522\:PICC_ReadCardSerial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MFRC522::PICC_ReadCardSerial ()}}
\par
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simple wrapper around PICC_Select. Returns true if a UID could be read. Remember to call {\b PICC_IsNewCardPresent()}, {\b PICC_RequestA()} or {\b PICC_WakeupA()} first. The read UID is available in the class variable uid.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid bool \par
}}{
Definition at line 1658 of file MFRC522.cpp.}\par
{
Referenced by MIFARE_SetUid().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1658                                   \{\par
 1659     byte result = PICC_Select(&uid);\par
 1660     return (result == STATUS_OK);\par
 1661 \} // End PICC_ReadCardSerial()\par
}
}
{\xe \v PICC_REQA_or_WUPA\:MFRC522}
{\xe \v MFRC522\:PICC_REQA_or_WUPA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::PICC_REQA_or_WUPA (byte  {\i command}, byte *  {\i bufferATQA}, byte *  {\i bufferSize})}}
\par
{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Transmits REQA or WUPA commands. Beware: When two PICCs are in the field at the same time I often get STATUS_TIMEOUT - probably due do bad antenna design.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid STATUS_OK on success, STATUS_??? otherwise. \par
}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i command} \cell }{The command to send - PICC_CMD_REQA or PICC_CMD_WUPA \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bufferATQA} \cell }{The buffer to store the ATQA (Answer to request) in \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bufferSize} \cell }{Buffer size, at least two bytes. Also number of bytes returned if STATUS_OK. \cell }
{\row }
}
}{
Definition at line 428 of file MFRC522.cpp.}\par
{
References STATUS_ERROR, STATUS_NO_ROOM, and STATUS_OK.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   431                                  \{\par
  432     byte validBits;\par
  433     byte status;\par
  434     \par
  435     if (bufferATQA == NULL || *bufferSize < 2) \{    // The ATQA response is 2 bytes long.\par
  436         return STATUS_NO_ROOM;\par
  437     \}\par
  438     PCD_ClearRegisterBitMask(CollReg, 0x80);            // ValuesAfterColl=1 => Bits received after collision are cleared.\par
  439     validBits = 7;                                      // For REQA and WUPA we need the short frame format - transmit only 7 bits of the last (and only) byte. TxLastBits = BitFramingReg[2..0]\par
  440     status = PCD_TransceiveData(&command, 1, bufferATQA, bufferSize, &validBits);\par
  441     if (status != STATUS_OK) \{\par
  442         return status;\par
  443     \}\par
  444     if (*bufferSize != 2 || validBits != 0) \{       // ATQA must be exactly 16 bits.\par
  445         return STATUS_ERROR;\par
  446     \}\par
  447     return STATUS_OK;\par
  448 \} // End PICC_REQA_or_WUPA()\par
}
}
{\xe \v PICC_RequestA\:MFRC522}
{\xe \v MFRC522\:PICC_RequestA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::PICC_RequestA (byte *  {\i bufferATQA}, byte *  {\i bufferSize})}}
\par
{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Transmits a REQuest command, Type A. Invites PICCs in state IDLE to go to READY and prepare for anticollision or selection. 7 bit frame. Beware: When two PICCs are in the field at the same time I often get STATUS_TIMEOUT - probably due do bad antenna design.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid STATUS_OK on success, STATUS_??? otherwise. \par
}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bufferATQA} \cell }{The buffer to store the ATQA (Answer to request) in \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bufferSize} \cell }{Buffer size, at least two bytes. Also number of bytes returned if STATUS_OK. \cell }
{\row }
}
}{
Definition at line 404 of file MFRC522.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   406                               \{\par
  407     return PICC_REQA_or_WUPA(PICC_CMD_REQA, bufferATQA, bufferSize);\par
  408 \} // End PICC_RequestA()\par
}
}
{\xe \v PICC_Select\:MFRC522}
{\xe \v MFRC522\:PICC_Select}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::PICC_Select ({\b Uid} *  {\i uid}, byte  {\i validBits} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Transmits SELECT/ANTICOLLISION commands to select a single PICC. Before calling this function the PICCs must be placed in the READY(*) state by calling {\b PICC_RequestA()} or {\b PICC_WakeupA()}. On success:{
\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The chosen PICC is in state ACTIVE(*) and all other PICCs have returned to state IDLE/HALT. (Figure 7 of the ISO/IEC 14443-3 draft.)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The UID size and value of the chosen PICC is returned in *uid along with the SAK.\par}
A PICC UID consists of 4, 7 or 10 bytes. Only 4 bytes can be specified in a SELECT command, so for the longer UIDs two or three iterations are used: UID size Number of UID bytes Cascade levels Example of PICC ======== =================== ============== =============== single 4 1 MIFARE Classic double 7 2 MIFARE Ultralight triple 10 3 Not currently in use?\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid STATUS_OK on success, STATUS_??? otherwise. \par
}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i uid} \cell }{Pointer to {\b Uid} struct. Normally output, but can also be used to supply a known UID. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i validBits} \cell }{The number of known UID bits supplied in *uid. Normally 0. If set you must also supply uid->size. \cell }
{\row }
}
}{
Definition at line 467 of file MFRC522.cpp.}\par
{
References STATUS_COLLISION, STATUS_CRC_WRONG, STATUS_ERROR, STATUS_INTERNAL_ERROR, STATUS_INVALID, and STATUS_OK.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   469                            \{\par
  470     bool uidComplete;\par
  471     bool selectDone;\par
  472     bool useCascadeTag;\par
  473     byte cascadeLevel   = 1; \par
  474     byte result;\par
  475     byte count;\par
  476     byte index;\par
  477     byte uidIndex;                  // The first index in uid->uidByte[] that is used in the current Cascade Level.\par
  478     int8_t currentLevelKnownBits;       // The number of known UID bits in the current Cascade Level.\par
  479     byte buffer[9];                 // The SELECT/ANTICOLLISION commands uses a 7 byte standard frame + 2 bytes CRC_A\par
  480     byte bufferUsed;                // The number of bytes used in the buffer, ie the number of bytes to transfer to the FIFO.\par
  481     byte rxAlign;                   // Used in BitFramingReg. Defines the bit position for the first bit received.\par
  482     byte txLastBits;                // Used in BitFramingReg. The number of valid bits in the last transmitted byte. \par
  483     byte *responseBuffer;\par
  484     byte responseLength;\par
  485     \par
  486     // Description of buffer structure:\par
  487     //      Byte 0: SEL                 Indicates the Cascade Level: PICC_CMD_SEL_CL1, PICC_CMD_SEL_CL2 or PICC_CMD_SEL_CL3\par
  488     //      Byte 1: NVB                 Number of Valid Bits (in complete command, not just the UID): High nibble: complete bytes, Low nibble: Extra bits. \par
  489     //      Byte 2: UID-data or CT      See explanation below. CT means Cascade Tag.\par
  490     //      Byte 3: UID-data\par
  491     //      Byte 4: UID-data\par
  492     //      Byte 5: UID-data\par
  493     //      Byte 6: BCC                 Block Check Character - XOR of bytes 2-5\par
  494     //      Byte 7: CRC_A\par
  495     //      Byte 8: CRC_A\par
  496     // The BCC and CRC_A is only transmitted if we know all the UID bits of the current Cascade Level.\par
  497     //\par
  498     // Description of bytes 2-5: (Section 6.5.4 of the ISO/IEC 14443-3 draft: UID contents and cascade levels)\par
  499     //      UID size    Cascade level   Byte2   Byte3   Byte4   Byte5\par
  500     //      ========    =============   =====   =====   =====   =====\par
  501     //       4 bytes        1           uid0    uid1    uid2    uid3\par
  502     //       7 bytes        1           CT      uid0    uid1    uid2\par
  503     //                      2           uid3    uid4    uid5    uid6\par
  504     //      10 bytes        1           CT      uid0    uid1    uid2\par
  505     //                      2           CT      uid3    uid4    uid5\par
  506     //                      3           uid6    uid7    uid8    uid9\par
  507     \par
  508     // Sanity checks\par
  509     if (validBits > 80) \{\par
  510         return STATUS_INVALID;\par
  511     \}\par
  512 \par
  513     // Prepare MFRC522\par
  514     PCD_ClearRegisterBitMask(CollReg, 0x80);            // ValuesAfterColl=1 => Bits received after collision are cleared.\par
  515 \par
  516     // Repeat Cascade Level loop until we have a complete UID.\par
  517     uidComplete = false;\par
  518     while ( ! uidComplete) \{\par
  519         // Set the Cascade Level in the SEL byte, find out if we need to use the Cascade Tag in byte 2.\par
  520         switch (cascadeLevel) \{\par
  521             case 1:\par
  522                 buffer[0] = PICC_CMD_SEL_CL1;\par
  523                 uidIndex = 0;\par
  524                 useCascadeTag = validBits && uid->size > 4; // When we know that the UID has more than 4 bytes\par
  525                 break;\par
  526             \par
  527             case 2:\par
  528                 buffer[0] = PICC_CMD_SEL_CL2;\par
  529                 uidIndex = 3;\par
  530                 useCascadeTag = validBits && uid->size > 7; // When we know that the UID has more than 7 bytes\par
  531                 break;\par
  532             \par
  533             case 3:\par
  534                 buffer[0] = PICC_CMD_SEL_CL3;\par
  535                 uidIndex = 6;\par
  536                 useCascadeTag = false;                      // Never used in CL3.\par
  537                 break;\par
  538             \par
  539             default:\par
  540                 return STATUS_INTERNAL_ERROR;\par
  541                 break;\par
  542         \}\par
  543         \par
  544         // How many UID bits are known in this Cascade Level?\par
  545         currentLevelKnownBits = validBits - (8 * uidIndex);\par
  546         if (currentLevelKnownBits < 0) \{\par
  547             currentLevelKnownBits = 0;\par
  548         \}\par
  549         // Copy the known bits from uid->uidByte[] to buffer[]\par
  550         index = 2; // destination index in buffer[]\par
  551         if (useCascadeTag) \{\par
  552             buffer[index++] = PICC_CMD_CT;\par
  553         \}\par
  554         byte bytesToCopy = currentLevelKnownBits / 8 + (currentLevelKnownBits % 8 ? 1 : 0); // The number of bytes needed to represent the known bits for this level.\par
  555         if (bytesToCopy) \{\par
  556             byte maxBytes = useCascadeTag ? 3 : 4; // Max 4 bytes in each Cascade Level. Only 3 left if we use the Cascade Tag\par
  557             if (bytesToCopy > maxBytes) \{ \par
  558                 bytesToCopy = maxBytes;\par
  559             \}\par
  560             for (count = 0; count < bytesToCopy; count++) \{\par
  561                 buffer[index++] = uid->uidByte[uidIndex + count];\par
  562             \}\par
  563         \}\par
  564         // Now that the data has been copied we need to include the 8 bits in CT in currentLevelKnownBits\par
  565         if (useCascadeTag) \{\par
  566             currentLevelKnownBits += 8;\par
  567         \}\par
  568         \par
  569         // Repeat anti collision loop until we can transmit all UID bits + BCC and receive a SAK - max 32 iterations.\par
  570         selectDone = false;\par
  571         while ( ! selectDone) \{\par
  572             // Find out how many bits and bytes to send and receive.\par
  573             if (currentLevelKnownBits >= 32) \{ // All UID bits in this Cascade Level are known. This is a SELECT.\par
  574                 //Serial.print("SELECT: currentLevelKnownBits="); Serial.println(currentLevelKnownBits, DEC);\par
  575                 buffer[1] = 0x70; // NVB - Number of Valid Bits: Seven whole bytes\par
  576                 // Calulate BCC - Block Check Character\par
  577                 buffer[6] = buffer[2] ^ buffer[3] ^ buffer[4] ^ buffer[5];\par
  578                 // Calculate CRC_A\par
  579                 result = PCD_CalculateCRC(buffer, 7, &buffer[7]);\par
  580                 if (result != STATUS_OK) \{\par
  581                     return result;\par
  582                 \}\par
  583                 txLastBits      = 0; // 0 => All 8 bits are valid.\par
  584                 bufferUsed      = 9;\par
  585                 // Store response in the last 3 bytes of buffer (BCC and CRC_A - not needed after tx)\par
  586                 responseBuffer  = &buffer[6];\par
  587                 responseLength  = 3;\par
  588             \}\par
  589             else \{ // This is an ANTICOLLISION.\par
  590                 //Serial.print("ANTICOLLISION: currentLevelKnownBits="); Serial.println(currentLevelKnownBits, DEC);\par
  591                 txLastBits      = currentLevelKnownBits % 8;\par
  592                 count           = currentLevelKnownBits / 8;    // Number of whole bytes in the UID part.\par
  593                 index           = 2 + count;                    // Number of whole bytes: SEL + NVB + UIDs\par
  594                 buffer[1]       = (index << 4) + txLastBits;    // NVB - Number of Valid Bits\par
  595                 bufferUsed      = index + (txLastBits ? 1 : 0);\par
  596                 // Store response in the unused part of buffer\par
  597                 responseBuffer  = &buffer[index];\par
  598                 responseLength  = sizeof(buffer) - index;\par
  599             \}\par
  600 \par
  601             // Set bit adjustments\par
  602             rxAlign = txLastBits;                                           // Having a seperate variable is overkill. But it makes the next line easier to read.\par
  603             PCD_WriteRegister(BitFramingReg, (rxAlign << 4) + txLastBits);  // RxAlign = BitFramingReg[6..4]. TxLastBits = BitFramingReg[2..0]\par
  604 \par
  605             // Transmit the buffer and receive the response.\par
  606             result = PCD_TransceiveData(buffer, bufferUsed, responseBuffer, &responseLength, &txLastBits, rxAlign);         \par
  607             if (result == STATUS_COLLISION) \{ // More than one PICC in the field => collision.\par
  608                 result = PCD_ReadRegister(CollReg); // CollReg[7..0] bits are: ValuesAfterColl reserved CollPosNotValid CollPos[4:0]\par
  609                 if (result & 0x20) \{ // CollPosNotValid\par
  610                     return STATUS_COLLISION; // Without a valid collision position we cannot continue\par
  611                 \}\par
  612                 byte collisionPos = result & 0x1F; // Values 0-31, 0 means bit 32.\par
  613                 if (collisionPos == 0) \{\par
  614                     collisionPos = 32;\par
  615                 \}\par
  616                 if (collisionPos <= currentLevelKnownBits) \{ // No progress - should not happen \par
  617                     return STATUS_INTERNAL_ERROR;\par
  618                 \}\par
  619                 // Choose the PICC with the bit set.\par
  620                 currentLevelKnownBits = collisionPos;\par
  621                 count           = (currentLevelKnownBits - 1) % 8; // The bit to modify\par
  622                 index           = 1 + (currentLevelKnownBits / 8) + (count ? 1 : 0); // First byte is index 0.\par
  623                 buffer[index]   |= (1 << count); \par
  624             \}\par
  625             else if (result != STATUS_OK) \{\par
  626                 return result;\par
  627             \}\par
  628             else \{ // STATUS_OK\par
  629                 if (currentLevelKnownBits >= 32) \{ // This was a SELECT.\par
  630                     selectDone = true; // No more anticollision \par
  631                     // We continue below outside the while.\par
  632                 \}\par
  633                 else \{ // This was an ANTICOLLISION.\par
  634                     // We now have all 32 bits of the UID in this Cascade Level\par
  635                     currentLevelKnownBits = 32;\par
  636                     // Run loop again to do the SELECT.\par
  637                 \}\par
  638             \}\par
  639         \} // End of while ( ! selectDone)\par
  640 \par
  641         // We do not check the CBB - it was constructed by us above.\par
  642         \par
  643         // Copy the found UID bytes from buffer[] to uid->uidByte[]\par
  644         index           = (buffer[2] == PICC_CMD_CT) ? 3 : 2; // source index in buffer[]\par
  645         bytesToCopy     = (buffer[2] == PICC_CMD_CT) ? 3 : 4;\par
  646         for (count = 0; count < bytesToCopy; count++) \{\par
  647             uid->uidByte[uidIndex + count] = buffer[index++];\par
  648         \}\par
  649         \par
  650         // Check response SAK (Select Acknowledge)\par
  651         if (responseLength != 3 || txLastBits != 0) \{       // SAK must be exactly 24 bits (1 byte + CRC_A).\par
  652             return STATUS_ERROR;\par
  653         \}\par
  654         // Verify CRC_A - do our own calculation and store the control in buffer[2..3] - those bytes are not needed anymore.\par
  655         result = PCD_CalculateCRC(responseBuffer, 1, &buffer[2]);\par
  656         if (result != STATUS_OK) \{\par
  657             return result;\par
  658         \}\par
  659         if ((buffer[2] != responseBuffer[1]) || (buffer[3] != responseBuffer[2])) \{\par
  660             return STATUS_CRC_WRONG;\par
  661         \}\par
  662         if (responseBuffer[0] & 0x04) \{ // Cascade bit set - UID not complete yes\par
  663             cascadeLevel++;\par
  664         \}\par
  665         else \{\par
  666             uidComplete = true;\par
  667             uid->sak = responseBuffer[0];\par
  668         \}\par
  669     \} // End of while ( ! uidComplete)\par
  670     \par
  671     // Set correct uid->size\par
  672     uid->size = 3 * cascadeLevel + 1;\par
  673 \par
  674     return STATUS_OK;\par
  675 \} // End PICC_Select()\par
}
}
{\xe \v PICC_WakeupA\:MFRC522}
{\xe \v MFRC522\:PICC_WakeupA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::PICC_WakeupA (byte *  {\i bufferATQA}, byte *  {\i bufferSize})}}
\par
{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Transmits a Wake-UP command, Type A. Invites PICCs in state IDLE and HALT to go to READY(*) and prepare for anticollision or selection. 7 bit frame. Beware: When two PICCs are in the field at the same time I often get STATUS_TIMEOUT - probably due do bad antenna design.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid STATUS_OK on success, STATUS_??? otherwise. \par
}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bufferATQA} \cell }{The buffer to store the ATQA (Answer to request) in \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bufferSize} \cell }{Buffer size, at least two bytes. Also number of bytes returned if STATUS_OK. \cell }
{\row }
}
}{
Definition at line 416 of file MFRC522.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   418                               \{\par
  419     return PICC_REQA_or_WUPA(PICC_CMD_WUPA, bufferATQA, bufferSize);\par
  420 \} // End PICC_WakeupA()\par
}
}
{\xe \v setBitMask\:MFRC522}
{\xe \v MFRC522\:setBitMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MFRC522::setBitMask (unsigned char  {\i reg}, unsigned char  {\i mask})}}
\par
{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v setSPIConfig\:MFRC522}
{\xe \v MFRC522\:setSPIConfig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MFRC522::setSPIConfig ()}}
\par
{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set SPI bus to work with {\b MFRC522} chip. Please call this function if you have changed the SPI config since the {\b MFRC522} constructor was run. \par
}{
Definition at line 39 of file MFRC522.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    39                            \{\par
   40     SPI.begin();            // Init SPI bus\par
   41     SPI.setClockDivider(SPI_CLOCK_DIV8);\par
   42     SPI.setBitOrder(MSBFIRST);\par
   43     SPI.setDataMode(SPI_MODE0);\par
   44 \} // End setSPIConfig()\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _chipSelectPin\:MFRC522}
{\xe \v MFRC522\:_chipSelectPin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::_chipSelectPin{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 349 of file MFRC522.h.}\par
}
{\xe \v _resetPowerDownPin\:MFRC522}
{\xe \v MFRC522\:_resetPowerDownPin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::_resetPowerDownPin{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 350 of file MFRC522.h.}\par
}
{\xe \v FIFO_SIZE\:MFRC522}
{\xe \v MFRC522\:FIFO_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const byte MFRC522::FIFO_SIZE = 64{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 269 of file MFRC522.h.}\par
}
{\xe \v uid\:MFRC522}
{\xe \v MFRC522\:uid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Uid} MFRC522::uid}}
\par
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 266 of file MFRC522.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/MFRC522/src/{\b MFRC522.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/MFRC522/src/{\b MFRC522.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MFRC522::MIFARE_Key Struct Reference\par \pard\plain 
{\tc\tcl2 \v MFRC522::MIFARE_Key}
{\xe \v MFRC522::MIFARE_Key}
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
\par
{
{\f2 #include <MFRC522.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b keyByte} [{\b MF_KEY_SIZE}]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 261 of file MFRC522.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v keyByte\:MFRC522::MIFARE_Key}
{\xe \v MFRC522::MIFARE_Key\:keyByte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::MIFARE_Key::keyByte[{\b MF_KEY_SIZE}]}}
\par
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 262 of file MFRC522.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/MFRC522/src/{\b MFRC522.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MQTT Class Reference\par \pard\plain 
{\tc\tcl2 \v MQTT}
{\xe \v MQTT}
{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
\par
{
{\f2 #include <MQTT.h>}}\par
Collaboration diagram for MQTT:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_m_q_t_t__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b EMQTT_QOS} \{ {\b QOS0} = 0, 
{\b QOS1} = 1, 
{\b QOS2} = 2
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b MQTT_VERSION} \{ {\b MQTT_V31} = 3, 
{\b MQTT_V311} = 4
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b EMQTT_CONNACK_RESPONSE} \{ {\b CONN_ACCEPT} = 0, 
{\b CONN_UNACCEPTABLE_PROCOTOL} = 1, 
{\b CONN_ID_REJECT} = 2, 
{\b CONN_SERVER_UNAVAILALE} = 3, 
{\b CONN_BAD_USER_PASSWORD} = 4, 
{\b CONN_NOT_AUTHORIZED} = 5
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MQTT} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MQTT} (char *{\b domain}, uint16_t {\b port}, void(*{\b callback})(char *, uint8_t *, unsigned int))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MQTT} (char *{\b domain}, uint16_t {\b port}, void(*{\b callback})(char *, uint8_t *, unsigned int), int {\b maxpacketsize})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MQTT} (uint8_t *{\b ip}, uint16_t {\b port}, void(*{\b callback})(char *, uint8_t *, unsigned int))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MQTT} (uint8_t *{\b ip}, uint16_t {\b port}, void(*{\b callback})(char *, uint8_t *, unsigned int), int {\b maxpacketsize})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MQTT} (char *{\b domain}, uint16_t {\b port}, int {\b keepalive}, void(*{\b callback})(char *, uint8_t *, unsigned int))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MQTT} (char *{\b domain}, uint16_t {\b port}, int {\b keepalive}, void(*{\b callback})(char *, uint8_t *, unsigned int), int {\b maxpacketsize})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MQTT} (uint8_t *{\b ip}, uint16_t {\b port}, int {\b keepalive}, void(*{\b callback})(char *, uint8_t *, unsigned int))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MQTT} (uint8_t *{\b ip}, uint16_t {\b port}, int {\b keepalive}, void(*{\b callback})(char *, uint8_t *, unsigned int), int {\b maxpacketsize})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~MQTT} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBroker} (char *{\b domain}, uint16_t {\b port})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBroker} (uint8_t *{\b ip}, uint16_t {\b port})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b connect} (const char *id)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b connect} (const char *id, const char *user, const char *pass)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b connect} (const char *id, const char *user, const char *pass, const char *willTopic, {\b EMQTT_QOS} willQos, uint8_t willRetain, const char *willMessage, bool cleanSession, {\b MQTT_VERSION} version={\b MQTT_V311})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b disconnect} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b publish} (const char *topic, const char *payload)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b publish} (const char *topic, const char *payload, bool retain)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b publish} (const char *topic, const char *payload, {\b EMQTT_QOS} qos, uint16_t *messageid=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b publish} (const char *topic, const char *payload, {\b EMQTT_QOS} qos, bool dup, uint16_t *messageid=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b publish} (const char *topic, const uint8_t *pyaload, unsigned int plength)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b publish} (const char *topic, const uint8_t *payload, unsigned int plength, {\b EMQTT_QOS} qos, uint16_t *messageid=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b publish} (const char *topic, const uint8_t *payload, unsigned int plength, {\b EMQTT_QOS} qos, bool dup, uint16_t *messageid=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b publish} (const char *topic, const uint8_t *payload, unsigned int plength, bool retain)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b publish} (const char *topic, const uint8_t *payload, unsigned int plength, bool retain, {\b EMQTT_QOS} qos, uint16_t *messageid=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b publish} (const char *topic, const uint8_t *payload, unsigned int plength, bool retain, {\b EMQTT_QOS} qos, bool dup, uint16_t *messageid)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addQosCallback} (void(*{\b qoscallback})(unsigned int))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b subscribe} (const char *topic)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b subscribe} (const char *topic, {\b EMQTT_QOS})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b unsubscribe} (const char *topic)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b loop} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isConnected} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b readPacket} (uint8_t *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t {\b readByte} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b write} (uint8_t header, uint8_t *buf, uint16_t length)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b writeString} (const char *string, uint8_t *buf, uint16_t pos)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initialize} (char *{\b domain}, uint8_t *{\b ip}, uint16_t {\b port}, int {\b keepalive}, void(*{\b callback})(char *, uint8_t *, unsigned int), int {\b maxpacketsize})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b publishRelease} (uint16_t messageid)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b publishComplete} (uint16_t messageid)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
TCPClient {\b _client}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t * {\b buffer} = NULL\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b nextMsgId}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b lastOutActivity}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b lastInActivity}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b pingOutstanding}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void(* {\b callback} )(char *, uint8_t *, unsigned int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void(* {\b qoscallback} )(unsigned int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} {\b domain}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint8_t * {\b ip} = NULL\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b port}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b keepalive}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint16_t {\b maxpacketsize}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 105 of file MQTT.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v EMQTT_CONNACK_RESPONSE\:MQTT}
{\xe \v MQTT\:EMQTT_CONNACK_RESPONSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b MQTT::EMQTT_CONNACK_RESPONSE}}}
\par
{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v CONN_ACCEPT\:MQTT}
{\xe \v MQTT\:CONN_ACCEPT}
{\qr CONN_ACCEPT{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
\cell }{\cell }{\row }
{\xe \v CONN_UNACCEPTABLE_PROCOTOL\:MQTT}
{\xe \v MQTT\:CONN_UNACCEPTABLE_PROCOTOL}
{\qr CONN_UNACCEPTABLE_PROCOTOL{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
\cell }{\cell }{\row }
{\xe \v CONN_ID_REJECT\:MQTT}
{\xe \v MQTT\:CONN_ID_REJECT}
{\qr CONN_ID_REJECT{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
\cell }{\cell }{\row }
{\xe \v CONN_SERVER_UNAVAILALE\:MQTT}
{\xe \v MQTT\:CONN_SERVER_UNAVAILALE}
{\qr CONN_SERVER_UNAVAILALE{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
\cell }{\cell }{\row }
{\xe \v CONN_BAD_USER_PASSWORD\:MQTT}
{\xe \v MQTT\:CONN_BAD_USER_PASSWORD}
{\qr CONN_BAD_USER_PASSWORD{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
\cell }{\cell }{\row }
{\xe \v CONN_NOT_AUTHORIZED\:MQTT}
{\xe \v MQTT\:CONN_NOT_AUTHORIZED}
{\qr CONN_NOT_AUTHORIZED{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
\cell }{\cell }{\row }
}
\par
{
Definition at line 119 of file MQTT.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   119              \{\par
  120     CONN_ACCEPT = 0,\par
  121     CONN_UNACCEPTABLE_PROCOTOL = 1,\par
  122     CONN_ID_REJECT = 2,\par
  123     CONN_SERVER_UNAVAILALE = 3,\par
  124     CONN_BAD_USER_PASSWORD = 4,\par
  125     CONN_NOT_AUTHORIZED = 5\par
  126 \} EMQTT_CONNACK_RESPONSE;\par
}
}
{\xe \v EMQTT_QOS\:MQTT}
{\xe \v MQTT\:EMQTT_QOS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b MQTT::EMQTT_QOS}}}
\par
{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
types \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v QOS0\:MQTT}
{\xe \v MQTT\:QOS0}
{\qr QOS0{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
\cell }{\cell }{\row }
{\xe \v QOS1\:MQTT}
{\xe \v MQTT\:QOS1}
{\qr QOS1{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
\cell }{\cell }{\row }
{\xe \v QOS2\:MQTT}
{\xe \v MQTT\:QOS2}
{\qr QOS2{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
\cell }{\cell }{\row }
}
\par
{
Definition at line 108 of file MQTT.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   108              \{\par
  109     QOS0 = 0,\par
  110     QOS1 = 1,\par
  111     QOS2 = 2,\par
  112 \} EMQTT_QOS;\par
}
}
{\xe \v MQTT_VERSION\:MQTT}
{\xe \v MQTT\:MQTT_VERSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b MQTT::MQTT_VERSION}}}
\par
{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v MQTT_V31\:MQTT}
{\xe \v MQTT\:MQTT_V31}
{\qr MQTT_V31{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
\cell }{\cell }{\row }
{\xe \v MQTT_V311\:MQTT}
{\xe \v MQTT\:MQTT_V311}
{\qr MQTT_V311{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
\cell }{\cell }{\row }
}
\par
{
Definition at line 114 of file MQTT.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   114             \{\par
  115     MQTT_V31 = 3,\par
  116     MQTT_V311 = 4\par
  117 \} MQTT_VERSION;\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v MQTT\:MQTT}
{\xe \v MQTT\:MQTT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MQTT::MQTT (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 152 of file MQTT.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   152 \{\};\par
}
}
{\xe \v MQTT\:MQTT}
{\xe \v MQTT\:MQTT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MQTT::MQTT (char *  {\i domain}, uint16_t  {\i port}, void(*)(char *, uint8_t *, unsigned int)  {\i callback})}}
\par
{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file MQTT.cpp.}\par
{
References initialize().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    12                                                                                      \{\par
   13     this->initialize(domain, NULL, port, MQTT_DEFAULT_KEEPALIVE, callback, MQTT_MAX_PACKET_SIZE);\par
   14 \}\par
}
}
{\xe \v MQTT\:MQTT}
{\xe \v MQTT\:MQTT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MQTT::MQTT (char *  {\i domain}, uint16_t  {\i port}, void(*)(char *, uint8_t *, unsigned int)  {\i callback}, int  {\i maxpacketsize})}}
\par
{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file MQTT.cpp.}\par
{
References initialize().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    16                                                                                                         \{\par
   17     this->initialize(domain, NULL, port, MQTT_DEFAULT_KEEPALIVE, callback, maxpacketsize);\par
   18 \}\par
}
}
{\xe \v MQTT\:MQTT}
{\xe \v MQTT\:MQTT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MQTT::MQTT (uint8_t *  {\i ip}, uint16_t  {\i port}, void(*)(char *, uint8_t *, unsigned int)  {\i callback})}}
\par
{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file MQTT.cpp.}\par
{
References initialize().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    20                                                                                     \{\par
   21     this->initialize(NULL, ip, port, MQTT_DEFAULT_KEEPALIVE, callback, MQTT_MAX_PACKET_SIZE);\par
   22 \}\par
}
}
{\xe \v MQTT\:MQTT}
{\xe \v MQTT\:MQTT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MQTT::MQTT (uint8_t *  {\i ip}, uint16_t  {\i port}, void(*)(char *, uint8_t *, unsigned int)  {\i callback}, int  {\i maxpacketsize})}}
\par
{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 24 of file MQTT.cpp.}\par
{
References initialize().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    24                                                                                                        \{\par
   25     this->initialize(NULL, ip, port, MQTT_DEFAULT_KEEPALIVE, callback, maxpacketsize);\par
   26 \}\par
}
}
{\xe \v MQTT\:MQTT}
{\xe \v MQTT\:MQTT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MQTT::MQTT (char *  {\i domain}, uint16_t  {\i port}, int  {\i keepalive}, void(*)(char *, uint8_t *, unsigned int)  {\i callback})}}
\par
{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file MQTT.cpp.}\par
{
References initialize().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    28                                                                                                     \{\par
   29     this->initialize(domain, NULL, port, keepalive, callback, MQTT_MAX_PACKET_SIZE);\par
   30 \}\par
}
}
{\xe \v MQTT\:MQTT}
{\xe \v MQTT\:MQTT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MQTT::MQTT (char *  {\i domain}, uint16_t  {\i port}, int  {\i keepalive}, void(*)(char *, uint8_t *, unsigned int)  {\i callback}, int  {\i maxpacketsize})}}
\par
{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file MQTT.cpp.}\par
{
References initialize().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    32                                                                                                                        \{\par
   33     this->initialize(domain, NULL, port, keepalive, callback, maxpacketsize);\par
   34 \}\par
}
}
{\xe \v MQTT\:MQTT}
{\xe \v MQTT\:MQTT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MQTT::MQTT (uint8_t *  {\i ip}, uint16_t  {\i port}, int  {\i keepalive}, void(*)(char *, uint8_t *, unsigned int)  {\i callback})}}
\par
{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 36 of file MQTT.cpp.}\par
{
References initialize().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    36                                                                                                    \{\par
   37     this->initialize(NULL, ip, port, keepalive, callback, MQTT_MAX_PACKET_SIZE);\par
   38 \}\par
}
}
{\xe \v MQTT\:MQTT}
{\xe \v MQTT\:MQTT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MQTT::MQTT (uint8_t *  {\i ip}, uint16_t  {\i port}, int  {\i keepalive}, void(*)(char *, uint8_t *, unsigned int)  {\i callback}, int  {\i maxpacketsize})}}
\par
{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file MQTT.cpp.}\par
{
References initialize().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    40                                                                                                                       \{\par
   41     this->initialize(NULL, ip, port, keepalive, callback, maxpacketsize);\par
   42 \}\par
}
}
{\xe \v ~MQTT\:MQTT}
{\xe \v MQTT\:~MQTT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MQTT::~MQTT ()}}
\par
{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file MQTT.cpp.}\par
{
References buffer, disconnect(), and isConnected().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    44             \{\par
   45     if (isConnected()) \{\par
   46         disconnect();\par
   47     \}\par
   48 \par
   49     if (buffer != NULL)\par
   50       delete[] buffer;\par
   51 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addQosCallback\:MQTT}
{\xe \v MQTT\:addQosCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MQTT::addQosCallback (void(*)(unsigned int)  {\i qoscallback})}}
\par
{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 89 of file MQTT.cpp.}\par
{
References qoscallback.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    89                                                            \{\par
   90     this->qoscallback = qoscallback;\par
   91 \}\par
}
}
{\xe \v clear\:MQTT}
{\xe \v MQTT\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MQTT::clear ()}}
\par
{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 534 of file MQTT.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   534                  \{\par
  535   _client.stop();\par
  536   lastInActivity = lastOutActivity = millis();\par
  537 \}\par
}
}
{\xe \v connect\:MQTT}
{\xe \v MQTT\:connect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MQTT::connect (const char *  {\i id})}}
\par
{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 94 of file MQTT.cpp.}\par
{
References connect(), and QOS0.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    94                                  \{\par
   95     return connect(id, NULL, NULL, 0, QOS0, 0, 0, true);\par
   96 \}\par
}
}
{\xe \v connect\:MQTT}
{\xe \v MQTT\:connect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MQTT::connect (const char *  {\i id}, const char *  {\i user}, const char *  {\i pass})}}
\par
{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 98 of file MQTT.cpp.}\par
{
References connect(), and QOS0.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    98                                                                      \{\par
   99     return connect(id, user, pass, 0, QOS0, 0, 0, true);\par
  100 \}\par
}
}
{\xe \v connect\:MQTT}
{\xe \v MQTT\:connect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MQTT::connect (const char *  {\i id}, const char *  {\i user}, const char *  {\i pass}, const char *  {\i willTopic}, {\b EMQTT_QOS}  {\i willQos}, uint8_t  {\i willRetain}, const char *  {\i willMessage}, bool  {\i cleanSession}, {\b MQTT_VERSION}  {\i version} = {\f2 {\b MQTT_V311}})}}
\par
{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 102 of file MQTT.cpp.}\par
{
References buffer, CONN_ACCEPT, isConnected(), keepalive, MQTT_V31, MQTT_V311, nextMsgId, pingOutstanding, readPacket(), write(), and writeString().}\par
{
Referenced by connect().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   102                                                                                                                                                                                                      \{\par
  103     if (!isConnected()) \{\par
  104         int result = 0;\par
  105         if (ip == NULL)\par
  106             result = _client.connect(this->domain.c_str(), this->port);\par
  107         else\par
  108             result = _client.connect(this->ip, this->port);\par
  109 \par
  110         if (result) \{\par
  111             nextMsgId = 1;\par
  112             uint16_t length = 5;\par
  113 \par
  114             if (version == MQTT_V311) \{\par
  115                 const uint8_t MQTT_HEADER_V311[] = \{0x00,0x04,'M','Q','T','T',MQTT_V311\};\par
  116                 memcpy(buffer + length, MQTT_HEADER_V311, sizeof(MQTT_HEADER_V311));\par
  117                 length+=sizeof(MQTT_HEADER_V311);\par
  118             \} else \{\par
  119                 const uint8_t MQTT_HEADER_V31[] = \{0x00,0x06,'M','Q','I','s','d','p', MQTT_V31\};\par
  120                 memcpy(buffer + length, MQTT_HEADER_V31, sizeof(MQTT_HEADER_V31));\par
  121                 length+=sizeof(MQTT_HEADER_V31);\par
  122             \}\par
  123 \par
  124             uint8_t v = 0;\par
  125             if (willTopic) \{\par
  126                 v = 0x06|(willQos<<3)|(willRetain<<5);\par
  127             \} else \{\par
  128                 v = 0x02;\par
  129             \}\par
  130 \par
  131             if (!cleanSession) \{\par
  132               v = v&0xfd;\par
  133             \}\par
  134 \par
  135             if(user != NULL) \{\par
  136                 v = v|0x80;\par
  137 \par
  138                 if(pass != NULL) \{\par
  139                     v = v|(0x80>>1);\par
  140                 \}\par
  141             \}\par
  142 \par
  143             buffer[length++] = v;\par
  144 \par
  145             buffer[length++] = ((this->keepalive) >> 8);\par
  146             buffer[length++] = ((this->keepalive) & 0xFF);\par
  147             length = writeString(id, buffer, length);\par
  148             if (willTopic) \{\par
  149                 length = writeString(willTopic, buffer, length);\par
  150                 length = writeString(willMessage, buffer, length);\par
  151             \}\par
  152 \par
  153             if(user != NULL) \{\par
  154                 length = writeString(user,buffer,length);\par
  155                 if(pass != NULL) \{\par
  156                     length = writeString(pass,buffer,length);\par
  157                 \}\par
  158             \}\par
  159 \par
  160             write(MQTTCONNECT, buffer, length-5);\par
  161             lastInActivity = lastOutActivity = millis();\par
  162 \par
  163             while (!_client.available()) \{\par
  164                 unsigned long t = millis();\par
  165                 if (t-lastInActivity > this->keepalive*1000UL) \{\par
  166                     _client.stop();\par
  167                     return false;\par
  168                 \}\par
  169             \}\par
  170             uint8_t llen;\par
  171             uint16_t len = readPacket(&llen);\par
  172 \par
  173             if (len == 4) \{\par
  174                 if (buffer[3] == CONN_ACCEPT) \{\par
  175                     lastInActivity = millis();\par
  176                     pingOutstanding = false;\par
  177                     debug_print(" Connect success\\n");\par
  178                     return true;\par
  179                 \} else \{\par
  180                     // check EMQTT_CONNACK_RESPONSE code.\par
  181                     debug_print(" Connect fail. code = [%d]\\n", buffer[3]);\par
  182                 \}\par
  183             \}\par
  184         \}\par
  185         _client.stop();\par
  186     \}\par
  187     return false;\par
  188 \}\par
}
}
{\xe \v disconnect\:MQTT}
{\xe \v MQTT\:disconnect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MQTT::disconnect ()}}
\par
{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 506 of file MQTT.cpp.}\par
{
References buffer.}\par
{
Referenced by setBroker(), and ~MQTT().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   506                       \{\par
  507     buffer[0] = MQTTDISCONNECT;\par
  508     buffer[1] = 0;\par
  509     _client.write(buffer,2);\par
  510     _client.stop();\par
  511     lastInActivity = lastOutActivity = millis();\par
  512 \}\par
}
}
{\xe \v initialize\:MQTT}
{\xe \v MQTT\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MQTT::initialize (char *  {\i domain}, uint8_t *  {\i ip}, uint16_t  {\i port}, int  {\i keepalive}, void(*)(char *, uint8_t *, unsigned int)  {\i callback}, int  {\i maxpacketsize}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 53 of file MQTT.cpp.}\par
{
References buffer, callback, domain, ip, keepalive, maxpacketsize, String::operator=(), port, and qoscallback.}\par
{
Referenced by MQTT().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    53                                                                                                                                                \{\par
   54     this->callback = callback;\par
   55     this->qoscallback = NULL;\par
   56     if (ip != NULL)\par
   57         this->ip = ip;\par
   58     if (domain != NULL)\par
   59         this->domain = domain;\par
   60     this->port = port;\par
   61     this->keepalive = keepalive;\par
   62 \par
   63     // if maxpacketsize is over MQTT_MAX_PACKET_SIZE.\par
   64     this->maxpacketsize = (maxpacketsize <= MQTT_MAX_PACKET_SIZE ? MQTT_MAX_PACKET_SIZE : maxpacketsize);\par
   65     if (buffer != NULL)\par
   66       delete[] buffer;\par
   67     buffer = new uint8_t[this->maxpacketsize];\par
   68 \}\par
}
}
{\xe \v isConnected\:MQTT}
{\xe \v MQTT\:isConnected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MQTT::isConnected ()}}
\par
{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 528 of file MQTT.cpp.}\par
{
Referenced by connect(), loop(), publish(), publishComplete(), publishRelease(), setBroker(), subscribe(), unsubscribe(), and ~MQTT().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   528                        \{\par
  529     bool rc = (int)_client.connected();\par
  530     if (!rc) _client.stop();\par
  531     return rc;\par
  532 \}\par
}
}
{\xe \v loop\:MQTT}
{\xe \v MQTT\:loop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MQTT::loop ()}}
\par
{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 240 of file MQTT.cpp.}\par
{
References buffer, callback, isConnected(), keepalive, lastInActivity, lastOutActivity, pingOutstanding, publishComplete(), publishRelease(), qoscallback, and readPacket().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   240                 \{\par
  241     if (isConnected()) \{\par
  242         unsigned long t = millis();\par
  243         if ((t - lastInActivity > this->keepalive*1000UL) || (t - lastOutActivity > this->keepalive*1000UL)) \{\par
  244             if (pingOutstanding) \{\par
  245                 _client.stop();\par
  246                 return false;\par
  247             \} else \{\par
  248                 buffer[0] = MQTTPINGREQ;\par
  249                 buffer[1] = 0;\par
  250                 _client.write(buffer,2);\par
  251                 lastOutActivity = t;\par
  252                 lastInActivity = t;\par
  253                 pingOutstanding = true;\par
  254             \}\par
  255         \}\par
  256         if (_client.available()) \{\par
  257             uint8_t llen;\par
  258             uint16_t len = readPacket(&llen);\par
  259             uint16_t msgId = 0;\par
  260             uint8_t *payload;\par
  261             if (len > 0) \{\par
  262                 lastInActivity = t;\par
  263                 uint8_t type = buffer[0]&0xF0;\par
  264                 if (type == MQTTPUBLISH) \{\par
  265                     if (callback) \{\par
  266                         uint16_t tl = (buffer[llen+1]<<8)+buffer[llen+2]; // topic length\par
  267                         char topic[tl+1];\par
  268                         for (uint16_t i=0;i<tl;i++) \{\par
  269                             topic[i] = buffer[llen+3+i];\par
  270                         \}\par
  271                         topic[tl] = 0;\par
  272                         // msgId only present for QOS>0\par
  273                         if ((buffer[0]&0x06) == MQTTQOS1_HEADER_MASK) \{ // QoS=1\par
  274                             msgId = (buffer[llen+3+tl]<<8)+buffer[llen+3+tl+1];\par
  275                             payload = buffer+llen+3+tl+2;\par
  276                             callback(topic,payload,len-llen-3-tl-2);\par
  277 \par
  278                             buffer[0] = MQTTPUBACK; // respond with PUBACK\par
  279                             buffer[1] = 2;\par
  280                             buffer[2] = (msgId >> 8);\par
  281                             buffer[3] = (msgId & 0xFF);\par
  282                             _client.write(buffer,4);\par
  283                             lastOutActivity = t;\par
  284                                     \} else if ((buffer[0] & 0x06) == MQTTQOS2_HEADER_MASK) \{ // QoS=2\par
  285                                           msgId = (buffer[llen + 3 + tl] << 8) + buffer[llen + 3 + tl + 1];\par
  286                                           payload = buffer + llen + 3 + tl + 2;\par
  287                                           callback(topic, payload, len - llen - 3 - tl - 2);\par
  288 \par
  289                                         buffer[0] = MQTTPUBREC; // respond with PUBREC\par
  290                                         buffer[1] = 2;\par
  291                                         buffer[2] = (msgId >> 8);\par
  292                                         buffer[3] = (msgId & 0xFF);\par
  293                                         _client.write(buffer, 4);\par
  294                                         lastOutActivity = t;\par
  295                                     \} else \{\par
  296                             payload = buffer+llen+3+tl;\par
  297                             callback(topic,payload,len-llen-3-tl);\par
  298                         \}\par
  299                     \}\par
  300                 \} else if (type == MQTTPUBREC) \{\par
  301                     // check for the situation that QoS2 receive PUBREC, should return PUBREL\par
  302                     msgId = (buffer[2] << 8) + buffer[3];\par
  303                     this->publishRelease(msgId);\par
  304                 \} else if (type == MQTTPUBACK) \{\par
  305                     if (qoscallback) \{\par
  306                         // this case QOS==1\par
  307                         if (len == 4 && (buffer[0]&0x06) == MQTTQOS0_HEADER_MASK) \{\par
  308                             msgId = (buffer[2]<<8)+buffer[3];\par
  309                             this->qoscallback(msgId);\par
  310                         \}\par
  311                     \}\par
  312                 \} else if (type == MQTTPUBREL) \{\par
  313                   msgId = (buffer[2] << 8) + buffer[3];\par
  314                   this->publishComplete(msgId);\par
  315                 \} else if (type == MQTTPUBCOMP) \{\par
  316                   if (qoscallback) \{\par
  317                       // msgId only present for QOS==0\par
  318                       if (len == 4 && (buffer[0]&0x06) == MQTTQOS0_HEADER_MASK) \{\par
  319                           msgId = (buffer[2]<<8)+buffer[3];\par
  320                           this->qoscallback(msgId);\par
  321                       \}\par
  322                   \}\par
  323                 \} else if (type == MQTTSUBACK) \{\par
  324                     // if something...\par
  325                 \} else if (type == MQTTPINGREQ) \{\par
  326                     buffer[0] = MQTTPINGRESP;\par
  327                     buffer[1] = 0;\par
  328                     _client.write(buffer,2);\par
  329                 \} else if (type == MQTTPINGRESP) \{\par
  330                     pingOutstanding = false;\par
  331                 \}\par
  332             \}\par
  333         \}\par
  334         return true;\par
  335     \}\par
  336     return false;\par
  337 \}\par
}
}
{\xe \v publish\:MQTT}
{\xe \v MQTT\:publish}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MQTT::publish (const char *  {\i topic}, const char *  {\i payload})}}
\par
{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 339 of file MQTT.cpp.}\par
{
References publish(), and QOS0.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   339                                                          \{\par
  340     return publish(topic, (uint8_t*)payload, strlen(payload), false, QOS0, NULL);\par
  341 \}\par
}
}
{\xe \v publish\:MQTT}
{\xe \v MQTT\:publish}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MQTT::publish (const char *  {\i topic}, const char *  {\i payload}, bool  {\i retain})}}
\par
{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 343 of file MQTT.cpp.}\par
{
References publish(), and QOS0.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   343                                                                       \{\par
  344     return publish(topic, (uint8_t*)payload, strlen(payload), retain, QOS0, NULL);\par
  345 \}\par
}
}
{\xe \v publish\:MQTT}
{\xe \v MQTT\:publish}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MQTT::publish (const char *  {\i topic}, const char *  {\i payload}, {\b EMQTT_QOS}  {\i qos}, uint16_t *  {\i messageid} = {\f2 NULL})}}
\par
{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 351 of file MQTT.cpp.}\par
{
References publish().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   351                                                                                               \{\par
  352     return publish(topic, (uint8_t*)payload, strlen(payload), false, qos, messageid);\par
  353 \}\par
}
}
{\xe \v publish\:MQTT}
{\xe \v MQTT\:publish}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MQTT::publish (const char *  {\i topic}, const char *  {\i payload}, {\b EMQTT_QOS}  {\i qos}, bool  {\i dup}, uint16_t *  {\i messageid} = {\f2 NULL})}}
\par
{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 347 of file MQTT.cpp.}\par
{
References publish().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   347                                                                                                         \{\par
  348     return publish(topic, (uint8_t*)payload, strlen(payload), false, qos, dup, messageid);\par
  349 \}\par
}
}
{\xe \v publish\:MQTT}
{\xe \v MQTT\:publish}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MQTT::publish (const char *  {\i topic}, const uint8_t *  {\i pyaload}, unsigned int  {\i plength})}}
\par
{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 355 of file MQTT.cpp.}\par
{
References publish(), and QOS0.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   355                                                                                   \{\par
  356     return publish(topic, payload, plength, false, QOS0, NULL);\par
  357 \}\par
}
}
{\xe \v publish\:MQTT}
{\xe \v MQTT\:publish}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MQTT::publish (const char *  {\i topic}, const uint8_t *  {\i payload}, unsigned int  {\i plength}, {\b EMQTT_QOS}  {\i qos}, uint16_t *  {\i messageid} = {\f2 NULL})}}
\par
{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 363 of file MQTT.cpp.}\par
{
References publish().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   363                                                                                                                       \{\par
  364     return publish(topic, payload, plength, false, qos, messageid);\par
  365 \}\par
}
}
{\xe \v publish\:MQTT}
{\xe \v MQTT\:publish}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MQTT::publish (const char *  {\i topic}, const uint8_t *  {\i payload}, unsigned int  {\i plength}, {\b EMQTT_QOS}  {\i qos}, bool  {\i dup}, uint16_t *  {\i messageid} = {\f2 NULL})}}
\par
{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 359 of file MQTT.cpp.}\par
{
References publish().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   359                                                                                                                                 \{\par
  360     return publish(topic, payload, plength, false, qos, dup, messageid);\par
  361 \}\par
}
}
{\xe \v publish\:MQTT}
{\xe \v MQTT\:publish}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MQTT::publish (const char *  {\i topic}, const uint8_t *  {\i payload}, unsigned int  {\i plength}, bool  {\i retain})}}
\par
{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 367 of file MQTT.cpp.}\par
{
References publish(), and QOS0.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   367                                                                                                \{\par
  368     return publish(topic, payload, plength, retain, QOS0, NULL);\par
  369 \}\par
}
}
{\xe \v publish\:MQTT}
{\xe \v MQTT\:publish}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MQTT::publish (const char *  {\i topic}, const uint8_t *  {\i payload}, unsigned int  {\i plength}, bool  {\i retain}, {\b EMQTT_QOS}  {\i qos}, uint16_t *  {\i messageid} = {\f2 NULL})}}
\par
{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 371 of file MQTT.cpp.}\par
{
References publish().}\par
{
Referenced by publish().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   371                                                                                                                                    \{\par
  372     return publish(topic, payload, plength, retain, qos, false, messageid);\par
  373 \}\par
}
}
{\xe \v publish\:MQTT}
{\xe \v MQTT\:publish}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MQTT::publish (const char *  {\i topic}, const uint8_t *  {\i payload}, unsigned int  {\i plength}, bool  {\i retain}, {\b EMQTT_QOS}  {\i qos}, bool  {\i dup}, uint16_t *  {\i messageid})}}
\par
{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 375 of file MQTT.cpp.}\par
{
References buffer, isConnected(), maxpacketsize, nextMsgId, QOS1, QOS2, write(), and writeString().}\par
{
Referenced by publish().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   375                                                                                                                                              \{\par
  376     if (isConnected()) \{\par
  377         // Leave room in the buffer for header and variable length field\par
  378         uint16_t length = 5;\par
  379         memset(buffer, 0, this->maxpacketsize);\par
  380 \par
  381         length = writeString(topic, buffer, length);\par
  382 \par
  383         if (qos == QOS2 || qos == QOS1) \{\par
  384             nextMsgId += 1;\par
  385             buffer[length++] = (nextMsgId >> 8);\par
  386             buffer[length++] = (nextMsgId & 0xFF);\par
  387             if (messageid != NULL)\par
  388                 *messageid = nextMsgId++;\par
  389         \}\par
  390 \par
  391         for (uint16_t i=0; i < plength && length < this->maxpacketsize; i++) \{\par
  392             buffer[length++] = payload[i];\par
  393         \}\par
  394 \par
  395         uint8_t header = MQTTPUBLISH;\par
  396         if (retain) \{\par
  397             header |= 1;\par
  398         \}\par
  399 \par
  400         if (dup) \{\par
  401             header |= DUP_FLAG_ON_MASK;\par
  402         \}\par
  403 \par
  404         if (qos == QOS2)\par
  405             header |= MQTTQOS2_HEADER_MASK;\par
  406         else if (qos == QOS1)\par
  407             header |= MQTTQOS1_HEADER_MASK;\par
  408         else\par
  409             header |= MQTTQOS0_HEADER_MASK;\par
  410 \par
  411         return write(header, buffer, length-5);\par
  412     \}\par
  413     return false;\par
  414 \}\par
}
}
{\xe \v publishComplete\:MQTT}
{\xe \v MQTT\:publishComplete}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MQTT::publishComplete (uint16_t  {\i messageid}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 429 of file MQTT.cpp.}\par
{
References buffer, and isConnected().}\par
{
Referenced by loop().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   429                                              \{\par
  430     if (isConnected()) \{\par
  431         uint16_t length = 0;\par
  432         // reserved bits in MQTT v3.1.1\par
  433         buffer[length++] = MQTTPUBCOMP | MQTTQOS1_HEADER_MASK;\par
  434         buffer[length++] = 2;\par
  435         buffer[length++] = (messageid >> 8);\par
  436         buffer[length++] = (messageid & 0xFF);\par
  437         return _client.write(buffer, length);\par
  438     \}\par
  439     return false;\par
  440 \}\par
}
}
{\xe \v publishRelease\:MQTT}
{\xe \v MQTT\:publishRelease}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MQTT::publishRelease (uint16_t  {\i messageid}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 416 of file MQTT.cpp.}\par
{
References buffer, and isConnected().}\par
{
Referenced by loop().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   416                                             \{\par
  417     if (isConnected()) \{\par
  418         uint16_t length = 0;\par
  419         // reserved bits in MQTT v3.1.1\par
  420         buffer[length++] = MQTTPUBREL | MQTTQOS1_HEADER_MASK;\par
  421         buffer[length++] = 2;\par
  422         buffer[length++] = (messageid >> 8);\par
  423         buffer[length++] = (messageid & 0xFF);\par
  424         return _client.write(buffer, length);\par
  425     \}\par
  426     return false;\par
  427 \}\par
}
}
{\xe \v readByte\:MQTT}
{\xe \v MQTT\:readByte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t MQTT::readByte (){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 190 of file MQTT.cpp.}\par
{
Referenced by readPacket().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   190                        \{\par
  191     while(!_client.available()) \{\}\par
  192     return _client.read();\par
  193 \}\par
}
}
{\xe \v readPacket\:MQTT}
{\xe \v MQTT\:readPacket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t MQTT::readPacket (uint8_t *  {\i lengthLength}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 195 of file MQTT.cpp.}\par
{
References buffer, maxpacketsize, and readByte().}\par
{
Referenced by connect(), and loop().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   195                                                \{\par
  196     uint16_t len = 0;\par
  197     buffer[len++] = readByte();\par
  198     bool isPublish = (buffer[0]&0xF0) == MQTTPUBLISH;\par
  199     uint32_t multiplier = 1;\par
  200     uint16_t length = 0;\par
  201     uint8_t digit = 0;\par
  202     uint16_t skip = 0;\par
  203     uint8_t start = 0;\par
  204 \par
  205     do \{\par
  206         digit = readByte();\par
  207         buffer[len++] = digit;\par
  208         length += (digit & 127) * multiplier;\par
  209         multiplier *= 128;\par
  210     \} while ((digit & 128) != 0);\par
  211     *lengthLength = len-1;\par
  212 \par
  213     if (isPublish) \{\par
  214         // Read in topic length to calculate bytes to skip over for Stream writing\par
  215         buffer[len++] = readByte();\par
  216         buffer[len++] = readByte();\par
  217         skip = (buffer[*lengthLength+1]<<8)+buffer[*lengthLength+2];\par
  218         start = 2;\par
  219         if (buffer[0] & MQTTQOS1_HEADER_MASK) \{\par
  220             // skip message id\par
  221             skip += 2;\par
  222         \}\par
  223     \}\par
  224 \par
  225     for (uint16_t i = start;i<length;i++) \{\par
  226         digit = readByte();\par
  227         if (len < this->maxpacketsize) \{\par
  228             buffer[len] = digit;\par
  229         \}\par
  230         len++;\par
  231     \}\par
  232 \par
  233     if (len > this->maxpacketsize) \{\par
  234         len = 0; // This will cause the packet to be ignored.\par
  235     \}\par
  236 \par
  237     return len;\par
  238 \}\par
}
}
{\xe \v setBroker\:MQTT}
{\xe \v MQTT\:setBroker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MQTT::setBroker (char *  {\i domain}, uint16_t  {\i port})}}
\par
{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 70 of file MQTT.cpp.}\par
{
References disconnect(), domain, ip, isConnected(), String::operator=(), and port.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    70                                                 \{\par
   71     if(isConnected()) \{\par
   72         disconnect();\par
   73     \}\par
   74     this->domain = domain;\par
   75     this->ip = NULL;\par
   76     this->port = port;\par
   77 \}\par
}
}
{\xe \v setBroker\:MQTT}
{\xe \v MQTT\:setBroker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MQTT::setBroker (uint8_t *  {\i ip}, uint16_t  {\i port})}}
\par
{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 79 of file MQTT.cpp.}\par
{
References disconnect(), domain, ip, isConnected(), String::operator=(), and port.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    79                                                \{\par
   80     if(isConnected()) \{\par
   81         disconnect();\par
   82     \}\par
   83     this->domain = "";\par
   84     this->ip = ip;\par
   85     this->port = port;\par
   86 \}\par
}
}
{\xe \v subscribe\:MQTT}
{\xe \v MQTT\:subscribe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MQTT::subscribe (const char *  {\i topic})}}
\par
{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 469 of file MQTT.cpp.}\par
{
References QOS0, and subscribe().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   469                                       \{\par
  470     return subscribe(topic, QOS0);\par
  471 \}\par
}
}
{\xe \v subscribe\:MQTT}
{\xe \v MQTT\:subscribe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MQTT::subscribe (const char *  {\i topic}, {\b EMQTT_QOS}  {\i qos})}}
\par
{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 473 of file MQTT.cpp.}\par
{
References buffer, isConnected(), nextMsgId, write(), and writeString().}\par
{
Referenced by subscribe().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   473                                                      \{\par
  474 \par
  475     if (isConnected()) \{\par
  476         // Leave room in the buffer for header and variable length field\par
  477         uint16_t length = 5;\par
  478         nextMsgId++;\par
  479         if (nextMsgId == 0) \{\par
  480             nextMsgId = 1;\par
  481         \}\par
  482         buffer[length++] = (nextMsgId >> 8);\par
  483         buffer[length++] = (nextMsgId & 0xFF);\par
  484         length = writeString(topic, buffer,length);\par
  485         buffer[length++] = qos;\par
  486         return write(MQTTSUBSCRIBE | MQTTQOS1_HEADER_MASK,buffer,length-5);\par
  487     \}\par
  488     return false;\par
  489 \}\par
}
}
{\xe \v unsubscribe\:MQTT}
{\xe \v MQTT\:unsubscribe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MQTT::unsubscribe (const char *  {\i topic})}}
\par
{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 491 of file MQTT.cpp.}\par
{
References buffer, isConnected(), nextMsgId, write(), and writeString().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   491                                         \{\par
  492     if (isConnected()) \{\par
  493         uint16_t length = 5;\par
  494         nextMsgId++;\par
  495         if (nextMsgId == 0) \{\par
  496             nextMsgId = 1;\par
  497         \}\par
  498         buffer[length++] = (nextMsgId >> 8);\par
  499         buffer[length++] = (nextMsgId & 0xFF);\par
  500         length = writeString(topic, buffer,length);\par
  501         return write(MQTTUNSUBSCRIBE | MQTTQOS1_HEADER_MASK,buffer,length-5);\par
  502     \}\par
  503     return false;\par
  504 \}\par
}
}
{\xe \v write\:MQTT}
{\xe \v MQTT\:write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MQTT::write (uint8_t  {\i header}, uint8_t *  {\i buf}, uint16_t  {\i length}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 442 of file MQTT.cpp.}\par
{
Referenced by connect(), publish(), subscribe(), and unsubscribe().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   442                                                               \{\par
  443     uint8_t lenBuf[4];\par
  444     uint8_t llen = 0;\par
  445     uint8_t digit;\par
  446     uint8_t pos = 0;\par
  447     uint16_t rc;\par
  448     uint16_t len = length;\par
  449     do \{\par
  450         digit = len % 128;\par
  451         len = len / 128;\par
  452         if (len > 0) \{\par
  453             digit |= 0x80;\par
  454         \}\par
  455         lenBuf[pos++] = digit;\par
  456         llen++;\par
  457     \} while(len > 0);\par
  458 \par
  459     buf[4-llen] = header;\par
  460     for (int i = 0; i < llen; i++) \{\par
  461         buf[5-llen+i] = lenBuf[i];\par
  462     \}\par
  463     rc = _client.write(buf+(4-llen), length+1+llen);\par
  464 \par
  465     lastOutActivity = millis();\par
  466     return (rc == 1+llen+length);\par
  467 \}\par
}
}
{\xe \v writeString\:MQTT}
{\xe \v MQTT\:writeString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t MQTT::writeString (const char *  {\i string}, uint8_t *  {\i buf}, uint16_t  {\i pos}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 514 of file MQTT.cpp.}\par
{
References maxpacketsize.}\par
{
Referenced by connect(), publish(), subscribe(), and unsubscribe().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   514                                                                          \{\par
  515     const char* idp = string;\par
  516     uint16_t i = 0;\par
  517     pos += 2;\par
  518     while (*idp && pos < this->maxpacketsize) \{\par
  519         buf[pos++] = *idp++;\par
  520         i++;\par
  521     \}\par
  522     buf[pos-i-2] = (i >> 8);\par
  523     buf[pos-i-1] = (i & 0xFF);\par
  524     return pos;\par
  525 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _client\:MQTT}
{\xe \v MQTT\:_client}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TCPClient MQTT::_client{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 129 of file MQTT.h.}\par
}
{\xe \v buffer\:MQTT}
{\xe \v MQTT\:buffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t* MQTT::buffer = NULL{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 130 of file MQTT.h.}\par
{
Referenced by connect(), disconnect(), initialize(), loop(), publish(), publishComplete(), publishRelease(), readPacket(), subscribe(), unsubscribe(), and ~MQTT().}\par
}
{\xe \v callback\:MQTT}
{\xe \v MQTT\:callback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void(* MQTT::callback) (char *, uint8_t *, unsigned int){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 135 of file MQTT.h.}\par
{
Referenced by initialize(), and loop().}\par
}
{\xe \v domain\:MQTT}
{\xe \v MQTT\:domain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String} MQTT::domain{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 141 of file MQTT.h.}\par
{
Referenced by initialize(), and setBroker().}\par
}
{\xe \v ip\:MQTT}
{\xe \v MQTT\:ip}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint8_t* MQTT::ip = NULL{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 142 of file MQTT.h.}\par
{
Referenced by initialize(), and setBroker().}\par
}
{\xe \v keepalive\:MQTT}
{\xe \v MQTT\:keepalive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MQTT::keepalive{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 144 of file MQTT.h.}\par
{
Referenced by connect(), initialize(), and loop().}\par
}
{\xe \v lastInActivity\:MQTT}
{\xe \v MQTT\:lastInActivity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long MQTT::lastInActivity{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 133 of file MQTT.h.}\par
{
Referenced by loop().}\par
}
{\xe \v lastOutActivity\:MQTT}
{\xe \v MQTT\:lastOutActivity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long MQTT::lastOutActivity{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 132 of file MQTT.h.}\par
{
Referenced by loop().}\par
}
{\xe \v maxpacketsize\:MQTT}
{\xe \v MQTT\:maxpacketsize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t MQTT::maxpacketsize{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 145 of file MQTT.h.}\par
{
Referenced by initialize(), publish(), readPacket(), and writeString().}\par
}
{\xe \v nextMsgId\:MQTT}
{\xe \v MQTT\:nextMsgId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t MQTT::nextMsgId{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 131 of file MQTT.h.}\par
{
Referenced by connect(), publish(), subscribe(), and unsubscribe().}\par
}
{\xe \v pingOutstanding\:MQTT}
{\xe \v MQTT\:pingOutstanding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MQTT::pingOutstanding{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 134 of file MQTT.h.}\par
{
Referenced by connect(), and loop().}\par
}
{\xe \v port\:MQTT}
{\xe \v MQTT\:port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint16_t MQTT::port{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 143 of file MQTT.h.}\par
{
Referenced by initialize(), and setBroker().}\par
}
{\xe \v qoscallback\:MQTT}
{\xe \v MQTT\:qoscallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void(* MQTT::qoscallback) (unsigned int){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 136 of file MQTT.h.}\par
{
Referenced by addQosCallback(), initialize(), and loop().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/MQTT/src/{\b MQTT.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/MQTT/src/{\b MQTT.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Print Class Reference\par \pard\plain 
{\tc\tcl2 \v Print}
{\xe \v Print}
{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for printing to a stream or file. }}\par
{
{\f2 #include <spark_wiring_print.h>}}\par
Inheritance diagram for Print:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_print__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Print} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Print} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getWriteError} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clearWriteError} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual size_t {\b write} (uint8_t)=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b write} (const char *str)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual size_t {\b write} (const uint8_t *buffer, size_t size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b print} (const char[])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b print} (char)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b print} (unsigned char, int={\b DEC})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b print} (int, int={\b DEC})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b print} (unsigned int, int={\b DEC})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b print} (long, int={\b DEC})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b print} (unsigned long, int={\b DEC})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b print} (double, int=2)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b print} (const {\b Printable} &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b println} (const char[])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b println} (char)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b println} (unsigned char, int={\b DEC})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b println} (int, int={\b DEC})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b println} (unsigned int, int={\b DEC})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b println} (long, int={\b DEC})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b println} (unsigned long, int={\b DEC})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b println} (double, int=2)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b println} (const {\b Printable} &)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b println} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename... Args> size_t {\b printf} (const char *format, Args... args)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename... Args> size_t {\b printlnf} (const char *format, Args... args)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Print} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~Print} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getWriteError} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the last error code. 0 means no error. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clearWriteError} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear the last error code to 0. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual size_t {\b write} (uint8_t c)=0\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write a single byte to the stream or file. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b write} (const char *str)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write a null-terminated c-string the stream or file. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual size_t {\b write} (const uint8_t *buffer, size_t size)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write a bytes specified by a buffer and length to the stream or file. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b print} (const char[])\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} a null-terminated array of char variables (a c-string) to the stream or file. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b print} (char)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} a single character to the stream or file. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b print} (unsigned char value, int base={\b DEC})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} an unsigned char (byte value, 8 bits) in the specified base to the stream or file. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b print} (int value, int base={\b DEC})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} an int (32 bit integer) the specified base to the stream or file. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b print} (unsigned int value, int base={\b DEC})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} an unsigned int (32 bit unsigned integer) the specified base to the stream or file. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b print} (long value, int base={\b DEC})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} a long (32 bit integer) the specified base to the stream or file. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b print} (unsigned long value, int base={\b DEC})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} a unsigned long (32 bit unsigned integer) the specified base to the stream or file. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b print} (double value, int dec=2)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} a double floating point value to the stream or file. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b print} (const {\b Printable} &)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} an object derived from {\b Printable} to the stream or file. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b print} (const __FlashStringHelper *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b println} (const char[])\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} a null-terminated array of char variables (a c-string) plus a CRLF end-of-line terminator to the stream or file. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b println} (char value)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} a single character plus a CRLF end-of-line terminator to the stream or file. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b println} (unsigned char value, int base={\b DEC})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} an unsigned char (byte value. 8 bits) in the specified base plus a CRLF end-of-line terminator to the stream or file. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b println} (int value, int base={\b DEC})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} an int (32 bit integer) the specified base to plus a CRLF end-of-line terminator the stream or file. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b println} (unsigned int value, int base={\b DEC})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} an unsigned int (32 bit unsigned integer) the specified base plus a CRLF end-of-line terminator to the stream or file. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b println} (long value, int base={\b DEC})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} a long (32 bit signed integer) the specified base plus a CRLF end-of-line terminator to the stream or file. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b println} (unsigned long value, int base={\b DEC})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} a unsigned long (32 bit unsigned integer) the specified base plus a CRLF end-of-line terminator to the stream or file. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b println} (double value, int dec=2)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} a double floating point value plus a CRLF end-of-line terminator to the stream or file. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b println} (const {\b Printable} &)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} an object derived from {\b Printable} plus a CRLF end-of-line terminator to the stream or file. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b println} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} a CRLF end-of-line terminator to the stream or file. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b println} (const __FlashStringHelper *)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename... Args> size_t {\b printf} (const char *format, Args... args)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} using printf-style formatting to the stream or file. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename... Args> size_t {\b printlnf} (const char *format, Args... args)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} using printf-style formatting plus a CRLF end-of-line terminator to the stream or file. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setWriteError} (int err=1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b printf_impl} (bool newline, const char *format,...)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setWriteError} (int err=1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b printf_impl} (bool newline, const char *format,...)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b printNumber} (unsigned long, uint8_t)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b printFloat} (double, uint8_t)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b printNumber} (unsigned long, uint8_t)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b printFloat} (double, uint8_t)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b write_error}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for printing to a stream or file. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Various classes include serial, TCP network streams, and files inherit from this and can use these methods. \par
}{
Definition at line 44 of file spark_wiring_print.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Print\:Print}
{\xe \v Print\:Print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Print::Print (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file spark_wiring_print.h.}\par
{
References write_error.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    55 : write_error(0) \{\}\par
}
}
{\xe \v ~Print\:Print}
{\xe \v Print\:~Print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual Print::~Print (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 56 of file spark_wiring_print.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    56 \{\}\par
}
}
{\xe \v Print\:Print}
{\xe \v Print\:Print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Print::Print (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 64 of file spark_wiring_print.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    64 : write_error(0) \{\}\par
}
}
{\xe \v ~Print\:Print}
{\xe \v Print\:~Print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual Print::~Print (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 66 of file spark_wiring_print.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    66 \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v clearWriteError\:Print}
{\xe \v Print\:clearWriteError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Print::clearWriteError (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 59 of file spark_wiring_print.h.}\par
{
References setWriteError().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    59 \{ setWriteError(0); \}\par
}
}
{\xe \v clearWriteError\:Print}
{\xe \v Print\:clearWriteError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Print::clearWriteError (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clear the last error code to 0. }}\par
{
Definition at line 76 of file spark_wiring_print.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    76 \{ setWriteError(0); \}\par
}
}
{\xe \v getWriteError\:Print}
{\xe \v Print\:getWriteError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Print::getWriteError (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 58 of file spark_wiring_print.h.}\par
{
References write_error.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    58 \{ return write_error; \}\par
}
}
{\xe \v getWriteError\:Print}
{\xe \v Print\:getWriteError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Print::getWriteError (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the last error code. 0 means no error. }}\par
{
Definition at line 71 of file spark_wiring_print.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    71 \{ return write_error; \}\par
}
}
{\xe \v print\:Print}
{\xe \v Print\:print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::print (const char  {\i str}[])}}
\par
{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 53 of file spark_wiring_print.cpp.}\par
{
References write().}\par
{
Referenced by printf_impl(), printFloat(), and println().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    54 \{\par
   55   return write(str);\par
   56 \}\par
}
}
{\xe \v print\:Print}
{\xe \v Print\:print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::print (char  {\i c})}}
\par
{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 58 of file spark_wiring_print.cpp.}\par
{
References write().}\par
{
Referenced by print(), printFloat(), and println().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    59 \{\par
   60   return write(c);\par
   61 \}\par
}
}
{\xe \v print\:Print}
{\xe \v Print\:print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::print (unsigned char  {\i b}, int  {\i base} = {\f2 {\b DEC}})}}
\par
{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 63 of file spark_wiring_print.cpp.}\par
{
References print().}\par
{
Referenced by println().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    64 \{\par
   65   return print((unsigned long) b, base);\par
   66 \}\par
}
}
{\xe \v print\:Print}
{\xe \v Print\:print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::print (int  {\i n}, int  {\i base} = {\f2 {\b DEC}})}}
\par
{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 68 of file spark_wiring_print.cpp.}\par
{
References print().}\par
{
Referenced by printFloat(), and println().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    69 \{\par
   70   return print((long) n, base);\par
   71 \}\par
}
}
{\xe \v print\:Print}
{\xe \v Print\:print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::print (unsigned int  {\i n}, int  {\i base} = {\f2 {\b DEC}})}}
\par
{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 73 of file spark_wiring_print.cpp.}\par
{
References print().}\par
{
Referenced by println().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    74 \{\par
   75   return print((unsigned long) n, base);\par
   76 \}\par
}
}
{\xe \v print\:Print}
{\xe \v Print\:print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::print (long  {\i n}, int  {\i base} = {\f2 {\b DEC}})}}
\par
{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 78 of file spark_wiring_print.cpp.}\par
{
References print(), printNumber(), and write().}\par
{
Referenced by print(), and println().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    79 \{\par
   80   if (base == 0) \{\par
   81     return write(n);\par
   82   \} else if (base == 10) \{\par
   83     if (n < 0) \{\par
   84       int t = print('-');\par
   85       n = -n;\par
   86       return printNumber(n, 10) + t;\par
   87     \}\par
   88     return printNumber(n, 10);\par
   89   \} else \{\par
   90     return printNumber(n, base);\par
   91   \}\par
   92 \}\par
}
}
{\xe \v print\:Print}
{\xe \v Print\:print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::print (unsigned long  {\i n}, int  {\i base} = {\f2 {\b DEC}})}}
\par
{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 94 of file spark_wiring_print.cpp.}\par
{
References printNumber(), and write().}\par
{
Referenced by print(), printFloat(), and println().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    95 \{\par
   96   if (base == 0) return write(n);\par
   97   else return printNumber(n, base);\par
   98 \}\par
}
}
{\xe \v print\:Print}
{\xe \v Print\:print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::print (double  {\i n}, int  {\i digits} = {\f2 2})}}
\par
{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 100 of file spark_wiring_print.cpp.}\par
{
References printFloat().}\par
{
Referenced by println().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   101 \{\par
  102   return printFloat(n, digits);\par
  103 \}\par
}
}
{\xe \v print\:Print}
{\xe \v Print\:print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::print (const {\b Printable} &  {\i x})}}
\par
{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 105 of file spark_wiring_print.cpp.}\par
{
References Printable::printTo().}\par
{
Referenced by println().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   106  \{\par
  107    return x.printTo(*this);\par
  108  \}\par
}
}
{\xe \v print\:Print}
{\xe \v Print\:print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::print (const char [])}}
\par
{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} a null-terminated array of char variables (a c-string) to the stream or file. }}\par
}
{\xe \v print\:Print}
{\xe \v Print\:print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::print (char )}}
\par
{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} a single character to the stream or file. }}\par
}
{\xe \v print\:Print}
{\xe \v Print\:print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::print (unsigned char  {\i value}, int  {\i base} = {\f2 {\b DEC}})}}
\par
{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} an unsigned char (byte value, 8 bits) in the specified base to the stream or file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{The value to print. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i base} \cell }{The base to print. Default is DEC (decimal). Other values are HEX (hexadecimal), OCT (octal), and BIN (binary). \cell }
{\row }
}
}}
{\xe \v print\:Print}
{\xe \v Print\:print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::print (int  {\i value}, int  {\i base} = {\f2 {\b DEC}})}}
\par
{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} an int (32 bit integer) the specified base to the stream or file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{The value to print. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i base} \cell }{The base to print. Default is DEC (decimal). Other values are HEX (hexadecimal), OCT (octal), and BIN (binary). \cell }
{\row }
}
}}
{\xe \v print\:Print}
{\xe \v Print\:print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::print (unsigned int  {\i value}, int  {\i base} = {\f2 {\b DEC}})}}
\par
{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} an unsigned int (32 bit unsigned integer) the specified base to the stream or file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{The value to print. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i base} \cell }{The base to print. Default is DEC (decimal). Other values are HEX (hexadecimal), OCT (octal), and BIN (binary). \cell }
{\row }
}
}}
{\xe \v print\:Print}
{\xe \v Print\:print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::print (long  {\i value}, int  {\i base} = {\f2 {\b DEC}})}}
\par
{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} a long (32 bit integer) the specified base to the stream or file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{The value to print. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i base} \cell }{The base to print. Default is DEC (decimal). Other values are HEX (hexadecimal), OCT (octal), and BIN (binary). \cell }
{\row }
}
}}
{\xe \v print\:Print}
{\xe \v Print\:print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::print (unsigned long  {\i value}, int  {\i base} = {\f2 {\b DEC}})}}
\par
{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} a unsigned long (32 bit unsigned integer) the specified base to the stream or file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{The value to print. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i base} \cell }{The base to print. Default is DEC (decimal). Other values are HEX (hexadecimal), OCT (octal), and BIN (binary). \cell }
{\row }
}
}}
{\xe \v print\:Print}
{\xe \v Print\:print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::print (double  {\i value}, int  {\i dec} = {\f2 2})}}
\par
{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} a double floating point value to the stream or file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{The value to print. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dec} \cell }{The number of decimal places to include for the fractional part. Default: 2 \cell }
{\row }
}
}}
{\xe \v print\:Print}
{\xe \v Print\:print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::print (const {\b Printable} & )}}
\par
{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} an object derived from {\b Printable} to the stream or file. }}\par
}
{\xe \v print\:Print}
{\xe \v Print\:print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::print (const __FlashStringHelper * )}}
\par
{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v printf\:Print}
{\xe \v Print\:printf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename... Args> size_t Print::printf (const char *  {\i format}, Args...  {\i args}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 90 of file spark_wiring_print.h.}\par
{
References printf_impl().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    91     \{\par
   92         return this->printf_impl(false, format, args...);\par
   93     \}\par
}
}
{\xe \v printf\:Print}
{\xe \v Print\:printf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename... Args> size_t Print::printf (const char *  {\i format}, Args...  {\i args}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} using printf-style formatting to the stream or file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i format} \cell }{printf-style formatting string\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i args} \cell }{variable arguments \cell }
{\row }
}
}{
Definition at line 256 of file spark_wiring_print.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   257     \{\par
  258         return this->printf_impl(false, format, args...);\par
  259     \}\par
}
}
{\xe \v printf_impl\:Print}
{\xe \v Print\:printf_impl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::printf_impl (bool  {\i newline}, const char *  {\i format},   {\i ...}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 246 of file spark_wiring_print.cpp.}\par
{
References print(), and println().}\par
{
Referenced by printf(), and printlnf().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   247 \{\par
  248     const int bufsize = 20;\par
  249     char test[bufsize];\par
  250     va_list marker;\par
  251     va_start(marker, format);\par
  252     size_t n = vsnprintf(test, bufsize, format, marker);\par
  253     va_end(marker);\par
  254 \par
  255     if (n<bufsize)\par
  256     \{\par
  257         n = print(test);\par
  258     \}\par
  259     else\par
  260     \{\par
  261         char bigger[n+1];\par
  262         va_start(marker, format);\par
  263         n = vsnprintf(bigger, n+1, format, marker);\par
  264         va_end(marker);\par
  265         n = print(bigger);\par
  266     \}\par
  267     if (newline)\par
  268         n += println();\par
  269     return n;\par
  270 \}\par
}
}
{\xe \v printf_impl\:Print}
{\xe \v Print\:printf_impl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::printf_impl (bool  {\i newline}, const char *  {\i format},   {\i ...}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v printFloat\:Print}
{\xe \v Print\:printFloat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::printFloat (double  {\i number}, uint8_t  {\i digits}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 201 of file spark_wiring_print.cpp.}\par
{
References print().}\par
{
Referenced by print().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   202 \{\par
  203   size_t n = 0;\par
  204 \par
  205   if (isnan(number)) return print("nan");\par
  206   if (isinf(number)) return print("inf");\par
  207   if (number > 4294967040.0) return print ("ovf");  // constant determined empirically\par
  208   if (number <-4294967040.0) return print ("ovf");  // constant determined empirically\par
  209 \par
  210   // Handle negative numbers\par
  211   if (number < 0.0)\par
  212   \{\par
  213      n += print('-');\par
  214      number = -number;\par
  215   \}\par
  216 \par
  217   // Round correctly so that print(1.999, 2) prints as "2.00"\par
  218   double rounding = 0.5;\par
  219   for (uint8_t i=0; i<digits; ++i)\par
  220     rounding /= 10.0;\par
  221 \par
  222   number += rounding;\par
  223 \par
  224   // Extract the integer part of the number and print it\par
  225   unsigned long int_part = (unsigned long)number;\par
  226   double remainder = number - (double)int_part;\par
  227   n += print(int_part);\par
  228 \par
  229   // Print the decimal point, but only if there are digits beyond\par
  230   if (digits > 0) \{\par
  231     n += print(".");\par
  232   \}\par
  233 \par
  234   // Extract digits from the remainder one at a time\par
  235   while (digits-- > 0)\par
  236   \{\par
  237     remainder *= 10.0;\par
  238     int toPrint = int(remainder);\par
  239     n += print(toPrint);\par
  240     remainder -= toPrint;\par
  241   \}\par
  242 \par
  243   return n;\par
  244 \}\par
}
}
{\xe \v printFloat\:Print}
{\xe \v Print\:printFloat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::printFloat (double , uint8_t ){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v println\:Print}
{\xe \v Print\:println}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::println (const char  {\i c}[])}}
\par
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 117 of file spark_wiring_print.cpp.}\par
{
References print(), and println().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   118 \{\par
  119   size_t n = print(c);\par
  120   n += println();\par
  121   return n;\par
  122 \}\par
}
}
{\xe \v println\:Print}
{\xe \v Print\:println}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::println (char  {\i c})}}
\par
{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 124 of file spark_wiring_print.cpp.}\par
{
References print(), and println().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   125 \{\par
  126   size_t n = print(c);\par
  127   n += println();\par
  128   return n;\par
  129 \}\par
}
}
{\xe \v println\:Print}
{\xe \v Print\:println}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::println (unsigned char  {\i b}, int  {\i base} = {\f2 {\b DEC}})}}
\par
{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 131 of file spark_wiring_print.cpp.}\par
{
References print(), and println().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   132 \{\par
  133   size_t n = print(b, base);\par
  134   n += println();\par
  135   return n;\par
  136 \}\par
}
}
{\xe \v println\:Print}
{\xe \v Print\:println}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::println (int  {\i num}, int  {\i base} = {\f2 {\b DEC}})}}
\par
{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 138 of file spark_wiring_print.cpp.}\par
{
References print(), and println().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   139 \{\par
  140   size_t n = print(num, base);\par
  141   n += println();\par
  142   return n;\par
  143 \}\par
}
}
{\xe \v println\:Print}
{\xe \v Print\:println}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::println (unsigned int  {\i num}, int  {\i base} = {\f2 {\b DEC}})}}
\par
{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 145 of file spark_wiring_print.cpp.}\par
{
References print(), and println().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   146 \{\par
  147   size_t n = print(num, base);\par
  148   n += println();\par
  149   return n;\par
  150 \}\par
}
}
{\xe \v println\:Print}
{\xe \v Print\:println}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::println (long  {\i num}, int  {\i base} = {\f2 {\b DEC}})}}
\par
{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 152 of file spark_wiring_print.cpp.}\par
{
References print(), and println().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   153 \{\par
  154   size_t n = print(num, base);\par
  155   n += println();\par
  156   return n;\par
  157 \}\par
}
}
{\xe \v println\:Print}
{\xe \v Print\:println}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::println (unsigned long  {\i num}, int  {\i base} = {\f2 {\b DEC}})}}
\par
{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 159 of file spark_wiring_print.cpp.}\par
{
References print(), and println().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   160 \{\par
  161   size_t n = print(num, base);\par
  162   n += println();\par
  163   return n;\par
  164 \}\par
}
}
{\xe \v println\:Print}
{\xe \v Print\:println}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::println (double  {\i num}, int  {\i digits} = {\f2 2})}}
\par
{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 166 of file spark_wiring_print.cpp.}\par
{
References print(), and println().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   167 \{\par
  168   size_t n = print(num, digits);\par
  169   n += println();\par
  170   return n;\par
  171 \}\par
}
}
{\xe \v println\:Print}
{\xe \v Print\:println}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::println (const {\b Printable} &  {\i x})}}
\par
{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 173 of file spark_wiring_print.cpp.}\par
{
References print(), and println().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   174  \{\par
  175    size_t n = print(x);\par
  176    n += println();\par
  177    return n;\par
  178  \}\par
}
}
{\xe \v println\:Print}
{\xe \v Print\:println}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::println (void )}}
\par
{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 110 of file spark_wiring_print.cpp.}\par
{
References print().}\par
{
Referenced by printf_impl(), and println().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   111 \{\par
  112   size_t n = print('\\r');\par
  113   n += print('\\n');\par
  114   return n;\par
  115 \}\par
}
}
{\xe \v println\:Print}
{\xe \v Print\:println}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::println (const char [])}}
\par
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} a null-terminated array of char variables (a c-string) plus a CRLF end-of-line terminator to the stream or file. }}\par
}
{\xe \v println\:Print}
{\xe \v Print\:println}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::println (char  {\i value})}}
\par
{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} a single character plus a CRLF end-of-line terminator to the stream or file. }}\par
}
{\xe \v println\:Print}
{\xe \v Print\:println}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::println (unsigned char  {\i value}, int  {\i base} = {\f2 {\b DEC}})}}
\par
{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} an unsigned char (byte value. 8 bits) in the specified base plus a CRLF end-of-line terminator to the stream or file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{The value to print. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i base} \cell }{The base to print. Default is DEC (decimal). Other values are HEX (hexadecimal), OCT (octal), and BIN (binary). \cell }
{\row }
}
}}
{\xe \v println\:Print}
{\xe \v Print\:println}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::println (int  {\i value}, int  {\i base} = {\f2 {\b DEC}})}}
\par
{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} an int (32 bit integer) the specified base to plus a CRLF end-of-line terminator the stream or file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{The value to print \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i base} \cell }{The base to print. Default is DEC (decimal). Other values are HEX (hexadecimal), OCT (octal), and BIN (binary). \cell }
{\row }
}
}}
{\xe \v println\:Print}
{\xe \v Print\:println}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::println (unsigned int  {\i value}, int  {\i base} = {\f2 {\b DEC}})}}
\par
{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} an unsigned int (32 bit unsigned integer) the specified base plus a CRLF end-of-line terminator to the stream or file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{The value to print \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i base} \cell }{The base to print. Default is DEC (decimal). Other values are HEX (hexadecimal), OCT (octal), and BIN (binary). \cell }
{\row }
}
}}
{\xe \v println\:Print}
{\xe \v Print\:println}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::println (long  {\i value}, int  {\i base} = {\f2 {\b DEC}})}}
\par
{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} a long (32 bit signed integer) the specified base plus a CRLF end-of-line terminator to the stream or file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{The value to print \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i base} \cell }{The base to print. Default is DEC (decimal). Other values are HEX (hexadecimal), OCT (octal), and BIN (binary). \cell }
{\row }
}
}}
{\xe \v println\:Print}
{\xe \v Print\:println}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::println (unsigned long  {\i value}, int  {\i base} = {\f2 {\b DEC}})}}
\par
{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} a unsigned long (32 bit unsigned integer) the specified base plus a CRLF end-of-line terminator to the stream or file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{The value to print. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i base} \cell }{The base to print. Default is DEC (decimal). Other values are HEX (hexadecimal), OCT (octal), and BIN (binary). \cell }
{\row }
}
}}
{\xe \v println\:Print}
{\xe \v Print\:println}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::println (double  {\i value}, int  {\i dec} = {\f2 2})}}
\par
{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} a double floating point value plus a CRLF end-of-line terminator to the stream or file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{The value to print. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dec} \cell }{The number of decimal places to include for the fractional part. Default: 2 \cell }
{\row }
}
}}
{\xe \v println\:Print}
{\xe \v Print\:println}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::println (const {\b Printable} & )}}
\par
{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} an object derived from {\b Printable} plus a CRLF end-of-line terminator to the stream or file. }}\par
}
{\xe \v println\:Print}
{\xe \v Print\:println}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::println (void )}}
\par
{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} a CRLF end-of-line terminator to the stream or file. }}\par
}
{\xe \v println\:Print}
{\xe \v Print\:println}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::println (const __FlashStringHelper * )}}
\par
{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v printlnf\:Print}
{\xe \v Print\:printlnf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename... Args> size_t Print::printlnf (const char *  {\i format}, Args...  {\i args}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 96 of file spark_wiring_print.h.}\par
{
References printf_impl().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    97     \{\par
   98         return this->printf_impl(true, format, args...);\par
   99     \}\par
}
}
{\xe \v printlnf\:Print}
{\xe \v Print\:printlnf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename... Args> size_t Print::printlnf (const char *  {\i format}, Args...  {\i args}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} using printf-style formatting plus a CRLF end-of-line terminator to the stream or file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i format} \cell }{printf-style formatting string\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i args} \cell }{variable arguments \cell }
{\row }
}
}{
Definition at line 269 of file spark_wiring_print.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   270     \{\par
  271         return this->printf_impl(true, format, args...);\par
  272     \}\par
}
}
{\xe \v printNumber\:Print}
{\xe \v Print\:printNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::printNumber (unsigned long  {\i n}, uint8_t  {\i base}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 182 of file spark_wiring_print.cpp.}\par
{
References write().}\par
{
Referenced by print().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   182                                                        \{\par
  183   char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.\par
  184   char *str = &buf[sizeof(buf) - 1];\par
  185 \par
  186   *str = '\\0';\par
  187 \par
  188   // prevent crash if called with base == 1\par
  189   if (base < 2) base = 10;\par
  190 \par
  191   do \{\par
  192     unsigned long m = n;\par
  193     n /= base;\par
  194     char c = m - base * n;\par
  195     *--str = c < 10 ? c + '0' : c + 'A' - 10;\par
  196   \} while(n);\par
  197 \par
  198   return write(str);\par
  199 \}\par
}
}
{\xe \v printNumber\:Print}
{\xe \v Print\:printNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::printNumber (unsigned  {\i long}, uint8_t ){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v setWriteError\:Print}
{\xe \v Print\:setWriteError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Print::setWriteError (int  {\i err} = {\f2 1}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 51 of file spark_wiring_print.h.}\par
{
References write_error.}\par
{
Referenced by clearWriteError().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    51 \{ write_error = err; \}\par
}
}
{\xe \v setWriteError\:Print}
{\xe \v Print\:setWriteError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Print::setWriteError (int  {\i err} = {\f2 1}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 58 of file spark_wiring_print.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    58 \{ write_error = err; \}\par
}
}
{\xe \v write\:Print}
{\xe \v Print\:write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual size_t Print::write (uint8_t ){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b StringPrintableHelper} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Referenced by print(), and write().}\par
}
{\xe \v write\:Print}
{\xe \v Print\:write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::write (const char *  {\i str}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 62 of file spark_wiring_print.h.}\par
{
References write().}\par
{
Referenced by print(), and printNumber().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    62                                   \{\par
   63       if (str == NULL) return 0;\par
   64       return write((const uint8_t *)str, strlen(str));\par
   65     \}\par
}
}
{\xe \v write\:Print}
{\xe \v Print\:write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::write (const uint8_t *  {\i buffer}, size_t  {\i size}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b StringPrintableHelper} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 37 of file spark_wiring_print.cpp.}\par
{
References write().}\par
{
Referenced by write().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    38 \{\par
   39   size_t n = 0;\par
   40   while (size--) \{\par
   41      int chunk = write(*buffer++);\par
   42      if (chunk>=0)\par
   43          n += chunk;\par
   44      else \{\par
   45          if (n==0)\par
   46              n = chunk;\par
   47          break;\par
   48      \}\par
   49   \}\par
   50   return n;\par
   51 \}\par
}
}
{\xe \v write\:Print}
{\xe \v Print\:write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual size_t Print::write (uint8_t  {\i c}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write a single byte to the stream or file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i c} \cell }{The byte to write. All values 0 - 255 are allowed. \cell }
{\row }
}
}{
Implemented in {\b StringPrintableHelper} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v write\:Print}
{\xe \v Print\:write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Print::write (const char *  {\i str}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write a null-terminated c-string the stream or file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{point to a null-terminated c-string. \cell }
{\row }
}
}{
Definition at line 90 of file spark_wiring_print.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    90                                   \{\par
   91       if (str == NULL) return 0;\par
   92       return write((const uint8_t *)str, strlen(str));\par
   93     \}\par
}
}
{\xe \v write\:Print}
{\xe \v Print\:write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual size_t Print::write (const uint8_t *  {\i buffer}, size_t  {\i size}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZT}
{\bkmkend AAAAAAAAZT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write a bytes specified by a buffer and length to the stream or file. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buffer} \cell }{pointer to the buffer. The data does not need to be null-terminated. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{size in bytes \cell }
{\row }
}
}{
Reimplemented in {\b StringPrintableHelper} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v write_error\:Print}
{\xe \v Print\:write_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Print::write_error{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAZU}
{\bkmkend AAAAAAAAZU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file spark_wiring_print.h.}\par
{
Referenced by getWriteError(), Print(), and setWriteError().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/test/gcclib/{\b spark_wiring_print.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/test/gcclib/{\b spark_wiring_print.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Printable Class Reference\par \pard\plain 
{\tc\tcl2 \v Printable}
{\xe \v Printable}
{\bkmkstart AAAAAAAAZV}
{\bkmkend AAAAAAAAZV}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Printable} class provides a way for new classes to allow themselves to be printed. }}\par
{
{\f2 #include <spark_wiring_printable.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual size_t {\b printTo} ({\b Print} &p) const =0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual size_t {\b printTo} ({\b Print} &p) const =0\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} a textual representation of the class to a {\b Print} object. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Printable} class provides a way for new classes to allow themselves to be printed. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Printable} class provides a way for new classes to allow themselves to be printed. By deriving from {\b Printable} and implementing the printTo method, it will then be possible for users to print out instances of this class by passing them into the usual {\b Print::print} and {\b Print::println} methods.\par
By deriving from {\b Printable} and implementing the printTo method, it will then be possible for users to print out instances of this class by passing them into the usual {\b Print::print} and {\b Print::println} methods. \par
}{
Definition at line 40 of file spark_wiring_printable.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v printTo\:Printable}
{\xe \v Printable\:printTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual size_t Printable::printTo ({\b Print} &  {\i p}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v printTo\:Printable}
{\xe \v Printable\:printTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual size_t Printable::printTo ({\b Print} &  {\i p}) const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Print} a textual representation of the class to a {\b Print} object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i p} \cell }{The {\b Print} object to print to \cell }
{\row }
}
}{
Referenced by Print::print(), and String::String().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/test/gcclib/{\b spark_wiring_printable.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Stream Class Reference\par \pard\plain 
{\tc\tcl2 \v Stream}
{\xe \v Stream}
{\bkmkstart AAAAAAAAZX}
{\bkmkend AAAAAAAAZX}
\par
{
{\f2 #include <Particle.h>}}\par
Inheritance diagram for Stream:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_stream__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for Stream:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_stream__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b available} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b read} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b available} ()=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b read} ()=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b peek} ()=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b flush} ()=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Stream} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTimeout} ({\b system_tick_t} timeout)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b find} (char *target)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b find} (char *target, size_t length)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b findUntil} (char *target, char *terminator)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b findUntil} (char *target, size_t targetLen, char *terminate, size_t termLen)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
long {\b parseInt} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b parseFloat} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b readBytes} (char *buffer, size_t length)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b readBytesUntil} (char terminator, char *buffer, size_t length)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} {\b readString} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} {\b readStringUntil} (char terminator)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b timedRead} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b timedPeek} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b peekNextDigit} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
long {\b parseInt} (char skipChar)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b parseFloat} (char skipChar)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b system_tick_t} {\b _timeout}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b system_tick_t} {\b _startMillis}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 15 of file Particle.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Stream\:Stream}
{\xe \v Stream\:Stream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Stream::Stream (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZY}
{\bkmkend AAAAAAAAZY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 59 of file spark_wiring_stream.h.}\par
{
References _timeout.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    59 \{_timeout=1000;\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v available\:Stream}
{\xe \v Stream\:available}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Stream::available (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZZ}
{\bkmkend AAAAAAAAZZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file Particle.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    17 \{ return 0; \}\par
}
}
{\xe \v available\:Stream}
{\xe \v Stream\:available}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual int Stream::available (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABAA}
{\bkmkend AAAAAAABAA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v find\:Stream}
{\xe \v Stream\:find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Stream::find (char *  {\i target})}}
\par
{\bkmkstart AAAAAAABAB}
{\bkmkend AAAAAAABAB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v find\:Stream}
{\xe \v Stream\:find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Stream::find (char *  {\i target}, size_t  {\i length})}}
\par
{\bkmkstart AAAAAAABAC}
{\bkmkend AAAAAAABAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v findUntil\:Stream}
{\xe \v Stream\:findUntil}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Stream::findUntil (char *  {\i target}, char *  {\i terminator})}}
\par
{\bkmkstart AAAAAAABAD}
{\bkmkend AAAAAAABAD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v findUntil\:Stream}
{\xe \v Stream\:findUntil}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Stream::findUntil (char *  {\i target}, size_t  {\i targetLen}, char *  {\i terminate}, size_t  {\i termLen})}}
\par
{\bkmkstart AAAAAAABAE}
{\bkmkend AAAAAAABAE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v flush\:Stream}
{\xe \v Stream\:flush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void Stream::flush (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABAF}
{\bkmkend AAAAAAABAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parseFloat\:Stream}
{\xe \v Stream\:parseFloat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Stream::parseFloat ()}}
\par
{\bkmkstart AAAAAAABAG}
{\bkmkend AAAAAAABAG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parseFloat\:Stream}
{\xe \v Stream\:parseFloat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Stream::parseFloat (char  {\i skipChar}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABAH}
{\bkmkend AAAAAAABAH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parseInt\:Stream}
{\xe \v Stream\:parseInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
long Stream::parseInt ()}}
\par
{\bkmkstart AAAAAAABAI}
{\bkmkend AAAAAAABAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parseInt\:Stream}
{\xe \v Stream\:parseInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
long Stream::parseInt (char  {\i skipChar}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABAJ}
{\bkmkend AAAAAAABAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v peek\:Stream}
{\xe \v Stream\:peek}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual int Stream::peek (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABAK}
{\bkmkend AAAAAAABAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v peekNextDigit\:Stream}
{\xe \v Stream\:peekNextDigit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Stream::peekNextDigit (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABAL}
{\bkmkend AAAAAAABAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v read\:Stream}
{\xe \v Stream\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Stream::read (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAM}
{\bkmkend AAAAAAABAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file Particle.h.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    18 \{ return 0; \}\par
}
}
{\xe \v read\:Stream}
{\xe \v Stream\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual int Stream::read (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABAN}
{\bkmkend AAAAAAABAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v readBytes\:Stream}
{\xe \v Stream\:readBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Stream::readBytes (char *  {\i buffer}, size_t  {\i length})}}
\par
{\bkmkstart AAAAAAABAO}
{\bkmkend AAAAAAABAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v readBytesUntil\:Stream}
{\xe \v Stream\:readBytesUntil}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t Stream::readBytesUntil (char  {\i terminator}, char *  {\i buffer}, size_t  {\i length})}}
\par
{\bkmkstart AAAAAAABAP}
{\bkmkend AAAAAAABAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v readString\:Stream}
{\xe \v Stream\:readString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String} Stream::readString ()}}
\par
{\bkmkstart AAAAAAABAQ}
{\bkmkend AAAAAAABAQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v readStringUntil\:Stream}
{\xe \v Stream\:readStringUntil}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String} Stream::readStringUntil (char  {\i terminator})}}
\par
{\bkmkstart AAAAAAABAR}
{\bkmkend AAAAAAABAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v setTimeout\:Stream}
{\xe \v Stream\:setTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Stream::setTimeout ({\b system_tick_t}  {\i timeout})}}
\par
{\bkmkstart AAAAAAABAS}
{\bkmkend AAAAAAABAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v timedPeek\:Stream}
{\xe \v Stream\:timedPeek}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Stream::timedPeek (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABAT}
{\bkmkend AAAAAAABAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v timedRead\:Stream}
{\xe \v Stream\:timedRead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Stream::timedRead (){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABAU}
{\bkmkend AAAAAAABAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v _startMillis\:Stream}
{\xe \v Stream\:_startMillis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b system_tick_t} Stream::_startMillis{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABAV}
{\bkmkend AAAAAAABAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 48 of file spark_wiring_stream.h.}\par
}
{\xe \v _timeout\:Stream}
{\xe \v Stream\:_timeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b system_tick_t} Stream::_timeout{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABAW}
{\bkmkend AAAAAAABAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file spark_wiring_stream.h.}\par
{
Referenced by Stream().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/test/gcclib/{\b Particle.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/test/gcclib/{\b spark_wiring_stream.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
String Class Reference\par \pard\plain 
{\tc\tcl2 \v String}
{\xe \v String}
{\bkmkstart AAAAAAABAX}
{\bkmkend AAAAAAABAX}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wiring {\b String}: A class to hold and manipulate a dynamically allocated string. }}\par
{
{\f2 #include <spark_wiring_string.h>}}\par
Inheritance diagram for String:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_string__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} (const char *cstr="")\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b String} object from a c-string (null-terminated) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} (const char *cstr, unsigned int {\b length})\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b String} object from a pointer and length. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} (const {\b String} &str)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b String} object as a copy of another string. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} (const __FlashStringHelper *pstr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} (const {\b Printable} &printable)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b String} object from any {\b Printable} object. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} (char c)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b String} containing a single character. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} (unsigned char b, unsigned char base=10)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b String} from a unsigned char (uint8_t) value, expressed as a number. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} (int value, unsigned char base=10)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b String} from a int (32 bit signed integer) value, expressed as a number. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} (unsigned int value, unsigned char base=10)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b String} from a unsigned int (32 bit unsigned integer) value, expressed as a number. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} (long value, unsigned char base=10)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b String} from a long (32 bit signed integer) value, expressed as a number. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} (unsigned long value, unsigned char base=10)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b String} from a unsigned long (32 bit unsigned integer) value, expressed as a number. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} (float value, int decimalPlaces=6)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b String} from a float (32 bit single precision floating point) value, expressed as a number. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} (double value, int decimalPlaces=6)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b String} from a double (64 bit double precision floating point) value, expressed as a number. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~String} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. Also deletes the underlying dynamically allocated string. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b reserve} (unsigned int size)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reserves a buffer of size. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b length} (void) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the length of the string in bytes. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} & {\b operator=} (const {\b String} &rhs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assigns this string to have a copy of {\b String} rhs. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} & {\b operator=} (const char *cstr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assigns this string to have a copy of c-string (null-terminated) cstr. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} & {\b operator=} (const __FlashStringHelper *pstr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator const char *} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the contents this {\b String} as a c-string (null-terminated) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b concat} (const {\b String} &str)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) a {\b String} object to the end of this {\b String}, modifying this string in place. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b concat} (const char *cstr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) a c-string (null-terminated) to the end of this {\b String}, modifying this string in place. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b concat} (const __FlashStringHelper *str)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b concat} (char c)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) a single character to the end of this {\b String}, modifying this string in place. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b concat} (unsigned char c)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the byte value c to the end of this {\b String} as a decimal number 0 - 255, modifying this string in place. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b concat} (int num)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the integer value num to the end of this {\b String} as a signed decimal number (base 10), modifying this string in place. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b concat} (unsigned int num)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the unsigned integer value num to the end of this {\b String} as a unsigned decimal number (base 10), modifying this string in place. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b concat} (long num)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the long integer value num to the end of this {\b String} as a signed decimal number (base 10), modifying this string in place. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b concat} (unsigned long num)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the unsigned long value num to the end of this {\b String} as a unsigned decimal number (base 10), modifying this string in place. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b concat} (float num)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the float n to the end of this {\b String} as a decimal number (base 10), modifying this string in place. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b concat} (double num)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the double precision float n to the end of this {\b String} as a decimal number (base 10), modifying this string in place. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} & {\b operator+=} (const {\b String} &rhs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Appends (concatenate) a {\b String} object to the end of this {\b String}, modifying this string in place. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} & {\b operator+=} (const char *cstr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Appends (concatenate) a c-string (null-terminated) to the end of this {\b String}, modifying this string in place. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} & {\b operator+=} (char c)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Appends (concatenate) a single character to the end of this {\b String}, modifying this string in place. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} & {\b operator+=} (unsigned char num)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the byte value num to the end of this {\b String} as a decimal number 0 - 255, modifying this string in place. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} & {\b operator+=} (int num)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the integer value num to the end of this {\b String} as a signed decimal number (base 10), modifying this string in place. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} & {\b operator+=} (unsigned int num)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the unsigned integer value num to the end of this {\b String} as a unsigned decimal number (base 10), modifying this string in place. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} & {\b operator+=} (long num)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the long integer value num to the end of this {\b String} as a signed decimal number (base 10), modifying this string in place. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} & {\b operator+=} (unsigned long num)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the unsigned long value num to the end of this {\b String} as a unsigned decimal number (base 10), modifying this string in place. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator StringIfHelperType} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b compareTo} (const {\b String} &s) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compares this string to another string using strcmp (case-sensitive) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b equals} (const {\b String} &s) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string is equal to another string (case-sensitive) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b equals} (const char *cstr) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string equal to another string (case-sensitive) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b operator==} (const {\b String} &rhs) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string is equal to another string (case-sensitive) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b operator==} (const char *cstr) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string equal to another string (case-sensitive) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b operator!=} (const {\b String} &rhs) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string is greater than to another string (case-sensitive) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b operator!=} (const char *cstr) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string not equal to another string (case-sensitive) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b operator<} (const {\b String} &rhs) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string is less than to another string (case-sensitive) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b operator>} (const {\b String} &rhs) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string is greater than to another string (case-sensitive) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b operator<=} (const {\b String} &rhs) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string is less than or equal to another string (case-sensitive) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b operator>=} (const {\b String} &rhs) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string is greater than or equal to another string (case-sensitive) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b equalsIgnoreCase} (const {\b String} &s) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string equals another string (case-insensitive) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b startsWith} (const {\b String} &prefix) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string starts with prefix (case-sensitive) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b startsWith} (const {\b String} &prefix, unsigned int offset) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string contains prefix at specified offset (case-sensitive) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b endsWith} (const {\b String} &suffix) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string ends with suffix (case-sensitive) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b charAt} (unsigned int index) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the character at offset index. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCharAt} (unsigned int index, char c)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the character at offset index. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b operator[]} (unsigned int index) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the character at offset index. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char & {\b operator[]} (unsigned int index)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the character at offset index. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getBytes} (unsigned char *buf, unsigned int bufsize, unsigned int index=0) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy the data out of this {\b String} into another buffer. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b toCharArray} (char *buf, unsigned int bufsize, unsigned int index=0) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy the data out of this {\b String} into another buffer. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b c_str} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a c-string (null-terminated) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b indexOf} (char ch) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Search this string for a given character. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b indexOf} (char ch, unsigned int fromIndex) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Search this string for a given character starting at an offset. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b indexOf} (const {\b String} &str) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Search this string for a given {\b String}. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b indexOf} (const {\b String} &str, unsigned int fromIndex) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Search this string for a given {\b String} starting at an offset. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b lastIndexOf} (char ch) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Search this string for a given character, starting at the end. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b lastIndexOf} (char ch, unsigned int fromIndex) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Search this string for a given character, starting at the fromIndex and going toward the beginning. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b lastIndexOf} (const {\b String} &str) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Search this string for a last occurrence of str. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b lastIndexOf} (const {\b String} &str, unsigned int fromIndex) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Search this string for a last occurrence of str starting at fromIndex. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} {\b substring} (unsigned int beginIndex) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b String} object with a copy of the characters starting at beginIndex through the end of the string. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} {\b substring} (unsigned int beginIndex, unsigned int endIndex) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b String} object with a copy of the characters in the specified range. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} & {\b replace} (char find, char replace)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Replaces every occurrence of a character in the string with another character, modifying it in place. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} & {\b replace} (const {\b String} &find, const {\b String} &replace)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Replaces every occurrence of a {\b String} with another {\b String}, modifying it in place. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} & {\b remove} (unsigned int index)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes characters from the {\b String}, modifying it in place. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} & {\b remove} (unsigned int index, unsigned int count)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes characters from the {\b String}, modifying it in place. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} & {\b toLowerCase} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts this {\b String} to lower case, modifying it in place. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} & {\b toUpperCase} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts this {\b String} to upper case, modifying it in place. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} & {\b trim} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes leading an trailing white spaces from this string, modifying it in place. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
long {\b toInt} (void) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts this string to a signed integer (32-bit) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b toFloat} (void) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts this string to a float (single precision floating point value) }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b String} {\b format} (const char *format,...)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Uses sprintf-style formatting to build a {\b String} object [static]. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b init} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b invalidate} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b changeBuffer} (unsigned int maxStrLen)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b concat} (const char *cstr, unsigned int {\b length})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} & {\b copy} (const char *cstr, unsigned int {\b length})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} & {\b copy} (const __FlashStringHelper *pstr, unsigned int {\b length})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b buffer}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The buffer containing the data. It is always null-terminated. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b capacity}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The capacity of the buffer. The longest string is one byte less than this. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b len}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b String} length (not counting the null terminator). }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b flags}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unused, for future features. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void(String::* {\b StringIfHelperType}) () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b StringIfHelper} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b StringPrintableHelper}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} & {\b operator+} (const {\b StringSumHelper} &lhs, const {\b String} &rhs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) a {\b String} to the end of lhs. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} & {\b operator+} (const {\b StringSumHelper} &lhs, const char *cstr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) a c-string (null-terminated) to the end of lhs. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} & {\b operator+} (const {\b StringSumHelper} &lhs, char c)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the character c the end of lhs a. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} & {\b operator+} (const {\b StringSumHelper} &lhs, unsigned char num)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the unsigned char num to the end of lhs as a decimal number (base 10) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} & {\b operator+} (const {\b StringSumHelper} &lhs, int num)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the signed int num to the end of lhs as a decimal number (base 10) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} & {\b operator+} (const {\b StringSumHelper} &lhs, unsigned int num)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the unsigned int num to the end of lhs as a decimal number (base 10) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} & {\b operator+} (const {\b StringSumHelper} &lhs, long num)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the long integer num to the end of lhs as a decimal number (base 10) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} & {\b operator+} (const {\b StringSumHelper} &lhs, unsigned long num)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the unsigned long integer to the end of lhs as a decimal number (base 10) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} & {\b operator+} (const {\b StringSumHelper} &lhs, float num)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the float num to the end of lhs as a decimal number (base 10) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} & {\b operator+} (const {\b StringSumHelper} &lhs, double num)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the double precision float num to the end of lhs as a decimal number (base 10) }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wiring {\b String}: A class to hold and manipulate a dynamically allocated string. \par
}{
Definition at line 54 of file spark_wiring_string.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v StringIfHelperType\:String}
{\xe \v String\:StringIfHelperType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void(String::* String::StringIfHelperType) () const{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABAY}
{\bkmkend AAAAAAABAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 59 of file spark_wiring_string.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v String\:String}
{\xe \v String\:String}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String::String (const char *  {\i cstr} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAABAZ}
{\bkmkend AAAAAAABAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b String} object from a c-string (null-terminated) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cstr} \cell }{The string to copy, optional. If not specified, starts with an empty string \cell }
{\row }
}
}{
Definition at line 69 of file spark_wiring_string.cpp.}\par
{
References copy(), and init().}\par
{
Referenced by StringSumHelper::StringSumHelper().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    70 \{\par
   71     init();\par
   72     if (cstr) copy(cstr, strlen(cstr));\par
   73 \}\par
}
}
{\xe \v String\:String}
{\xe \v String\:String}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String::String (const char *  {\i cstr}, unsigned int  {\i length})}}
\par
{\bkmkstart AAAAAAABBA}
{\bkmkend AAAAAAABBA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b String} object from a pointer and length. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cstr} \cell }{Pointer to a bytes, typically ASCII or UTF-8. Does not need to be null-terminated.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i length} \cell }{Length in bytes of the string. \cell }
{\row }
}
}}
{\xe \v String\:String}
{\xe \v String\:String}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String::String (const {\b String} &  {\i str})}}
\par
{\bkmkstart AAAAAAABBB}
{\bkmkend AAAAAAABBB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b String} object as a copy of another string. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{The string to copy. Changes made to str in the future won't be reflected in this copy. \cell }
{\row }
}
}{
Definition at line 75 of file spark_wiring_string.cpp.}\par
{
References init(), and operator=().}\par
{
Referenced by StringSumHelper::StringSumHelper().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    76 \{\par
   77     init();\par
   78     *this = value;\par
   79 \}\par
}
}
{\xe \v String\:String}
{\xe \v String\:String}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String::String (const __FlashStringHelper *  {\i pstr})}}
\par
{\bkmkstart AAAAAAABBC}
{\bkmkend AAAAAAABBC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v String\:String}
{\xe \v String\:String}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String::String (const {\b Printable} &  {\i printable})}}
\par
{\bkmkstart AAAAAAABBD}
{\bkmkend AAAAAAABBD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b String} object from any {\b Printable} object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i printable} \cell }{The {\b Printable} object. The toPrint() method will be called on it to print to this {\b String} the textual representation of the object.\cell }
{\row }
}
For example, IPAddress is printable, so you can pass an IPAddress to this constructor and this string will contain a textual representation of the IPAddress (dotted quad). \par
}{
Definition at line 780 of file spark_wiring_string.cpp.}\par
{
References init(), Printable::printTo(), and StringPrintableHelper::StringPrintableHelper().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   781 \{\par
  782     init();\par
  783     StringPrintableHelper help(*this);\par
  784     printable.printTo(help);\par
  785 \}\par
}
}
{\xe \v String\:String}
{\xe \v String\:String}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String::String (char  {\i c}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABBE}
{\bkmkend AAAAAAABBE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b String} containing a single character. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i c} \cell }{The character to set the {\b String} to \cell }
{\row }
}
}{
Definition at line 94 of file spark_wiring_string.cpp.}\par
{
References init(), and operator=().}\par
{
Referenced by StringSumHelper::StringSumHelper().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    95 \{\par
   96     init();\par
   97     char buf[2];\par
   98     buf[0] = c;\par
   99     buf[1] = 0;\par
  100     *this = buf;\par
  101 \}\par
}
}
{\xe \v String\:String}
{\xe \v String\:String}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String::String (unsigned char  {\i b}, unsigned char  {\i base} = {\f2 10}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABBF}
{\bkmkend AAAAAAABBF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b String} from a unsigned char (uint8_t) value, expressed as a number. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i b} \cell }{The value.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i base} \cell }{The number base, default is 10 (decimal). Other values include 8 (octal) and 16 (hexadecimal). \cell }
{\row }
}
}{
Definition at line 103 of file spark_wiring_string.cpp.}\par
{
References init(), operator=(), and utoa().}\par
{
Referenced by StringSumHelper::StringSumHelper().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   104 \{\par
  105     init();\par
  106     char buf[9];\par
  107     utoa(value, buf, base);\par
  108     *this = buf;\par
  109 \}\par
}
}
{\xe \v String\:String}
{\xe \v String\:String}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String::String (int  {\i value}, unsigned char  {\i base} = {\f2 10}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABBG}
{\bkmkend AAAAAAABBG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b String} from a int (32 bit signed integer) value, expressed as a number. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{The value.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i base} \cell }{The number base, default is 10 (decimal). Other values include 8 (octal) and 16 (hexadecimal). \cell }
{\row }
}
}{
Definition at line 111 of file spark_wiring_string.cpp.}\par
{
References init(), itoa(), and operator=().}\par
{
Referenced by StringSumHelper::StringSumHelper().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   112 \{\par
  113     init();\par
  114     char buf[34];\par
  115     itoa(value, buf, base);\par
  116     *this = buf;\par
  117 \}\par
}
}
{\xe \v String\:String}
{\xe \v String\:String}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String::String (unsigned int  {\i value}, unsigned char  {\i base} = {\f2 10}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABBH}
{\bkmkend AAAAAAABBH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b String} from a unsigned int (32 bit unsigned integer) value, expressed as a number. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{The value.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i base} \cell }{The number base, default is 10 (decimal). Other values include 8 (octal) and 16 (hexadecimal). \cell }
{\row }
}
}{
Definition at line 119 of file spark_wiring_string.cpp.}\par
{
References init(), operator=(), and utoa().}\par
{
Referenced by maxCurrentC1_test(), maxCurrentC2_test(), and StringSumHelper::StringSumHelper().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   120 \{\par
  121     init();\par
  122     char buf[33];\par
  123     utoa(value, buf, base);\par
  124     *this = buf;\par
  125 \}\par
}
}
{\xe \v String\:String}
{\xe \v String\:String}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String::String (long  {\i value}, unsigned char  {\i base} = {\f2 10}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABBI}
{\bkmkend AAAAAAABBI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b String} from a long (32 bit signed integer) value, expressed as a number. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{The value.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i base} \cell }{The number base, default is 10 (decimal). Other values include 8 (octal) and 16 (hexadecimal). \cell }
{\row }
}
}{
Definition at line 127 of file spark_wiring_string.cpp.}\par
{
References init(), ltoa(), and operator=().}\par
{
Referenced by StringSumHelper::StringSumHelper().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   128 \{\par
  129     init();\par
  130     char buf[34];\par
  131     ltoa(value, buf, base);\par
  132     *this = buf;\par
  133 \}\par
}
}
{\xe \v String\:String}
{\xe \v String\:String}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String::String (unsigned long  {\i value}, unsigned char  {\i base} = {\f2 10}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABBJ}
{\bkmkend AAAAAAABBJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b String} from a unsigned long (32 bit unsigned integer) value, expressed as a number. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{The value.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i base} \cell }{The number base, default is 10 (decimal). Other values include 8 (octal) and 16 (hexadecimal). \cell }
{\row }
}
}{
Definition at line 135 of file spark_wiring_string.cpp.}\par
{
References init(), operator=(), and ultoa().}\par
{
Referenced by StringSumHelper::StringSumHelper().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   136 \{\par
  137     init();\par
  138     char buf[33];\par
  139     ultoa(value, buf, base);\par
  140     *this = buf;\par
  141 \}\par
}
}
{\xe \v String\:String}
{\xe \v String\:String}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String::String (float  {\i value}, int  {\i decimalPlaces} = {\f2 6}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABBK}
{\bkmkend AAAAAAABBK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b String} from a float (32 bit single precision floating point) value, expressed as a number. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{The value.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i decimalPlaces} \cell }{The number of decimal places to show. Default = 6. \cell }
{\row }
}
}{
Definition at line 143 of file spark_wiring_string.cpp.}\par
{
References dtoa(), init(), and operator=().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   144 \{\par
  145     init();\par
  146     char buf[33];\par
  147     dtoa(value, decimalPlaces, buf);\par
  148         *this = buf;\par
  149 \}\par
}
}
{\xe \v String\:String}
{\xe \v String\:String}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String::String (double  {\i value}, int  {\i decimalPlaces} = {\f2 6}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABBL}
{\bkmkend AAAAAAABBL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Construct a {\b String} from a double (64 bit double precision floating point) value, expressed as a number. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i value} \cell }{The value.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i decimalPlaces} \cell }{The number of decimal places to show. Default = 6. \cell }
{\row }
}
}{
Definition at line 151 of file spark_wiring_string.cpp.}\par
{
References dtoa(), init(), and operator=().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   152 \{\par
  153     init();\par
  154     char buf[33];\par
  155     dtoa(value, decimalPlaces, buf);\par
  156         *this = buf;\par
  157 \}\par
}
}
{\xe \v ~String\:String}
{\xe \v String\:~String}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String::~String (void )}}
\par
{\bkmkstart AAAAAAABBM}
{\bkmkend AAAAAAABBM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destructor. Also deletes the underlying dynamically allocated string. }}\par
{
Definition at line 158 of file spark_wiring_string.cpp.}\par
{
References buffer.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   159 \{\par
  160     free(buffer);\par
  161 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v c_str\:String}
{\xe \v String\:c_str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* String::c_str () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBN}
{\bkmkend AAAAAAABBN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a c-string (null-terminated) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This allows the {\b String} object to be passed to anything that requires a c-string. See also operator const char *.\par
One place where you need to explicitly use {\b c_str()} or cast is when passing a {\b String} as a variable argument to sprintf:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid String str;\par
snprintf(buf, sizeof(buf), "string=%s", str.c_str());\par
}
\par
If you leave off the {\b c_str()} the value won't be printed as string. This also applies to things that use sprintf internally, like Log:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Log.info("string=%s", str.c_str());\par
}
\par
This method returns a pointer to the internal buffer. If the underlying string is reallocated because the string is appended to, this pointer will be invalid. \par
}{
Definition at line 819 of file spark_wiring_string.h.}\par
{
References buffer.}\par
{
Referenced by JsonWriter::insertValue(), main(), operator const char *(), and operator<<().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   819 \{ return buffer; \}\par
}
}
{\xe \v changeBuffer\:String}
{\xe \v String\:changeBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::changeBuffer (unsigned int  {\i maxStrLen}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABBO}
{\bkmkend AAAAAAABBO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 192 of file spark_wiring_string.cpp.}\par
{
References buffer, and capacity.}\par
{
Referenced by replace(), and reserve().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   193 \{\par
  194     char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);\par
  195     if (newbuffer) \{\par
  196         buffer = newbuffer;\par
  197         capacity = maxStrLen;\par
  198         return 1;\par
  199     \}\par
  200     return 0;\par
  201 \}\par
}
}
{\xe \v charAt\:String}
{\xe \v String\:charAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char String::charAt (unsigned int  {\i index}) const}}
\par
{\bkmkstart AAAAAAABBP}
{\bkmkend AAAAAAABBP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the character at offset index. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{The index to set (0 = first character)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The character is 0 if the index is larger than the length of the string. \par
}}{
Definition at line 509 of file spark_wiring_string.cpp.}\par
{
References operator[]().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   510 \{\par
  511     return operator[](loc);\par
  512 \}\par
}
}
{\xe \v compareTo\:String}
{\xe \v String\:compareTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int String::compareTo (const {\b String} &  {\i s}) const}}
\par
{\bkmkstart AAAAAAABBQ}
{\bkmkend AAAAAAABBQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compares this string to another string using strcmp (case-sensitive) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i s} \cell }{the string to compare to\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid < 0 if s is less than this, == 0 is s equals this, or > 0 if s is greater than this\par
}Uses the C standard library function strcmp which is case-sensitive and does not correctly compare UTF-8 characters. \par
}{
Definition at line 432 of file spark_wiring_string.cpp.}\par
{
References buffer, and len.}\par
{
Referenced by equals(), operator<(), operator<=(), operator>(), and operator>=().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   433 \{\par
  434     if (!buffer || !s.buffer) \{\par
  435         if (s.buffer && s.len > 0) return 0 - *(unsigned char *)s.buffer;\par
  436         if (buffer && len > 0) return *(unsigned char *)buffer;\par
  437         return 0;\par
  438     \}\par
  439     return strcmp(buffer, s.buffer);\par
  440 \}\par
}
}
{\xe \v concat\:String}
{\xe \v String\:concat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::concat (const {\b String} &  {\i str})}}
\par
{\bkmkstart AAAAAAABBR}
{\bkmkend AAAAAAABBR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) a {\b String} object to the end of this {\b String}, modifying this string in place. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{The string to copy from. It is not modified.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the append succeeded or false if there was not enough memory or the parameter was invalid. \par
}}{
Definition at line 276 of file spark_wiring_string.cpp.}\par
{
References buffer, concat(), and len.}\par
{
Referenced by operator+=().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   277 \{\par
  278     return concat(s.buffer, s.len);\par
  279 \}\par
}
}
{\xe \v concat\:String}
{\xe \v String\:concat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::concat (const char *  {\i cstr})}}
\par
{\bkmkstart AAAAAAABBS}
{\bkmkend AAAAAAABBS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) a c-string (null-terminated) to the end of this {\b String}, modifying this string in place. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cstr} \cell }{The string to copy from. It is not modified.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the append succeeded or false if there was not enough memory or the parameter was invalid. \par
}}{
Definition at line 292 of file spark_wiring_string.cpp.}\par
{
References concat().}\par
{
Referenced by operator+=().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   293 \{\par
  294     if (!cstr) return 0;\par
  295     return concat(cstr, strlen(cstr));\par
  296 \}\par
}
}
{\xe \v concat\:String}
{\xe \v String\:concat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::concat (const __FlashStringHelper *  {\i str})}}
\par
{\bkmkstart AAAAAAABBT}
{\bkmkend AAAAAAABBT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v concat\:String}
{\xe \v String\:concat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::concat (char  {\i c})}}
\par
{\bkmkstart AAAAAAABBU}
{\bkmkend AAAAAAABBU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) a single character to the end of this {\b String}, modifying this string in place. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i c} \cell }{The character to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the append succeeded or false if there was not enough memory. \par
}}{
Definition at line 298 of file spark_wiring_string.cpp.}\par
{
References concat().}\par
{
Referenced by JsonParserString::append(), operator+(), operator+=(), and StringPrintableHelper::write().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   299 \{\par
  300     char buf[2];\par
  301     buf[0] = c;\par
  302     buf[1] = 0;\par
  303     return concat(buf, 1);\par
  304 \}\par
}
}
{\xe \v concat\:String}
{\xe \v String\:concat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::concat (unsigned char  {\i c})}}
\par
{\bkmkstart AAAAAAABBV}
{\bkmkend AAAAAAABBV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the byte value c to the end of this {\b String} as a decimal number 0 - 255, modifying this string in place. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i c} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the append succeeded or false if there was not enough memory. \par
}}{
Definition at line 306 of file spark_wiring_string.cpp.}\par
{
References concat(), and itoa().}\par
{
Referenced by operator+(), and operator+=().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   307 \{\par
  308     char buf[4];\par
  309     itoa(num, buf, 10);\par
  310     return concat(buf, strlen(buf));\par
  311 \}\par
}
}
{\xe \v concat\:String}
{\xe \v String\:concat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::concat (int  {\i num})}}
\par
{\bkmkstart AAAAAAABBW}
{\bkmkend AAAAAAABBW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the integer value num to the end of this {\b String} as a signed decimal number (base 10), modifying this string in place. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the append succeeded or false if there was not enough memory. \par
}}{
Definition at line 313 of file spark_wiring_string.cpp.}\par
{
References concat(), and itoa().}\par
{
Referenced by allowUser_callback(), maxCurrentC1_test(), maxCurrentC2_test(), operator+(), and operator+=().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   314 \{\par
  315     char buf[7];\par
  316     itoa(num, buf, 10);\par
  317     return concat(buf, strlen(buf));\par
  318 \}\par
}
}
{\xe \v concat\:String}
{\xe \v String\:concat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::concat (unsigned int  {\i num})}}
\par
{\bkmkstart AAAAAAABBX}
{\bkmkend AAAAAAABBX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the unsigned integer value num to the end of this {\b String} as a unsigned decimal number (base 10), modifying this string in place. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the append succeeded or false if there was not enough memory. \par
}}{
Definition at line 320 of file spark_wiring_string.cpp.}\par
{
References concat(), and utoa().}\par
{
Referenced by operator+(), and operator+=().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   321 \{\par
  322     char buf[6];\par
  323     utoa(num, buf, 10);\par
  324     return concat(buf, strlen(buf));\par
  325 \}\par
}
}
{\xe \v concat\:String}
{\xe \v String\:concat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::concat (long  {\i num})}}
\par
{\bkmkstart AAAAAAABBY}
{\bkmkend AAAAAAABBY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the long integer value num to the end of this {\b String} as a signed decimal number (base 10), modifying this string in place. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the append succeeded or false if there was not enough memory. \par
}}{
Definition at line 327 of file spark_wiring_string.cpp.}\par
{
References concat(), and ltoa().}\par
{
Referenced by operator+(), and operator+=().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   328 \{\par
  329     char buf[12];\par
  330     ltoa(num, buf, 10);\par
  331     return concat(buf, strlen(buf));\par
  332 \}\par
}
}
{\xe \v concat\:String}
{\xe \v String\:concat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::concat (unsigned long  {\i num})}}
\par
{\bkmkstart AAAAAAABBZ}
{\bkmkend AAAAAAABBZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the unsigned long value num to the end of this {\b String} as a unsigned decimal number (base 10), modifying this string in place. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the append succeeded or false if there was not enough memory. \par
}}{
Definition at line 334 of file spark_wiring_string.cpp.}\par
{
References concat(), DEC, and ultoa().}\par
{
Referenced by operator+(), and operator+=().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   335 \{\par
  336     char buf[11];\par
  337     ultoa(num, buf, DEC);\par
  338     return concat(buf, strlen(buf));\par
  339 \}\par
}
}
{\xe \v concat\:String}
{\xe \v String\:concat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::concat (float  {\i num})}}
\par
{\bkmkstart AAAAAAABCA}
{\bkmkend AAAAAAABCA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the float n to the end of this {\b String} as a decimal number (base 10), modifying this string in place. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the append succeeded or false if there was not enough memory. \par
}}{
Definition at line 341 of file spark_wiring_string.cpp.}\par
{
References concat(), and dtoa().}\par
{
Referenced by operator+().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   342 \{\par
  343     char buf[20];\par
  344     dtoa(num, 6, buf);\par
  345     return concat(buf, strlen(buf));\par
  346 \}\par
}
}
{\xe \v concat\:String}
{\xe \v String\:concat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::concat (double  {\i num})}}
\par
{\bkmkstart AAAAAAABCB}
{\bkmkend AAAAAAABCB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the double precision float n to the end of this {\b String} as a decimal number (base 10), modifying this string in place. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the append succeeded or false if there was not enough memory. \par
}}{
Definition at line 348 of file spark_wiring_string.cpp.}\par
{
References concat(), and dtoa().}\par
{
Referenced by operator+().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   349 \{\par
  350     char buf[20];\par
  351     dtoa(num, 6, buf);\par
  352     return concat(buf, strlen(buf));\par
  353 \}\par
}
}
{\xe \v concat\:String}
{\xe \v String\:concat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::concat (const char *  {\i cstr}, unsigned int  {\i length}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABCC}
{\bkmkend AAAAAAABCC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 281 of file spark_wiring_string.cpp.}\par
{
References buffer, len, and reserve().}\par
{
Referenced by concat(), operator+(), and StringPrintableHelper::write().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   282 \{\par
  283     unsigned int newlen = len + length;\par
  284     if (!cstr) return 0;\par
  285     if (length == 0) return 1;\par
  286     if (!reserve(newlen)) return 0;\par
  287     strcpy(buffer + len, cstr);\par
  288     len = newlen;\par
  289     return 1;\par
  290 \}\par
}
}
{\xe \v copy\:String}
{\xe \v String\:copy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String} & String::copy (const char *  {\i cstr}, unsigned int  {\i length}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABCD}
{\bkmkend AAAAAAABCD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 207 of file spark_wiring_string.cpp.}\par
{
References buffer, invalidate(), len, and reserve().}\par
{
Referenced by operator=(), and String().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   208 \{\par
  209     if (!reserve(length)) \{\par
  210         invalidate();\par
  211         return *this;\par
  212     \}\par
  213     len = length;\par
  214     strcpy(buffer, cstr);\par
  215     return *this;\par
  216 \}\par
}
}
{\xe \v copy\:String}
{\xe \v String\:copy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String}& String::copy (const __FlashStringHelper *  {\i pstr}, unsigned int  {\i length}){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABCE}
{\bkmkend AAAAAAABCE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v endsWith\:String}
{\xe \v String\:endsWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::endsWith (const {\b String} &  {\i suffix}) const}}
\par
{\bkmkstart AAAAAAABCF}
{\bkmkend AAAAAAABCF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string ends with suffix (case-sensitive) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i suffix} \cell }{the string containing the suffix to test\cell }
{\row }
}
Uses the C standard library function strcmp which is case-sensitive and may not work properly with UTF-8 characters. \par
}{
Definition at line 499 of file spark_wiring_string.cpp.}\par
{
References buffer, and len.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   500 \{\par
  501     if ( len < s2.len || !buffer || !s2.buffer) return 0;\par
  502     return strcmp(&buffer[len - s2.len], s2.buffer) == 0;\par
  503 \}\par
}
}
{\xe \v equals\:String}
{\xe \v String\:equals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::equals (const {\b String} &  {\i s}) const}}
\par
{\bkmkstart AAAAAAABCG}
{\bkmkend AAAAAAABCG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string is equal to another string (case-sensitive) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i s} \cell }{the string to compare to\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the other string is equal to this string.\par
}Uses the C standard library function strcmp which is case-sensitive and does not correctly compare UTF-8 characters. \par
}{
Definition at line 442 of file spark_wiring_string.cpp.}\par
{
References compareTo(), and len.}\par
{
Referenced by operator!=(), and operator==().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   443 \{\par
  444     return (len == s2.len && compareTo(s2) == 0);\par
  445 \}\par
}
}
{\xe \v equals\:String}
{\xe \v String\:equals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::equals (const char *  {\i cstr}) const}}
\par
{\bkmkstart AAAAAAABCH}
{\bkmkend AAAAAAABCH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string equal to another string (case-sensitive) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cstr} \cell }{the c-string (null-terminated) to compare to\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the other string is equal to this string.\par
}Uses the C standard library function strcmp which is case-sensitive and does not correctly compare UTF-8 characters. \par
}{
Definition at line 447 of file spark_wiring_string.cpp.}\par
{
References buffer, and len.}\par
{
Referenced by operator!=(), and operator==().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   448 \{\par
  449     if (len == 0) return (cstr == NULL || *cstr == 0);\par
  450     if (cstr == NULL) return buffer[0] == 0;\par
  451     return strcmp(buffer, cstr) == 0;\par
  452 \}\par
}
}
{\xe \v equalsIgnoreCase\:String}
{\xe \v String\:equalsIgnoreCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::equalsIgnoreCase (const {\b String} &  {\i s}) const}}
\par
{\bkmkstart AAAAAAABCI}
{\bkmkend AAAAAAABCI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string equals another string (case-insensitive) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i s} \cell }{the string to compare to\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if equal, false if not\par
}Uses the C standard library function strcmp which is case-sensitive and does not correctly compare UTF-8 characters. \par
}{
Definition at line 474 of file spark_wiring_string.cpp.}\par
{
References buffer, and len.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   475 \{\par
  476     if (this == &s2) return 1;\par
  477     if (len != s2.len) return 0;\par
  478     if (len == 0) return 1;\par
  479     const char *p1 = buffer;\par
  480     const char *p2 = s2.buffer;\par
  481     while (*p1) \{\par
  482         if (tolower(*p1++) != tolower(*p2++)) return 0;\par
  483     \}\par
  484     return 1;\par
  485 \}\par
}
}
{\xe \v format\:String}
{\xe \v String\:format}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String} String::format (const char *  {\i format},   {\i ...}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCJ}
{\bkmkend AAAAAAABCJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Uses sprintf-style formatting to build a {\b String} object [static]. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i format} \cell }{The formatting string\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ...} \cell }{Variable arguments corresponding to the formatting string\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Returns a {\b String} object formatted as specified \par
}}{
Definition at line 787 of file spark_wiring_string.cpp.}\par
{
References buffer, len, and reserve().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   788 \{\par
  789     va_list marker;\par
  790     va_start(marker, fmt);\par
  791     const int bufsize = 5;\par
  792     char test[bufsize];\par
  793     size_t n = vsnprintf(test, bufsize, fmt, marker);\par
  794     va_end(marker);\par
  795 \par
  796     String result;\par
  797     result.reserve(n);  // internally adds +1 for null terminator\par
  798     if (result.buffer) \{\par
  799         va_start(marker, fmt);\par
  800         n = vsnprintf(result.buffer, n+1, fmt, marker);\par
  801         va_end(marker);\par
  802         result.len = n;\par
  803     \}\par
  804     return result;\par
  805 \}\par
}
}
{\xe \v getBytes\:String}
{\xe \v String\:getBytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void String::getBytes (unsigned char *  {\i buf}, unsigned int  {\i bufsize}, unsigned int  {\i index} = {\f2 0}) const}}
\par
{\bkmkstart AAAAAAABCK}
{\bkmkend AAAAAAABCK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy the data out of this {\b String} into another buffer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buf} \cell }{The buffer to copy into\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bufsize} \cell }{The size of the buffer. The buffer will contain a null-terminted string so the maximum string length is bufsize - 1.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{The index to start copying from (0 = first character). Optional. Default is from 0, the start of the string.\cell }
{\row }
}
If bufsize is smaller than the string the string will be truncated and still null-terminated. If the string is truncated and UTF-8, it may break a multi-byte character sequence in the middle, resulting in invalid UTF-8. \par
}{
Definition at line 535 of file spark_wiring_string.cpp.}\par
{
References buffer, and len.}\par
{
Referenced by toCharArray().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   536 \{\par
  537     if (!bufsize || !buf) return;\par
  538     if (index >= len) \{\par
  539         buf[0] = 0;\par
  540         return;\par
  541     \}\par
  542     unsigned int n = bufsize - 1;\par
  543     if (n > len - index) n = len - index;\par
  544     strncpy((char *)buf, buffer + index, n);\par
  545     buf[n] = 0;\par
  546 \}\par
}
}
{\xe \v indexOf\:String}
{\xe \v String\:indexOf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int String::indexOf (char  {\i ch}) const}}
\par
{\bkmkstart AAAAAAABCL}
{\bkmkend AAAAAAABCL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Search this string for a given character. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ch} \cell }{The ASCII character to search for\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid index of the character or -1 if not found. 0 = the first character.\par
}This uses the C standard library function strchr and is only compatible with ASCII characters. It can return invalid results for UTF-8 strings. \par
}{
Definition at line 552 of file spark_wiring_string.cpp.}\par
{
References indexOf().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   553 \{\par
  554     return indexOf(c, 0);\par
  555 \}\par
}
}
{\xe \v indexOf\:String}
{\xe \v String\:indexOf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int String::indexOf (char  {\i ch}, unsigned int  {\i fromIndex}) const}}
\par
{\bkmkstart AAAAAAABCM}
{\bkmkend AAAAAAABCM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Search this string for a given character starting at an offset. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ch} \cell }{The ASCII character to t search for\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fromIndex} \cell }{The index to start from (0 = first character)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid index of the character or -1 if not found. 0 = the first character.\par
}This uses the C standard library function strchr and is only compatible with ASCII characters. It can return invalid results for UTF-8 strings. \par
}{
Definition at line 557 of file spark_wiring_string.cpp.}\par
{
References buffer, and len.}\par
{
Referenced by indexOf().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   558 \{\par
  559     if (fromIndex >= len) return -1;\par
  560     const char* temp = strchr(buffer + fromIndex, ch);\par
  561     if (temp == NULL) return -1;\par
  562     return temp - buffer;\par
  563 \}\par
}
}
{\xe \v indexOf\:String}
{\xe \v String\:indexOf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int String::indexOf (const {\b String} &  {\i str}) const}}
\par
{\bkmkstart AAAAAAABCN}
{\bkmkend AAAAAAABCN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Search this string for a given {\b String}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{The string to search for\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid index of the string or -1 if not found. 0 = the first character.\par
}This uses the C standard library function strstr and is only compatible with ASCII characters. It can return invalid results for UTF-8 strings. It is case-sensitive. \par
}{
Definition at line 565 of file spark_wiring_string.cpp.}\par
{
References indexOf().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   566 \{\par
  567     return indexOf(s2, 0);\par
  568 \}\par
}
}
{\xe \v indexOf\:String}
{\xe \v String\:indexOf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int String::indexOf (const {\b String} &  {\i str}, unsigned int  {\i fromIndex}) const}}
\par
{\bkmkstart AAAAAAABCO}
{\bkmkend AAAAAAABCO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Search this string for a given {\b String} starting at an offset. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{The string to search for\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fromIndex} \cell }{The index to start from (0 = first character)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid index of the string or -1 if not found. 0 = the first character.\par
}This uses the C standard library function strstr and is only compatible with ASCII characters. It can return invalid results for UTF-8 strings. It is case-sensitive. \par
}{
Definition at line 570 of file spark_wiring_string.cpp.}\par
{
References buffer, and len.}\par
{
Referenced by indexOf().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   571 \{\par
  572     if (fromIndex >= len) return -1;\par
  573     const char *found = strstr(buffer + fromIndex, s2.buffer);\par
  574     if (found == NULL) return -1;\par
  575     return found - buffer;\par
  576 \}\par
}
}
{\xe \v init\:String}
{\xe \v String\:init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void String::init (void ){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABCP}
{\bkmkend AAAAAAABCP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 167 of file spark_wiring_string.cpp.}\par
{
References buffer, capacity, flags, and len.}\par
{
Referenced by String().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   168 \{\par
  169     buffer = NULL;\par
  170     capacity = 0;\par
  171     len = 0;\par
  172     flags = 0;\par
  173 \}\par
}
}
{\xe \v invalidate\:String}
{\xe \v String\:invalidate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void String::invalidate (void ){\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABCQ}
{\bkmkend AAAAAAABCQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 175 of file spark_wiring_string.cpp.}\par
{
References buffer, capacity, and len.}\par
{
Referenced by copy(), operator+(), and operator=().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   176 \{\par
  177     if (buffer) free(buffer);\par
  178     buffer = NULL;\par
  179     capacity = len = 0;\par
  180 \}\par
}
}
{\xe \v lastIndexOf\:String}
{\xe \v String\:lastIndexOf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int String::lastIndexOf (char  {\i ch}) const}}
\par
{\bkmkstart AAAAAAABCR}
{\bkmkend AAAAAAABCR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Search this string for a given character, starting at the end. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ch} \cell }{The ASCII character to search for\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid index of the character or -1 if not found. 0 = the first character.\par
}This uses the C standard library function strrchr and is only compatible with ASCII characters. It can return invalid results for UTF-8 strings. \par
}{
Definition at line 578 of file spark_wiring_string.cpp.}\par
{
References lastIndexOf(), and len.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   579 \{\par
  580     return lastIndexOf(theChar, len - 1);\par
  581 \}\par
}
}
{\xe \v lastIndexOf\:String}
{\xe \v String\:lastIndexOf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int String::lastIndexOf (char  {\i ch}, unsigned int  {\i fromIndex}) const}}
\par
{\bkmkstart AAAAAAABCS}
{\bkmkend AAAAAAABCS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Search this string for a given character, starting at the fromIndex and going toward the beginning. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ch} \cell }{The ASCII character to search for\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fromIndex} \cell }{The index to start from (0 = first character)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid index of the character or -1 if not found. 0 = the first character.\par
}This uses the C standard library function strrchr and is only compatible with ASCII characters. It can return invalid results for UTF-8 strings. \par
}{
Definition at line 583 of file spark_wiring_string.cpp.}\par
{
References buffer, and len.}\par
{
Referenced by lastIndexOf().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   584 \{\par
  585     if (fromIndex >= len) return -1;\par
  586     char tempchar = buffer[fromIndex + 1];\par
  587     buffer[fromIndex + 1] = '\\0';\par
  588     char* temp = strrchr( buffer, ch );\par
  589     buffer[fromIndex + 1] = tempchar;\par
  590     if (temp == NULL) return -1;\par
  591     return temp - buffer;\par
  592 \}\par
}
}
{\xe \v lastIndexOf\:String}
{\xe \v String\:lastIndexOf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int String::lastIndexOf (const {\b String} &  {\i str}) const}}
\par
{\bkmkstart AAAAAAABCT}
{\bkmkend AAAAAAABCT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Search this string for a last occurrence of str. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{The string to search for\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid index of the start of the string or -1 if not found. 0 = the first character.\par
}This uses the C standard library function strstr and is only compatible with ASCII characters. It can return invalid results for UTF-8 strings. It is case-sensitive. \par
}{
Definition at line 594 of file spark_wiring_string.cpp.}\par
{
References lastIndexOf(), and len.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   595 \{\par
  596     return lastIndexOf(s2, len - s2.len);\par
  597 \}\par
}
}
{\xe \v lastIndexOf\:String}
{\xe \v String\:lastIndexOf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int String::lastIndexOf (const {\b String} &  {\i str}, unsigned int  {\i fromIndex}) const}}
\par
{\bkmkstart AAAAAAABCU}
{\bkmkend AAAAAAABCU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Search this string for a last occurrence of str starting at fromIndex. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{The string to search for\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i fromIndex} \cell }{The index to start from (0 = first character)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid index of the start of the string or -1 if not found. 0 = the first character.\par
}This uses the C standard library function strstr and is only compatible with ASCII characters. It can return invalid results for UTF-8 strings. It is case-sensitive. \par
}{
Definition at line 599 of file spark_wiring_string.cpp.}\par
{
References buffer, and len.}\par
{
Referenced by lastIndexOf(), and replace().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   600 \{\par
  601     if (s2.len == 0 || len == 0 || s2.len > len) return -1;\par
  602     if (fromIndex >= len) fromIndex = len - 1;\par
  603     int found = -1;\par
  604     for (char *p = buffer; p <= buffer + fromIndex; p++) \{\par
  605         p = strstr(p, s2.buffer);\par
  606         if (!p) break;\par
  607         if ((unsigned int)(p - buffer) <= fromIndex) found = p - buffer;\par
  608     \}\par
  609     return found;\par
  610 \}\par
}
}
{\xe \v length\:String}
{\xe \v String\:length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int String::length (void ) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCV}
{\bkmkend AAAAAAABCV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the length of the string in bytes. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Note that for UTF-8 strings, this is the number of bytes, not characters. \par
}{
Definition at line 208 of file spark_wiring_string.h.}\par
{
References len.}\par
{
Referenced by StringPrintableHelper::write().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   208 \{return len;\}\par
}
}
{\xe \v operator const char *\:String}
{\xe \v String\:operator const char *}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String::operator const char * () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCW}
{\bkmkend AAAAAAABCW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the contents this {\b String} as a c-string (null-terminated) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See also {\b c_str()} which is another way to do this. \par
}{
Definition at line 241 of file spark_wiring_string.h.}\par
{
References c_str().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   241 \{ return c_str(); \}\par
}
}
{\xe \v operator StringIfHelperType\:String}
{\xe \v String\:operator StringIfHelperType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String::operator {\b StringIfHelperType} () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCX}
{\bkmkend AAAAAAABCX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 536 of file spark_wiring_string.h.}\par
{
References buffer, and StringIfHelper().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   536 \{ return buffer ? &String::StringIfHelper : 0; \}\par
}
}
{\xe \v operator!=\:String}
{\xe \v String\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::operator!= (const {\b String} &  {\i rhs}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCY}
{\bkmkend AAAAAAABCY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string is greater than to another string (case-sensitive) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rhs} \cell }{the string to compare to\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the other string is greater than this string.\par
}Uses the C standard library function strcmp which is case-sensitive and does not correctly compare UTF-8 characters. \par
}{
Definition at line 610 of file spark_wiring_string.h.}\par
{
References equals().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   610 \{return !equals(rhs);\}\par
}
}
{\xe \v operator!=\:String}
{\xe \v String\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::operator!= (const char *  {\i cstr}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCZ}
{\bkmkend AAAAAAABCZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string not equal to another string (case-sensitive) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cstr} \cell }{the c-string (null-terminated) to compare to\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the other string is not equal to this string.\par
}Uses the C standard library function strcmp which is case-sensitive and does not correctly compare UTF-8 characters. \par
}{
Definition at line 622 of file spark_wiring_string.h.}\par
{
References equals().}\par
{
Referenced by runTest().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   622 \{return !equals(cstr);\}\par
}
}
{\xe \v operator+=\:String}
{\xe \v String\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String}& String::operator+= (const {\b String} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDA}
{\bkmkend AAAAAAABDA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Appends (concatenate) a {\b String} object to the end of this {\b String}, modifying this string in place. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rhs} \cell }{The string to copy from. It is not modified.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid This string to you can chain operations together. If there was not enough memory or other error occurs, this {\b String} will be left unmodified. \par
}}{
Definition at line 352 of file spark_wiring_string.h.}\par
{
References concat().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   352 \{concat(rhs); return (*this);\}\par
}
}
{\xe \v operator+=\:String}
{\xe \v String\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String}& String::operator+= (const char *  {\i cstr}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDB}
{\bkmkend AAAAAAABDB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Appends (concatenate) a c-string (null-terminated) to the end of this {\b String}, modifying this string in place. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cstr} \cell }{The string to copy from. It is not modified.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid This string to you can chain operations together. If there was not enough memory or other error occurs, this {\b String} will be left unmodified. \par
}}{
Definition at line 362 of file spark_wiring_string.h.}\par
{
References concat().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   362 \{concat(cstr); return (*this);\}\par
}
}
{\xe \v operator+=\:String}
{\xe \v String\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String}& String::operator+= (char  {\i c}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDC}
{\bkmkend AAAAAAABDC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Appends (concatenate) a single character to the end of this {\b String}, modifying this string in place. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i c} \cell }{The character to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid This string to you can chain operations together. If there was not enough memory or other error occurs, this {\b String} will be left unmodified. \par
}}{
Definition at line 372 of file spark_wiring_string.h.}\par
{
References concat().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   372 \{concat(c); return (*this);\}\par
}
}
{\xe \v operator+=\:String}
{\xe \v String\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String}& String::operator+= (unsigned char  {\i num}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDD}
{\bkmkend AAAAAAABDD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the byte value num to the end of this {\b String} as a decimal number 0 - 255, modifying this string in place. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid This string to you can chain operations together. If there was not enough memory or other error occurs, this {\b String} will be left unmodified. \par
}}{
Definition at line 382 of file spark_wiring_string.h.}\par
{
References concat().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   382 \{concat(num); return (*this);\}\par
}
}
{\xe \v operator+=\:String}
{\xe \v String\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String}& String::operator+= (int  {\i num}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDE}
{\bkmkend AAAAAAABDE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the integer value num to the end of this {\b String} as a signed decimal number (base 10), modifying this string in place. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid This string to you can chain operations together. If there was not enough memory or other error occurs, this {\b String} will be left unmodified. \par
}}{
Definition at line 392 of file spark_wiring_string.h.}\par
{
References concat().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   392 \{concat(num); return (*this);\}\par
}
}
{\xe \v operator+=\:String}
{\xe \v String\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String}& String::operator+= (unsigned int  {\i num}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDF}
{\bkmkend AAAAAAABDF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the unsigned integer value num to the end of this {\b String} as a unsigned decimal number (base 10), modifying this string in place. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid This string to you can chain operations together. If there was not enough memory or other error occurs, this {\b String} will be left unmodified. \par
}}{
Definition at line 402 of file spark_wiring_string.h.}\par
{
References concat().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   402 \{concat(num); return (*this);\}\par
}
}
{\xe \v operator+=\:String}
{\xe \v String\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String}& String::operator+= (long  {\i num}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDG}
{\bkmkend AAAAAAABDG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the long integer value num to the end of this {\b String} as a signed decimal number (base 10), modifying this string in place. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid This string to you can chain operations together. If there was not enough memory or other error occurs, this {\b String} will be left unmodified. \par
}}{
Definition at line 412 of file spark_wiring_string.h.}\par
{
References concat().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   412 \{concat(num); return (*this);\}\par
}
}
{\xe \v operator+=\:String}
{\xe \v String\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String}& String::operator+= (unsigned long  {\i num}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDH}
{\bkmkend AAAAAAABDH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the unsigned long value num to the end of this {\b String} as a unsigned decimal number (base 10), modifying this string in place. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid This string to you can chain operations together. If there was not enough memory or other error occurs, this {\b String} will be left unmodified. \par
}}{
Definition at line 422 of file spark_wiring_string.h.}\par
{
References concat().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   422 \{concat(num); return (*this);\}\par
}
}
{\xe \v operator<\:String}
{\xe \v String\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::operator< (const {\b String} &  {\i rhs}) const}}
\par
{\bkmkstart AAAAAAABDI}
{\bkmkend AAAAAAABDI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string is less than to another string (case-sensitive) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rhs} \cell }{the string to compare to\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the other string is less than this string.\par
}Uses the C standard library function strcmp which is case-sensitive and does not correctly compare UTF-8 characters. \par
}{
Definition at line 454 of file spark_wiring_string.cpp.}\par
{
References compareTo().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   455 \{\par
  456     return compareTo(rhs) < 0;\par
  457 \}\par
}
}
{\xe \v operator<=\:String}
{\xe \v String\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::operator<= (const {\b String} &  {\i rhs}) const}}
\par
{\bkmkstart AAAAAAABDJ}
{\bkmkend AAAAAAABDJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string is less than or equal to another string (case-sensitive) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rhs} \cell }{the string to compare to\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the other string is less than or equal to this string.\par
}Uses the C standard library function strcmp which is case-sensitive and does not correctly compare UTF-8 characters. \par
}{
Definition at line 464 of file spark_wiring_string.cpp.}\par
{
References compareTo().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   465 \{\par
  466     return compareTo(rhs) <= 0;\par
  467 \}\par
}
}
{\xe \v operator=\:String}
{\xe \v String\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String} & String::operator= (const {\b String} &  {\i rhs})}}
\par
{\bkmkstart AAAAAAABDK}
{\bkmkend AAAAAAABDK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assigns this string to have a copy of {\b String} rhs. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rhs} \cell }{The string to copy from. \cell }
{\row }
}
}{
Definition at line 240 of file spark_wiring_string.cpp.}\par
{
References buffer, copy(), invalidate(), and len.}\par
{
Referenced by String().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   241 \{\par
  242     if (this == &rhs) return *this;\par
  243 \par
  244     if (rhs.buffer) copy(rhs.buffer, rhs.len);\par
  245     else invalidate();\par
  246 \par
  247     return *this;\par
  248 \}\par
}
}
{\xe \v operator=\:String}
{\xe \v String\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String} & String::operator= (const char *  {\i cstr})}}
\par
{\bkmkstart AAAAAAABDL}
{\bkmkend AAAAAAABDL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Assigns this string to have a copy of c-string (null-terminated) cstr. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cstr} \cell }{The string to copy from. \cell }
{\row }
}
}{
Definition at line 264 of file spark_wiring_string.cpp.}\par
{
References copy(), and invalidate().}\par
{
Referenced by allowUser_callback(), callback(), charToString(), JsonParser::getTokenJsonString(), JsonParser::getTokenValue(), MQTT::initialize(), loop(), MQTT::setBroker(), String(), and substring().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   265 \{\par
  266     if (cstr) copy(cstr, strlen(cstr));\par
  267     else invalidate();\par
  268 \par
  269     return *this;\par
  270 \}\par
}
}
{\xe \v operator=\:String}
{\xe \v String\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String}& String::operator= (const __FlashStringHelper *  {\i pstr})}}
\par
{\bkmkstart AAAAAAABDM}
{\bkmkend AAAAAAABDM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:String}
{\xe \v String\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::operator== (const {\b String} &  {\i rhs}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDN}
{\bkmkend AAAAAAABDN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string is equal to another string (case-sensitive) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rhs} \cell }{the string to compare to\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the other string is equal to this string.\par
}Uses the C standard library function strcmp which is case-sensitive and does not correctly compare UTF-8 characters. \par
}{
Definition at line 585 of file spark_wiring_string.h.}\par
{
References equals().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   585 \{return equals(rhs);\}\par
}
}
{\xe \v operator==\:String}
{\xe \v String\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::operator== (const char *  {\i cstr}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDO}
{\bkmkend AAAAAAABDO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string equal to another string (case-sensitive) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cstr} \cell }{the c-string (null-terminated) to compare to\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the other string is equal to this string.\par
}Uses the C standard library function strcmp which is case-sensitive and does not correctly compare UTF-8 characters. \par
}{
Definition at line 597 of file spark_wiring_string.h.}\par
{
References equals().}\par
{
Referenced by JsonParser::getValueTokenByKey(), main(), and switchTest().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   597 \{return equals(cstr);\}\par
}
}
{\xe \v operator>\:String}
{\xe \v String\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::operator> (const {\b String} &  {\i rhs}) const}}
\par
{\bkmkstart AAAAAAABDP}
{\bkmkend AAAAAAABDP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string is greater than to another string (case-sensitive) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rhs} \cell }{the string to compare to\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the other string is greater than this string.\par
}Uses the C standard library function strcmp which is case-sensitive and does not correctly compare UTF-8 characters. \par
}{
Definition at line 459 of file spark_wiring_string.cpp.}\par
{
References compareTo().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   460 \{\par
  461     return compareTo(rhs) > 0;\par
  462 \}\par
}
}
{\xe \v operator>=\:String}
{\xe \v String\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::operator>= (const {\b String} &  {\i rhs}) const}}
\par
{\bkmkstart AAAAAAABDQ}
{\bkmkend AAAAAAABDQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string is greater than or equal to another string (case-sensitive) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rhs} \cell }{the string to compare to\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid true if the other string is greater than or equal to this string.\par
}Uses the C standard library function strcmp which is case-sensitive and does not correctly compare UTF-8 characters. \par
}{
Definition at line 469 of file spark_wiring_string.cpp.}\par
{
References compareTo().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   470 \{\par
  471     return compareTo(rhs) >= 0;\par
  472 \}\par
}
}
{\xe \v operator[]\:String}
{\xe \v String\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char String::operator[] (unsigned int  {\i index}) const}}
\par
{\bkmkstart AAAAAAABDR}
{\bkmkend AAAAAAABDR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gets the character at offset index. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{The index to set (0 = first character)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The character is 0 if the index is larger than the length of the string. \par
}}{
Definition at line 529 of file spark_wiring_string.cpp.}\par
{
References buffer, and len.}\par
{
Referenced by charAt().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   530 \{\par
  531     if (index >= len || !buffer) return 0;\par
  532     return buffer[index];\par
  533 \}\par
}
}
{\xe \v operator[]\:String}
{\xe \v String\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char & String::operator[] (unsigned int  {\i index})}}
\par
{\bkmkstart AAAAAAABDS}
{\bkmkend AAAAAAABDS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the character at offset index. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{The index to set (0 = first character)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid A reference to set.\par
}If index is greater than the length of the string, a dummy reference is returned instead. This allows operation to execute without error, but also discards the change. In other words, you cannot use this to append to the string, only modify an existing character. \par
}{
Definition at line 519 of file spark_wiring_string.cpp.}\par
{
References buffer, and len.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   520 \{\par
  521     static char dummy_writable_char;\par
  522     if (index >= len || !buffer) \{\par
  523         dummy_writable_char = 0;\par
  524         return dummy_writable_char;\par
  525     \}\par
  526     return buffer[index];\par
  527 \}\par
}
}
{\xe \v remove\:String}
{\xe \v String\:remove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String} & String::remove (unsigned int  {\i index})}}
\par
{\bkmkstart AAAAAAABDT}
{\bkmkend AAAAAAABDT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes characters from the {\b String}, modifying it in place. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{Index to start removing from, inclusive. 0 = first character of the string through the end of the string.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid this {\b String}, so you can chain multiple operations \par
}}{
Definition at line 691 of file spark_wiring_string.cpp.}\par
{
References len, and remove().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   691                                         \{\par
  692         int count = len - index;\par
  693         return remove(index, count);\par
  694 \}\par
}
}
{\xe \v remove\:String}
{\xe \v String\:remove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String} & String::remove (unsigned int  {\i index}, unsigned int  {\i count})}}
\par
{\bkmkstart AAAAAAABDU}
{\bkmkend AAAAAAABDU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes characters from the {\b String}, modifying it in place. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{Index to start removing from, inclusive. 0 = first character of the string.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i count} \cell }{Number of characters to remove. Typically 1 (remove one character) or more. Removes to the end of the string if count is larger than the size of the string.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid this {\b String}, so you can chain multiple operations \par
}}{
Definition at line 696 of file spark_wiring_string.cpp.}\par
{
References buffer, and len.}\par
{
Referenced by remove().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   696                                                             \{\par
  697     if (index >= len) \{ return *this; \}\par
  698     if (count <= 0) \{ return *this; \}\par
  699     if (index + count > len) \{ count = len - index; \}\par
  700     char *writeTo = buffer + index;\par
  701     len = len - count;\par
  702     strncpy(writeTo, buffer + index + count,len - index);\par
  703     buffer[len] = 0;\par
  704         return *this;\par
  705 \}\par
}
}
{\xe \v replace\:String}
{\xe \v String\:replace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String} & String::replace (char  {\i find}, char  {\i replace})}}
\par
{\bkmkstart AAAAAAABDV}
{\bkmkend AAAAAAABDV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Replaces every occurrence of a character in the string with another character, modifying it in place. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i find} \cell }{the character to look for\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i replace} \cell }{the character to replace it with\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid this {\b String}, so you can chain multiple operations \par
}}{
Definition at line 638 of file spark_wiring_string.cpp.}\par
{
References buffer.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   639 \{\par
  640     if (buffer)\par
  641             for (char *p = buffer; *p; p++) \{\par
  642                     if (*p == find) *p = replace;\par
  643             \}\par
  644         return *this;\par
  645 \}\par
}
}
{\xe \v replace\:String}
{\xe \v String\:replace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String} & String::replace (const {\b String} &  {\i find}, const {\b String} &  {\i replace})}}
\par
{\bkmkstart AAAAAAABDW}
{\bkmkend AAAAAAABDW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Replaces every occurrence of a {\b String} with another {\b String}, modifying it in place. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i find} \cell }{the string to look for (case-sensitive)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i replace} \cell }{the string to replace it with\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid this {\b String}, so you can chain multiple operations \par
}}{
Definition at line 647 of file spark_wiring_string.cpp.}\par
{
References buffer, capacity, changeBuffer(), lastIndexOf(), and len.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   648 \{\par
  649     if (len == 0 || find.len == 0) return *this;\par
  650     int diff = replace.len - find.len;\par
  651     char *readFrom = buffer;\par
  652     char *foundAt;\par
  653     if (diff == 0) \{\par
  654         while ((foundAt = strstr(readFrom, find.buffer)) != NULL) \{\par
  655             memcpy(foundAt, replace.buffer, replace.len);\par
  656             readFrom = foundAt + replace.len;\par
  657         \}\par
  658     \} else if (diff < 0) \{\par
  659         char *writeTo = buffer;\par
  660         while ((foundAt = strstr(readFrom, find.buffer)) != NULL) \{\par
  661             unsigned int n = foundAt - readFrom;\par
  662             memcpy(writeTo, readFrom, n);\par
  663             writeTo += n;\par
  664             memcpy(writeTo, replace.buffer, replace.len);\par
  665             writeTo += replace.len;\par
  666             readFrom = foundAt + find.len;\par
  667             len += diff;\par
  668         \}\par
  669         strcpy(writeTo, readFrom);\par
  670     \} else \{\par
  671         unsigned int size = len; // compute size needed for result\par
  672         while ((foundAt = strstr(readFrom, find.buffer)) != NULL) \{\par
  673             readFrom = foundAt + find.len;\par
  674             size += diff;\par
  675         \}\par
  676         if (size == len) return *this;;\par
  677         if (size > capacity && !changeBuffer(size)) return *this; // XXX: tell user!\par
  678         int index = len - 1;\par
  679         while (index >= 0 && (index = lastIndexOf(find, index)) >= 0) \{\par
  680             readFrom = buffer + index + find.len;\par
  681             memmove(readFrom + diff, readFrom, len - (readFrom - buffer));\par
  682             len += diff;\par
  683             buffer[len] = 0;\par
  684             memcpy(buffer + index, replace.buffer, replace.len);\par
  685             index--;\par
  686         \}\par
  687     \}\par
  688         return *this;\par
  689 \}\par
}
}
{\xe \v reserve\:String}
{\xe \v String\:reserve}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::reserve (unsigned int  {\i size})}}
\par
{\bkmkstart AAAAAAABDX}
{\bkmkend AAAAAAABDX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reserves a buffer of size. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This can improve the efficiency if you know approximately how big your string will be. Otherwise, the string is made larger in increments, which is much less efficient.\par
If, for example you reserve 100 bytes in a new empty string, the length will still be 0 until you append characters to it. It just will be able to append 100 bytes until it has to expand the internal dynamically allocated buffer. \par
}{
Definition at line 182 of file spark_wiring_string.cpp.}\par
{
References buffer, capacity, changeBuffer(), and len.}\par
{
Referenced by concat(), copy(), format(), JsonParser::getTokenJsonString(), JsonParser::getTokenValue(), and StringPrintableHelper::StringPrintableHelper().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   183 \{\par
  184     if (buffer && capacity >= size) return 1;\par
  185     if (changeBuffer(size)) \{\par
  186         if (len == 0) buffer[0] = 0;\par
  187         return 1;\par
  188     \}\par
  189     return 0;\par
  190 \}\par
}
}
{\xe \v setCharAt\:String}
{\xe \v String\:setCharAt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void String::setCharAt (unsigned int  {\i index}, char  {\i c})}}
\par
{\bkmkstart AAAAAAABDY}
{\bkmkend AAAAAAABDY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the character at offset index. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{The index to set (0 = first character)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i c} \cell }{The value to set the character to.\cell }
{\row }
}
If index is greater than the length of the string, nothing is done. In other words, you cannot use this to append to the string, only modify an existing character. \par
}{
Definition at line 514 of file spark_wiring_string.cpp.}\par
{
References buffer, and len.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   515 \{\par
  516     if (loc < len) buffer[loc] = c;\par
  517 \}\par
}
}
{\xe \v startsWith\:String}
{\xe \v String\:startsWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::startsWith (const {\b String} &  {\i prefix}) const}}
\par
{\bkmkstart AAAAAAABDZ}
{\bkmkend AAAAAAABDZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string starts with prefix (case-sensitive) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i prefix} \cell }{the string containing the string to test against\cell }
{\row }
}
Uses the C standard library function strcmp which is case-sensitive and may not work properly with UTF-8 characters. \par
}{
Definition at line 487 of file spark_wiring_string.cpp.}\par
{
References len, and startsWith().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   488 \{\par
  489     if (len < s2.len) return 0;\par
  490     return startsWith(s2, 0);\par
  491 \}\par
}
}
{\xe \v startsWith\:String}
{\xe \v String\:startsWith}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::startsWith (const {\b String} &  {\i prefix}, unsigned int  {\i offset}) const}}
\par
{\bkmkstart AAAAAAABEA}
{\bkmkend AAAAAAABEA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if this string contains prefix at specified offset (case-sensitive) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i prefix} \cell }{the string containing the string to test against\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i offset} \cell }{the offset to check at (0 = first characters)\cell }
{\row }
}
Uses the C standard library function strcmp which is case-sensitive and may not work properly with UTF-8 characters. \par
}{
Definition at line 493 of file spark_wiring_string.cpp.}\par
{
References buffer, and len.}\par
{
Referenced by startsWith().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   494 \{\par
  495     if (offset > len - s2.len || !buffer || !s2.buffer) return 0;\par
  496     return strncmp( &buffer[offset], s2.buffer, s2.len ) == 0;\par
  497 \}\par
}
}
{\xe \v StringIfHelper\:String}
{\xe \v String\:StringIfHelper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void String::StringIfHelper () const{\f2 [inline]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAABEB}
{\bkmkend AAAAAAABEB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 60 of file spark_wiring_string.h.}\par
{
Referenced by operator StringIfHelperType().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    60 \{\}\par
}
}
{\xe \v substring\:String}
{\xe \v String\:substring}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String} String::substring (unsigned int  {\i beginIndex}) const}}
\par
{\bkmkstart AAAAAAABEC}
{\bkmkend AAAAAAABEC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b String} object with a copy of the characters starting at beginIndex through the end of the string. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i beginIndex} \cell }{The index to start copying from, inclusive (0 = first byte, 1 = second byte, ...)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid A copy of the specified substring\par
}Note: If the {\b String} contains UTF-8 characters, beginIndex and endIndex are in bytes, not characters! It does not prevent splitting a UTF-8 multi-byte sequence. \par
}{
Definition at line 612 of file spark_wiring_string.cpp.}\par
{
References len, and substring().}\par
{
Referenced by readRFIDCard().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   613 \{\par
  614     return substring(left, len);\par
  615 \}\par
}
}
{\xe \v substring\:String}
{\xe \v String\:substring}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String} String::substring (unsigned int  {\i beginIndex}, unsigned int  {\i endIndex}) const}}
\par
{\bkmkstart AAAAAAABED}
{\bkmkend AAAAAAABED}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a {\b String} object with a copy of the characters in the specified range. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i beginIndex} \cell }{The index to start copying from, inclusive (0 = first byte, 1 = second byte, ...)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i endIndex} \cell }{The index to stop at, exclusive. The last character copied is the one before this one.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid A copy of the specified substring\par
}Note: If the {\b String} contains UTF-8 characters, beginIndex and endIndex are in bytes, not characters! It does not prevent splitting a UTF-8 multi-byte sequence. \par
}{
Definition at line 617 of file spark_wiring_string.cpp.}\par
{
References buffer, len, and operator=().}\par
{
Referenced by substring().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   618 \{\par
  619     if (left > right) \{\par
  620         unsigned int temp = right;\par
  621         right = left;\par
  622         left = temp;\par
  623     \}\par
  624     String out;\par
  625     if (left > len) return out;\par
  626     if (right > len) right = len;\par
  627     char temp = buffer[right];  // save the replaced character\par
  628     buffer[right] = '\\0';\par
  629     out = buffer + left;  // pointer arithmetic\par
  630     buffer[right] = temp;  //restore character\par
  631     return out;\par
  632 \}\par
}
}
{\xe \v toCharArray\:String}
{\xe \v String\:toCharArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void String::toCharArray (char *  {\i buf}, unsigned int  {\i bufsize}, unsigned int  {\i index} = {\f2 0}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEE}
{\bkmkend AAAAAAABEE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy the data out of this {\b String} into another buffer. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i buf} \cell }{The buffer to copy into\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bufsize} \cell }{The size of the buffer. The buffer will contain a null-terminted string so the maximum string length is bufsize - 1.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{The index to start copying from (0 = first character). Optional. Default is from 0, the start of the string.\cell }
{\row }
}
If bufsize is smaller than the string the string will be truncated and still null-terminated. If the string is truncated and UTF-8, it may break a multi-byte character sequence in the middle, resulting in invalid UTF-8. \par
}{
Definition at line 792 of file spark_wiring_string.h.}\par
{
References getBytes().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   793         \{getBytes((unsigned char *)buf, bufsize, index);\}\par
}
}
{\xe \v toFloat\:String}
{\xe \v String\:toFloat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float String::toFloat (void ) const}}
\par
{\bkmkstart AAAAAAABEF}
{\bkmkend AAAAAAABEF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts this string to a float (single precision floating point value) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid a float value or 0.0 if a parsing error occurs (not a float). \par
}}{
Definition at line 751 of file spark_wiring_string.cpp.}\par
{
References buffer.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   752 \{\par
  753     if (buffer) return float(atof(buffer));\par
  754     return 0;\par
  755 \}\par
}
}
{\xe \v toInt\:String}
{\xe \v String\:toInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
long String::toInt (void ) const}}
\par
{\bkmkstart AAAAAAABEG}
{\bkmkend AAAAAAABEG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts this string to a signed integer (32-bit) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid An integer value or 0 if a parsing error occurs (not an integer). \par
}}{
Definition at line 744 of file spark_wiring_string.cpp.}\par
{
References buffer.}\par
{
Referenced by maxCurrentC1(), and maxCurrentC2().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   745 \{\par
  746     if (buffer) return atol(buffer);\par
  747     return 0;\par
  748 \}\par
}
}
{\xe \v toLowerCase\:String}
{\xe \v String\:toLowerCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String} & String::toLowerCase (void )}}
\par
{\bkmkstart AAAAAAABEH}
{\bkmkend AAAAAAABEH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts this {\b String} to lower case, modifying it in place. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid this {\b String}, so you can chain multiple operations\par
}This is done using the C standard library function tolower() on each character. It only works with 7-bit ASCII characters and will corrupt UTF-8 data. \par
}{
Definition at line 707 of file spark_wiring_string.cpp.}\par
{
References buffer.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   708 \{\par
  709     if (buffer) \{\par
  710             for (char *p = buffer; *p; p++) \{\par
  711                     *p = tolower(*p);\par
  712             \}\par
  713         \}\par
  714         return *this;\par
  715 \}\par
}
}
{\xe \v toUpperCase\:String}
{\xe \v String\:toUpperCase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String} & String::toUpperCase (void )}}
\par
{\bkmkstart AAAAAAABEI}
{\bkmkend AAAAAAABEI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts this {\b String} to upper case, modifying it in place. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid this {\b String}, so you can chain multiple operations\par
}This is done using the C standard library function toupper() on each character. It only works with 7-bit ASCII characters and will corrupt UTF-8 data. \par
}{
Definition at line 717 of file spark_wiring_string.cpp.}\par
{
References buffer.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   718 \{\par
  719     if (buffer) \{\par
  720             for (char *p = buffer; *p; p++) \{\par
  721                     *p = toupper(*p);\par
  722             \}\par
  723         \}\par
  724         return *this;\par
  725 \}\par
}
}
{\xe \v trim\:String}
{\xe \v String\:trim}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String} & String::trim (void )}}
\par
{\bkmkstart AAAAAAABEJ}
{\bkmkend AAAAAAABEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes leading an trailing white spaces from this string, modifying it in place. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid this {\b String}, so you can chain multiple operations\par
}Whitespace is determined by the C standard library function isspace(). \par
}{
Definition at line 727 of file spark_wiring_string.cpp.}\par
{
References buffer, and len.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   728 \{\par
  729     if (!buffer || len == 0) return *this;\par
  730     char *begin = buffer;\par
  731     while (isspace(*begin)) begin++;\par
  732     char *end = buffer + len - 1;\par
  733     while (isspace(*end) && end >= begin) end--;\par
  734     len = end + 1 - begin;\par
  735     if (begin > buffer) memcpy(buffer, begin, len);\par
  736     buffer[len] = 0;\par
  737         return *this;\par
  738 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator+\:String}
{\xe \v String\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringSumHelper}& operator+ (const {\b StringSumHelper} &  {\i lhs}, const {\b String} &  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABEK}
{\bkmkend AAAAAAABEK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) a {\b String} to the end of lhs. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lhs} \cell }{The string to append to. {\b String} lhs is not modified.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rhs} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the combined string \par
}}{
Definition at line 359 of file spark_wiring_string.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   360 \{\par
  361     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);\par
  362     if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();\par
  363     return a;\par
  364 \}\par
}
}
{\xe \v operator+\:String}
{\xe \v String\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringSumHelper}& operator+ (const {\b StringSumHelper} &  {\i lhs}, const char *  {\i cstr}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABEL}
{\bkmkend AAAAAAABEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) a c-string (null-terminated) to the end of lhs. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lhs} \cell }{The string to append to. {\b String} lhs is not modified.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cstr} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the combined string \par
}}{
Definition at line 366 of file spark_wiring_string.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   367 \{\par
  368     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);\par
  369     if (!cstr || !a.concat(cstr, strlen(cstr))) a.invalidate();\par
  370     return a;\par
  371 \}\par
}
}
{\xe \v operator+\:String}
{\xe \v String\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringSumHelper}& operator+ (const {\b StringSumHelper} &  {\i lhs}, char  {\i c}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABEM}
{\bkmkend AAAAAAABEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the character c the end of lhs a. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lhs} \cell }{The string to append to. {\b String} lhs is not modified.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i c} \cell }{The character to append\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the combined string \par
}}{
Definition at line 373 of file spark_wiring_string.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   374 \{\par
  375     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);\par
  376     if (!a.concat(c)) a.invalidate();\par
  377     return a;\par
  378 \}\par
}
}
{\xe \v operator+\:String}
{\xe \v String\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringSumHelper}& operator+ (const {\b StringSumHelper} &  {\i lhs}, unsigned char  {\i num}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABEN}
{\bkmkend AAAAAAABEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the unsigned char num to the end of lhs as a decimal number (base 10) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lhs} \cell }{The string to append to. {\b String} lhs is not modified.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the combined string \par
}}{
Definition at line 380 of file spark_wiring_string.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   381 \{\par
  382     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);\par
  383     if (!a.concat(num)) a.invalidate();\par
  384     return a;\par
  385 \}\par
}
}
{\xe \v operator+\:String}
{\xe \v String\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringSumHelper}& operator+ (const {\b StringSumHelper} &  {\i lhs}, int  {\i num}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABEO}
{\bkmkend AAAAAAABEO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the signed int num to the end of lhs as a decimal number (base 10) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lhs} \cell }{The string to append to. {\b String} lhs is not modified.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the combined string \par
}}{
Definition at line 387 of file spark_wiring_string.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   388 \{\par
  389     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);\par
  390     if (!a.concat(num)) a.invalidate();\par
  391     return a;\par
  392 \}\par
}
}
{\xe \v operator+\:String}
{\xe \v String\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringSumHelper}& operator+ (const {\b StringSumHelper} &  {\i lhs}, unsigned int  {\i num}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABEP}
{\bkmkend AAAAAAABEP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the unsigned int num to the end of lhs as a decimal number (base 10) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lhs} \cell }{The string to append to. {\b String} lhs is not modified.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the combined string \par
}}{
Definition at line 394 of file spark_wiring_string.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   395 \{\par
  396     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);\par
  397     if (!a.concat(num)) a.invalidate();\par
  398     return a;\par
  399 \}\par
}
}
{\xe \v operator+\:String}
{\xe \v String\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringSumHelper}& operator+ (const {\b StringSumHelper} &  {\i lhs}, long  {\i num}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABEQ}
{\bkmkend AAAAAAABEQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the long integer num to the end of lhs as a decimal number (base 10) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lhs} \cell }{The string to append to. {\b String} lhs is not modified.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the combined string \par
}}{
Definition at line 401 of file spark_wiring_string.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   402 \{\par
  403     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);\par
  404     if (!a.concat(num)) a.invalidate();\par
  405     return a;\par
  406 \}\par
}
}
{\xe \v operator+\:String}
{\xe \v String\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringSumHelper}& operator+ (const {\b StringSumHelper} &  {\i lhs}, unsigned long  {\i num}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABER}
{\bkmkend AAAAAAABER}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the unsigned long integer to the end of lhs as a decimal number (base 10) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lhs} \cell }{The string to append to. {\b String} lhs is not modified.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the combined string \par
}}{
Definition at line 408 of file spark_wiring_string.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   409 \{\par
  410     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);\par
  411     if (!a.concat(num)) a.invalidate();\par
  412     return a;\par
  413 \}\par
}
}
{\xe \v operator+\:String}
{\xe \v String\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringSumHelper}& operator+ (const {\b StringSumHelper} &  {\i lhs}, float  {\i num}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABES}
{\bkmkend AAAAAAABES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the float num to the end of lhs as a decimal number (base 10) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lhs} \cell }{The string to append to. {\b String} lhs is not modified.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the combined string \par
}}{
Definition at line 415 of file spark_wiring_string.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   416 \{\par
  417     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);\par
  418     if (!a.concat(num)) a.invalidate();\par
  419     return a;\par
  420 \}\par
}
}
{\xe \v operator+\:String}
{\xe \v String\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringSumHelper}& operator+ (const {\b StringSumHelper} &  {\i lhs}, double  {\i num}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABET}
{\bkmkend AAAAAAABET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append (concatenate) the double precision float num to the end of lhs as a decimal number (base 10) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lhs} \cell }{The string to append to. {\b String} lhs is not modified.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the combined string \par
}}{
Definition at line 422 of file spark_wiring_string.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   423 \{\par
  424     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);\par
  425     if (!a.concat(num)) a.invalidate();\par
  426     return a;\par
  427 \}\par
}
}
{\xe \v StringPrintableHelper\:String}
{\xe \v String\:StringPrintableHelper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b StringPrintableHelper}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABEU}
{\bkmkend AAAAAAABEU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1078 of file spark_wiring_string.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v buffer\:String}
{\xe \v String\:buffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* String::buffer{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABEV}
{\bkmkend AAAAAAABEV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The buffer containing the data. It is always null-terminated. }}\par
{
Definition at line 1058 of file spark_wiring_string.h.}\par
{
Referenced by c_str(), changeBuffer(), compareTo(), concat(), copy(), endsWith(), equals(), equalsIgnoreCase(), format(), getBytes(), indexOf(), init(), invalidate(), lastIndexOf(), operator StringIfHelperType(), operator+(), operator=(), operator[](), remove(), replace(), reserve(), setCharAt(), startsWith(), substring(), toFloat(), toInt(), toLowerCase(), toUpperCase(), trim(), and ~String().}\par
}
{\xe \v capacity\:String}
{\xe \v String\:capacity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int String::capacity{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABEW}
{\bkmkend AAAAAAABEW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The capacity of the buffer. The longest string is one byte less than this. }}\par
{
Definition at line 1059 of file spark_wiring_string.h.}\par
{
Referenced by changeBuffer(), init(), invalidate(), replace(), and reserve().}\par
}
{\xe \v flags\:String}
{\xe \v String\:flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char String::flags{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABEX}
{\bkmkend AAAAAAABEX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unused, for future features. }}\par
{
Definition at line 1061 of file spark_wiring_string.h.}\par
{
Referenced by init().}\par
}
{\xe \v len\:String}
{\xe \v String\:len}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int String::len{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABEY}
{\bkmkend AAAAAAABEY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b String} length (not counting the null terminator). }}\par
{
Definition at line 1060 of file spark_wiring_string.h.}\par
{
Referenced by compareTo(), concat(), copy(), endsWith(), equals(), equalsIgnoreCase(), format(), getBytes(), indexOf(), init(), invalidate(), lastIndexOf(), length(), operator+(), operator=(), operator[](), remove(), replace(), reserve(), setCharAt(), startsWith(), substring(), and trim().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/docs/src/{\b spark_wiring_string.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/test/gcclib/{\b spark_wiring_string.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
StringPrintableHelper Class Reference\par \pard\plain 
{\tc\tcl2 \v StringPrintableHelper}
{\xe \v StringPrintableHelper}
{\bkmkstart AAAAAAABEZ}
{\bkmkend AAAAAAABEZ}
Inheritance diagram for StringPrintableHelper:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_string_printable_helper__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for StringPrintableHelper:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_string_printable_helper__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringPrintableHelper} ({\b String} &s_)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual size_t {\b write} (const uint8_t *buffer, size_t size) override\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual size_t {\b write} (uint8_t c) override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} & {\b s}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 757 of file spark_wiring_string.cpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v StringPrintableHelper\:StringPrintableHelper}
{\xe \v StringPrintableHelper\:StringPrintableHelper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
StringPrintableHelper::StringPrintableHelper ({\b String} &  {\i s_}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFA}
{\bkmkend AAAAAAABFA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 763 of file spark_wiring_string.cpp.}\par
{
References String::reserve(), and s.}\par
{
Referenced by String::String().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   763                                       : s(s_) \{\par
  764         s.reserve(20);\par
  765     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v write\:StringPrintableHelper}
{\xe \v StringPrintableHelper\:write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual size_t StringPrintableHelper::write (const uint8_t *  {\i buffer}, size_t  {\i size}){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b Print} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 767 of file spark_wiring_string.cpp.}\par
{
References String::concat(), String::length(), and s.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   768     \{\par
  769         unsigned len = s.length();\par
  770         s.concat((const char*)buffer, size);\par
  771         return s.length()-len;\par
  772     \}\par
}
}
{\xe \v write\:StringPrintableHelper}
{\xe \v StringPrintableHelper\:write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual size_t StringPrintableHelper::write (uint8_t  {\i c}){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b Print} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZN \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line 774 of file spark_wiring_string.cpp.}\par
{
References String::concat(), and s.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   775     \{\par
  776         return s.concat((char)c);\par
  777     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v s\:StringPrintableHelper}
{\xe \v StringPrintableHelper\:s}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String}& StringPrintableHelper::s{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABFB}
{\bkmkend AAAAAAABFB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 759 of file spark_wiring_string.cpp.}\par
{
Referenced by StringPrintableHelper(), and write().}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/test/gcclib/{\b spark_wiring_string.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
StringSumHelper Class Reference\par \pard\plain 
{\tc\tcl2 \v StringSumHelper}
{\xe \v StringSumHelper}
{\bkmkstart AAAAAAABFC}
{\bkmkend AAAAAAABFC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class used when appending mutiple {\b String} and other values using +. }}\par
{
{\f2 #include <spark_wiring_string.h>}}\par
Inheritance diagram for StringSumHelper:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_string_sum_helper__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for StringSumHelper:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_string_sum_helper__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} (const {\b String} &s)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append a {\b String} object. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} (const char *p)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append a const char * (c-string, null terminated) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} (char c)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append a single character. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} (unsigned char num)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append a byte as a decimal number 0 - 255. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} (int num)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append a 32-bit signed integer as a decimal number. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} (unsigned int num)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append a 32-bit unsigned integer as a decimal number. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} (long num)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append a 32-bit long integer as a decimal number. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} (unsigned long num)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append a 32-bit unsigned long as a decimal number. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class used when appending mutiple {\b String} and other values using +. \par
}{
Definition at line 1085 of file spark_wiring_string.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v StringSumHelper\:StringSumHelper}
{\xe \v StringSumHelper\:StringSumHelper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
StringSumHelper::StringSumHelper (const {\b String} &  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFD}
{\bkmkend AAAAAAABFD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append a {\b String} object. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i s} \cell }{The string to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b StringSumHelper} object that encapsulates a copy of that string for appending to another string. \par
}}{
Definition at line 1095 of file spark_wiring_string.h.}\par
{
References String::String().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1095 : String(s) \{\}\par
}
}
{\xe \v StringSumHelper\:StringSumHelper}
{\xe \v StringSumHelper\:StringSumHelper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
StringSumHelper::StringSumHelper (const char *  {\i p}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFE}
{\bkmkend AAAAAAABFE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append a const char * (c-string, null terminated) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i p} \cell }{The string to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b StringSumHelper} object that encapsulates a copy of that string for appending to another string. \par
}}{
Definition at line 1104 of file spark_wiring_string.h.}\par
{
References String::String().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1104 : String(p) \{\}\par
}
}
{\xe \v StringSumHelper\:StringSumHelper}
{\xe \v StringSumHelper\:StringSumHelper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
StringSumHelper::StringSumHelper (char  {\i c}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFF}
{\bkmkend AAAAAAABFF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append a single character. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i c} \cell }{The character to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b StringSumHelper} object that encapsulates a copy of that character for appending to another string. \par
}}{
Definition at line 1113 of file spark_wiring_string.h.}\par
{
References String::String().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1113 : String(c) \{\}\par
}
}
{\xe \v StringSumHelper\:StringSumHelper}
{\xe \v StringSumHelper\:StringSumHelper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
StringSumHelper::StringSumHelper (unsigned char  {\i num}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFG}
{\bkmkend AAAAAAABFG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append a byte as a decimal number 0 - 255. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The byte value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b StringSumHelper} object that encapsulates the textual representation of the number for appending to another string. \par
}}{
Definition at line 1122 of file spark_wiring_string.h.}\par
{
References String::String().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1122 : String(num) \{\}\par
}
}
{\xe \v StringSumHelper\:StringSumHelper}
{\xe \v StringSumHelper\:StringSumHelper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
StringSumHelper::StringSumHelper (int  {\i num}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFH}
{\bkmkend AAAAAAABFH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append a 32-bit signed integer as a decimal number. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The byte value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b StringSumHelper} object that encapsulates the textual representation of the number for appending to another string. \par
}}{
Definition at line 1131 of file spark_wiring_string.h.}\par
{
References String::String().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1131 : String(num) \{\}\par
}
}
{\xe \v StringSumHelper\:StringSumHelper}
{\xe \v StringSumHelper\:StringSumHelper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
StringSumHelper::StringSumHelper (unsigned int  {\i num}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFI}
{\bkmkend AAAAAAABFI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append a 32-bit unsigned integer as a decimal number. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The byte value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b StringSumHelper} object that encapsulates the textual representation of the number for appending to another string. \par
}}{
Definition at line 1140 of file spark_wiring_string.h.}\par
{
References String::String().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1140 : String(num) \{\}\par
}
}
{\xe \v StringSumHelper\:StringSumHelper}
{\xe \v StringSumHelper\:StringSumHelper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
StringSumHelper::StringSumHelper (long  {\i num}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFJ}
{\bkmkend AAAAAAABFJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append a 32-bit long integer as a decimal number. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The byte value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b StringSumHelper} object that encapsulates the textual representation of the number for appending to another string. \par
}}{
Definition at line 1149 of file spark_wiring_string.h.}\par
{
References String::String().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1149 : String(num) \{\}\par
}
}
{\xe \v StringSumHelper\:StringSumHelper}
{\xe \v StringSumHelper\:StringSumHelper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
StringSumHelper::StringSumHelper (unsigned long  {\i num}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFK}
{\bkmkend AAAAAAABFK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Append a 32-bit unsigned long as a decimal number. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The byte value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b StringSumHelper} object that encapsulates the textual representation of the number for appending to another string. \par
}}{
Definition at line 1158 of file spark_wiring_string.h.}\par
{
References String::String().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1158 : String(num) \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/JsonParserGeneratorRK/docs/src/{\b spark_wiring_string.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MFRC522::Uid Struct Reference\par \pard\plain 
{\tc\tcl2 \v MFRC522::Uid}
{\xe \v MFRC522::Uid}
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
\par
{
{\f2 #include <MFRC522.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b size}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b uidByte} [10]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte {\b sak}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line 254 of file MFRC522.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v sak\:MFRC522::Uid}
{\xe \v MFRC522::Uid\:sak}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::Uid::sak}}
\par
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 257 of file MFRC522.h.}\par
}
{\xe \v size\:MFRC522::Uid}
{\xe \v MFRC522::Uid\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::Uid::size}}
\par
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 255 of file MFRC522.h.}\par
}
{\xe \v uidByte\:MFRC522::Uid}
{\xe \v MFRC522::Uid\:uidByte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
byte MFRC522::Uid::uidByte[10]}}
\par
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 256 of file MFRC522.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
lib/MFRC522/src/{\b MFRC522.h}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/JsonParserGeneratorRK/docs/src/spark_wiring_print.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/JsonParserGeneratorRK/docs/src/spark_wiring_print.h}
{\xe \v lib/JsonParserGeneratorRK/docs/src/spark_wiring_print.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include "spark_wiring_string.h"}\par
{\f2 #include "spark_wiring_printable.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for spark_wiring_print.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "docs_2src_2spark__wiring__print_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "docs_2src_2spark__wiring__print_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Print}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for printing to a stream or file. }}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __SPARK_WIRING_PRINT_}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned char {\b DEC} = 10\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Decimal number format (0-9) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned char {\b HEX} = 16\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Hexadecimal number format (0-9, a-f) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned char {\b OCT} = 8\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Octal number format (0-7) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned char {\b BIN} = 2\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Binary number format (0-1) }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v __SPARK_WIRING_PRINT_\:docs/src/spark_wiring_print.h}
{\xe \v docs/src/spark_wiring_print.h\:__SPARK_WIRING_PRINT_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __SPARK_WIRING_PRINT_}}
\par
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file spark_wiring_print.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v BIN\:docs/src/spark_wiring_print.h}
{\xe \v docs/src/spark_wiring_print.h\:BIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char BIN = 2}}
\par
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Binary number format (0-1) }}\par
{
Definition at line 40 of file spark_wiring_print.h.}\par
}
{\xe \v DEC\:docs/src/spark_wiring_print.h}
{\xe \v docs/src/spark_wiring_print.h\:DEC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char DEC = 10}}
\par
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Decimal number format (0-9) }}\par
{
Definition at line 37 of file spark_wiring_print.h.}\par
{
Referenced by String::concat().}\par
}
{\xe \v HEX\:docs/src/spark_wiring_print.h}
{\xe \v docs/src/spark_wiring_print.h\:HEX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char HEX = 16}}
\par
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Hexadecimal number format (0-9, a-f) }}\par
{
Definition at line 38 of file spark_wiring_print.h.}\par
}
{\xe \v OCT\:docs/src/spark_wiring_print.h}
{\xe \v docs/src/spark_wiring_print.h\:OCT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char OCT = 8}}
\par
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Octal number format (0-7) }}\par
{
Definition at line 39 of file spark_wiring_print.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/JsonParserGeneratorRK/test/gcclib/spark_wiring_print.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/JsonParserGeneratorRK/test/gcclib/spark_wiring_print.h}
{\xe \v lib/JsonParserGeneratorRK/test/gcclib/spark_wiring_print.h}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <stdint.h>}\par
{\f2 #include "spark_wiring_string.h"}\par
{\f2 #include "spark_wiring_printable.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for spark_wiring_print.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "test_2gcclib_2spark__wiring__print_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "test_2gcclib_2spark__wiring__print_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Print}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for printing to a stream or file. }}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned char {\b DEC} = 10\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned char {\b HEX} = 16\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned char {\b OCT} = 8\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned char {\b BIN} = 2\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v BIN\:test/gcclib/spark_wiring_print.h}
{\xe \v test/gcclib/spark_wiring_print.h\:BIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char BIN = 2}}
\par
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 40 of file spark_wiring_print.h.}\par
}
{\xe \v DEC\:test/gcclib/spark_wiring_print.h}
{\xe \v test/gcclib/spark_wiring_print.h\:DEC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char DEC = 10}}
\par
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file spark_wiring_print.h.}\par
}
{\xe \v HEX\:test/gcclib/spark_wiring_print.h}
{\xe \v test/gcclib/spark_wiring_print.h\:HEX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char HEX = 16}}
\par
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file spark_wiring_print.h.}\par
}
{\xe \v OCT\:test/gcclib/spark_wiring_print.h}
{\xe \v test/gcclib/spark_wiring_print.h\:OCT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char OCT = 8}}
\par
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file spark_wiring_print.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/JsonParserGeneratorRK/docs/src/spark_wiring_printable.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/JsonParserGeneratorRK/docs/src/spark_wiring_printable.h}
{\xe \v lib/JsonParserGeneratorRK/docs/src/spark_wiring_printable.h}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for spark_wiring_printable.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "docs_2src_2spark__wiring__printable_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "docs_2src_2spark__wiring__printable_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Printable}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Printable} class provides a way for new classes to allow themselves to be printed. }}}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/JsonParserGeneratorRK/test/gcclib/spark_wiring_printable.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/JsonParserGeneratorRK/test/gcclib/spark_wiring_printable.h}
{\xe \v lib/JsonParserGeneratorRK/test/gcclib/spark_wiring_printable.h}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stddef.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for spark_wiring_printable.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "test_2gcclib_2spark__wiring__printable_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "test_2gcclib_2spark__wiring__printable_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Printable}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Printable} class provides a way for new classes to allow themselves to be printed. }}}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/JsonParserGeneratorRK/docs/src/spark_wiring_string.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/JsonParserGeneratorRK/docs/src/spark_wiring_string.h}
{\xe \v lib/JsonParserGeneratorRK/docs/src/spark_wiring_string.h}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdarg.h>}\par
{\f2 #include "spark_wiring_print.h"}\par
{\f2 #include "spark_wiring_printable.h"}\par
{\f2 #include <ostream>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for spark_wiring_string.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "docs_2src_2spark__wiring__string_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "docs_2src_2spark__wiring__string_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b String}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wiring {\b String}: A class to hold and manipulate a dynamically allocated string. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b StringSumHelper}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class used when appending mutiple {\b String} and other values using +. }}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b F}(X)\~ (X)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &os, const {\b String} &value)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v F\:docs/src/spark_wiring_string.h}
{\xe \v docs/src/spark_wiring_string.h\:F}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define F( X)\~ (X)}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file spark_wiring_string.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v operator<<\:docs/src/spark_wiring_string.h}
{\xe \v docs/src/spark_wiring_string.h\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream& operator<< (std::ostream &  {\i os}, const {\b String} &  {\i value})}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 807 of file spark_wiring_string.cpp.}\par
{
References String::c_str().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   807                                                                 \{\par
  808     os << '"' << value.c_str() << '"';\par
  809     return os;\par
  810 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/JsonParserGeneratorRK/test/gcclib/spark_wiring_string.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/JsonParserGeneratorRK/test/gcclib/spark_wiring_string.h}
{\xe \v lib/JsonParserGeneratorRK/test/gcclib/spark_wiring_string.h}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "test_2gcclib_2spark__wiring__string_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/JsonParserGeneratorRK/examples/1-parser/1-parser-JsonParserGeneratorRK.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v lib/JsonParserGeneratorRK/examples/1-parser/1-parser-JsonParserGeneratorRK.cpp}
{\xe \v lib/JsonParserGeneratorRK/examples/1-parser/1-parser-JsonParserGeneratorRK.cpp}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Particle.h"}\par
{\f2 #include "JsonParserGeneratorRK.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for 1-parser-JsonParserGeneratorRK.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "1-parser-_json_parser_generator_r_k_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b runTest} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setup} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inital setup for pin assignments and serial links start. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b loop} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Main running function that executes all other functions; runs over 5times/second. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned long {\b TEST_RUN_PERIOD_MS} = 10000\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b lastRun} = 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char *const {\b test2} = "\{\\"t1\\":\\"abc\\",\\"t2\\":1234,\\"t3\\":1234.5,\\"t4\\":true,\\"t5\\":false,\\"t6\\":null, \\"t7\\" : \\"\\\\\\"quoted\\\\\\"\\" \} "\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonParserStatic}< 256, 20 > {\b parser1}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v loop\:1-parser-JsonParserGeneratorRK.cpp}
{\xe \v 1-parser-JsonParserGeneratorRK.cpp\:loop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void loop ()}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Main running function that executes all other functions; runs over 5times/second. }}\par
{
Definition at line 19 of file 1-parser-JsonParserGeneratorRK.cpp.}\par
{
References runTest().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    19             \{\par
   20     if (millis() - lastRun >= TEST_RUN_PERIOD_MS) \{\par
   21         lastRun = millis();\par
   22         runTest();\par
   23     \}\par
   24 \}\par
}
}
{\xe \v runTest\:1-parser-JsonParserGeneratorRK.cpp}
{\xe \v 1-parser-JsonParserGeneratorRK.cpp\:runTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void runTest ()}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file 1-parser-JsonParserGeneratorRK.cpp.}\par
{
References JsonBuffer::addString(), JsonBuffer::clear(), JsonParser::getOuterKeyValueByIndex(), JsonParser::getOuterValueByKey(), String::operator!=(), JsonParser::parse(), parser1, and test2.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    26                \{\par
   27     // Clear the parser state, add the string test2, and parse it\par
   28     parser1.clear();\par
   29     parser1.addString(test2);\par
   30     if (!parser1.parse()) \{\par
   31         Serial.println("parsing failed test2");\par
   32         return;\par
   33     \}\par
   34 \par
   35     String strValue;\par
   36     if (!parser1.getOuterValueByKey("t1", strValue)) \{\par
   37         Serial.println("failed to get test2 t1");\par
   38         return;\par
   39     \}\par
   40     if (strValue != "abc") \{\par
   41         Serial.printlnf("wrong value test2 t1 was %s", strValue.c_str());\par
   42         return;\par
   43     \}\par
   44 \par
   45     String keyName;\par
   46     if (!parser1.getOuterKeyValueByIndex(0, keyName, strValue)) \{\par
   47         Serial.println("failed to get test2 t1 by index");\par
   48         return;\par
   49     \}\par
   50     if (keyName != "t1") \{\par
   51         Serial.printlnf("wrong key name test2 t1 was %s by index", keyName.c_str());\par
   52         return;\par
   53     \}\par
   54     if (strValue != "abc") \{\par
   55         Serial.printlnf("wrong value test2 t1 was %s by index", strValue.c_str());\par
   56         return;\par
   57     \}\par
   58 \par
   59     int intValue;\par
   60     if (!parser1.getOuterValueByKey("t2", intValue)) \{\par
   61         Serial.println("failed to get test2 t2");\par
   62         return;\par
   63     \}\par
   64     if (intValue != 1234) \{\par
   65         Serial.printlnf("wrong value test2 t2 was %d", intValue);\par
   66         return;\par
   67     \}\par
   68     intValue = -1;\par
   69 \par
   70     if (!parser1.getOuterKeyValueByIndex(1, keyName, intValue)) \{\par
   71         Serial.println("failed to get test2 t2 by index");\par
   72         return;\par
   73     \}\par
   74     if (keyName != "t2") \{\par
   75         Serial.printlnf("wrong key name test2 t2 was %s by index", keyName.c_str());\par
   76         return;\par
   77     \}\par
   78     if (intValue != 1234) \{\par
   79         Serial.printlnf("wrong value test2 t2 was %d by index", intValue);\par
   80         return;\par
   81     \}\par
   82 \par
   83 \par
   84     float floatValue;\par
   85     if (!parser1.getOuterValueByKey("t3", floatValue)) \{\par
   86         Serial.println("failed to get test2 t3");\par
   87         return;\par
   88     \}\par
   89     if (floatValue != 1234.5) \{\par
   90         Serial.printlnf("wrong value test2 t3 was %f", floatValue);\par
   91         return;\par
   92     \}\par
   93 \par
   94     bool boolValue;\par
   95     if (!parser1.getOuterValueByKey("t4", boolValue)) \{\par
   96         Serial.println("failed to get test2 t4");\par
   97         return;\par
   98     \}\par
   99     if (boolValue != true) \{\par
  100         Serial.printlnf("wrong value test2 t4 was %d", boolValue);\par
  101         return;\par
  102     \}\par
  103 \par
  104     if (!parser1.getOuterValueByKey("t5", boolValue)) \{\par
  105         Serial.println("failed to get test2 t5");\par
  106         return;\par
  107     \}\par
  108     if (boolValue != false) \{\par
  109         Serial.printlnf("wrong value test2 t5 was %d", boolValue);\par
  110         return;\par
  111     \}\par
  112 \par
  113 \par
  114     if (!parser1.getOuterValueByKey("t7", strValue)) \{\par
  115         Serial.println("failed to get test2 t7");\par
  116         return;\par
  117     \}\par
  118     if (strValue != "\\"quoted\\"") \{\par
  119         Serial.printlnf("wrong value test2 75 was %s", strValue.c_str());\par
  120         return;\par
  121     \}\par
  122 \par
  123     Serial.println("test passed!");\par
  124 \}\par
}
}
{\xe \v setup\:1-parser-JsonParserGeneratorRK.cpp}
{\xe \v 1-parser-JsonParserGeneratorRK.cpp\:setup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setup ()}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inital setup for pin assignments and serial links start. }}\par
{
Definition at line 15 of file 1-parser-JsonParserGeneratorRK.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    15              \{\par
   16     Serial.begin(9600);\par
   17 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v lastRun\:1-parser-JsonParserGeneratorRK.cpp}
{\xe \v 1-parser-JsonParserGeneratorRK.cpp\:lastRun}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long lastRun = 0}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6 of file 1-parser-JsonParserGeneratorRK.cpp.}\par
}
{\xe \v parser1\:1-parser-JsonParserGeneratorRK.cpp}
{\xe \v 1-parser-JsonParserGeneratorRK.cpp\:parser1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b JsonParserStatic}<256, 20> parser1}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file 1-parser-JsonParserGeneratorRK.cpp.}\par
{
Referenced by runTest().}\par
}
{\xe \v test2\:1-parser-JsonParserGeneratorRK.cpp}
{\xe \v 1-parser-JsonParserGeneratorRK.cpp\:test2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* const test2 = "\{\\"t1\\":\\"abc\\",\\"t2\\":1234,\\"t3\\":1234.5,\\"t4\\":true,\\"t5\\":false,\\"t6\\":null, \\"t7\\" : \\"\\\\\\"quoted\\\\\\"\\" \} "}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file 1-parser-JsonParserGeneratorRK.cpp.}\par
{
Referenced by runTest().}\par
}
{\xe \v TEST_RUN_PERIOD_MS\:1-parser-JsonParserGeneratorRK.cpp}
{\xe \v 1-parser-JsonParserGeneratorRK.cpp\:TEST_RUN_PERIOD_MS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned long TEST_RUN_PERIOD_MS = 10000}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 5 of file 1-parser-JsonParserGeneratorRK.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/JsonParserGeneratorRK/examples/2-generator/2-generator-JsonParserGeneratorRK.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v lib/JsonParserGeneratorRK/examples/2-generator/2-generator-JsonParserGeneratorRK.cpp}
{\xe \v lib/JsonParserGeneratorRK/examples/2-generator/2-generator-JsonParserGeneratorRK.cpp}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Particle.h"}\par
{\f2 #include "JsonParserGeneratorRK.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for 2-generator-JsonParserGeneratorRK.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "2-generator-_json_parser_generator_r_k_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b runTest} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setup} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b loop} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned long {\b TEST_RUN_PERIOD_MS} = 10000\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b lastRun} = 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v loop\:2-generator-JsonParserGeneratorRK.cpp}
{\xe \v 2-generator-JsonParserGeneratorRK.cpp\:loop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void loop ()}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file 2-generator-JsonParserGeneratorRK.cpp.}\par
{
References runTest().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    15             \{\par
   16     if (millis() - lastRun >= TEST_RUN_PERIOD_MS) \{\par
   17         lastRun = millis();\par
   18         runTest();\par
   19     \}\par
   20 \}\par
}
}
{\xe \v runTest\:2-generator-JsonParserGeneratorRK.cpp}
{\xe \v 2-generator-JsonParserGeneratorRK.cpp\:runTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void runTest ()}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 22 of file 2-generator-JsonParserGeneratorRK.cpp.}\par
{
References JsonBuffer::getBuffer(), JsonWriter::insertKeyValue(), and JsonWriterAutoObject::JsonWriterAutoObject().}\par
{
Referenced by loop().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    22                \{\par
   23     // This creates a buffer to hold up to 256 bytes of JSON data (good for Particle.publish)\par
   24     JsonWriterStatic<256> jw;\par
   25 \par
   26     // Creating a scope like this in \{\} with a JsonWriterAutoObject in it creates an object,\par
   27     // and automatically closes the object when leaving the scope. This is necessary because\par
   28     // all JSON values must be in either an object or an array to be valid, and JsonWriter\par
   29     // requires all startObject to be balanced with a finishObjectOrArray and JsonWriterAutoObject\par
   30     // takes care of doing that automatically.\par
   31     \{\par
   32         JsonWriterAutoObject obj(&jw);\par
   33 \par
   34         // Add various types of data\par
   35         jw.insertKeyValue("a", true);\par
   36         jw.insertKeyValue("b", 1234);\par
   37         jw.insertKeyValue("c", "test");\par
   38     \}\par
   39 \par
   40     // Verify the results\par
   41     if (strcmp(jw.getBuffer(), "\{\\"a\\":true,\\"b\\":1234,\\"c\\":\\"test\\"\}")) \{\par
   42         Serial.printlnf("test mismatch got %s", jw.getBuffer());\par
   43         return;\par
   44     \}\par
   45 \par
   46 \par
   47     Serial.println("test passed!");\par
   48 \}\par
}
}
{\xe \v setup\:2-generator-JsonParserGeneratorRK.cpp}
{\xe \v 2-generator-JsonParserGeneratorRK.cpp\:setup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setup ()}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 11 of file 2-generator-JsonParserGeneratorRK.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    11              \{\par
   12     Serial.begin(9600);\par
   13 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v lastRun\:2-generator-JsonParserGeneratorRK.cpp}
{\xe \v 2-generator-JsonParserGeneratorRK.cpp\:lastRun}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long lastRun = 0}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6 of file 2-generator-JsonParserGeneratorRK.cpp.}\par
}
{\xe \v TEST_RUN_PERIOD_MS\:2-generator-JsonParserGeneratorRK.cpp}
{\xe \v 2-generator-JsonParserGeneratorRK.cpp\:TEST_RUN_PERIOD_MS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned long TEST_RUN_PERIOD_MS = 10000}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 5 of file 2-generator-JsonParserGeneratorRK.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/JsonParserGeneratorRK/examples/3-subscription/3-subscription-JsonParserGeneratorRK.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v lib/JsonParserGeneratorRK/examples/3-subscription/3-subscription-JsonParserGeneratorRK.cpp}
{\xe \v lib/JsonParserGeneratorRK/examples/3-subscription/3-subscription-JsonParserGeneratorRK.cpp}
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Particle.h"}\par
{\f2 #include "JsonParserGeneratorRK.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for 3-subscription-JsonParserGeneratorRK.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "3-subscription-_json_parser_generator_r_k_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b subscriptionHandler} (const char *event, const char *data)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printJson} ({\b JsonParser} &jp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setup} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b loop} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printIndent} (size_t indent)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printString} (const char *str)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printJsonInner} ({\b JsonParser} &jp, const {\b JsonParserGeneratorRK::jsmntok_t} *container, size_t indent)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JsonParserStatic}< 2048, 100 > {\b jsonParser}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v loop\:3-subscription-JsonParserGeneratorRK.cpp}
{\xe \v 3-subscription-JsonParserGeneratorRK.cpp\:loop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void loop ()}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 22 of file 3-subscription-JsonParserGeneratorRK.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    22             \{\par
   23 \}\par
}
}
{\xe \v printIndent\:3-subscription-JsonParserGeneratorRK.cpp}
{\xe \v 3-subscription-JsonParserGeneratorRK.cpp\:printIndent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void printIndent (size_t  {\i indent})}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file 3-subscription-JsonParserGeneratorRK.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    47                                 \{\par
   48     for(size_t ii = 0; ii < 2 * indent; ii++) \{\par
   49         Serial.printf(" ");\par
   50     \}\par
   51 \}\par
}
}
{\xe \v printJson\:3-subscription-JsonParserGeneratorRK.cpp}
{\xe \v 3-subscription-JsonParserGeneratorRK.cpp\:printJson}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void printJson ({\b JsonParser} &  {\i jp})}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 149 of file 3-subscription-JsonParserGeneratorRK.cpp.}\par
{
References JsonParser::getOuterToken(), and printJsonInner().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   149                                \{\par
  150     printJsonInner(jp, jp.getOuterToken(), 0);\par
  151 \}\par
}
}
{\xe \v printJsonInner\:3-subscription-JsonParserGeneratorRK.cpp}
{\xe \v 3-subscription-JsonParserGeneratorRK.cpp\:printJsonInner}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void printJsonInner ({\b JsonParser} &  {\i jp}, const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i container}, size_t  {\i indent})}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 75 of file 3-subscription-JsonParserGeneratorRK.cpp.}\par
{
References JsonParserGeneratorRK::jsmntok_t::end, JsonParser::getKeyValueTokenByIndex(), JsonParser::getTokenValue(), JsonParser::getValueTokenByIndex(), JsonParserGeneratorRK::JSMN_ARRAY, JsonParserGeneratorRK::JSMN_OBJECT, JsonParserGeneratorRK::JSMN_PRIMITIVE, JsonParserGeneratorRK::JSMN_STRING, JsonParserGeneratorRK::JSMN_UNDEFINED, printIndent(), printJsonInner(), printString(), JsonParserGeneratorRK::jsmntok_t::start, and JsonParserGeneratorRK::jsmntok_t::type.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    75                                                                                                     \{\par
   76 \par
   77     switch(container->type) \{\par
   78     case JsonParserGeneratorRK::JSMN_OBJECT: \{\par
   79         printIndent(indent);\par
   80         Serial.printf("\{\\n");\par
   81 \par
   82         for(size_t ii = 0; ; ii++) \{\par
   83             const JsonParserGeneratorRK::jsmntok_t *keyToken;\par
   84             const JsonParserGeneratorRK::jsmntok_t *valueToken;\par
   85 \par
   86             if (!jp.getKeyValueTokenByIndex(container, keyToken, valueToken, ii)) \{\par
   87                 break;\par
   88             \}\par
   89             if (ii > 0) \{\par
   90                 Serial.printf(",\\n");\par
   91             \}\par
   92 \par
   93             String keyName;\par
   94             jp.getTokenValue(keyToken, keyName);\par
   95 \par
   96             printIndent(indent + 1);\par
   97             printString(keyName);\par
   98             Serial.printf(":");\par
   99             printJsonInner(jp, valueToken, indent + 1);\par
  100         \}\par
  101         Serial.printf("\\n");\par
  102         printIndent(indent);\par
  103         Serial.printf("\}\\n");\par
  104         break;\par
  105     \}\par
  106     case JsonParserGeneratorRK::JSMN_ARRAY: \{\par
  107         printIndent(indent);\par
  108         Serial.printf("[\\n");\par
  109 \par
  110         for(size_t ii = 0; ; ii++) \{\par
  111             const JsonParserGeneratorRK::jsmntok_t *valueToken;\par
  112 \par
  113             if (!jp.getValueTokenByIndex(container, ii, valueToken)) \{\par
  114                 break;\par
  115             \}\par
  116             if (ii > 0) \{\par
  117                 Serial.printf(",\\n");\par
  118             \}\par
  119             printIndent(indent + 1);\par
  120             printJsonInner(jp, valueToken, indent + 1);\par
  121         \}\par
  122         Serial.printf("\\n");\par
  123         printIndent(indent);\par
  124         Serial.printf("]\\n");\par
  125         break;\par
  126     \}\par
  127     case JsonParserGeneratorRK::JSMN_STRING: \{\par
  128         Serial.printf("\\"");\par
  129         for(int ii = container->start; ii < container->end; ii++) \{\par
  130             Serial.printf("%c", jp.getBuffer()[ii]);\par
  131         \}\par
  132         Serial.printf("\\"");\par
  133         break;\par
  134     \}\par
  135     case JsonParserGeneratorRK::JSMN_PRIMITIVE: \{\par
  136         for(int ii = container->start; ii < container->end; ii++) \{\par
  137             Serial.printf("%c", jp.getBuffer()[ii]);\par
  138         \}\par
  139         break;\par
  140     \}\par
  141     case JsonParserGeneratorRK::JSMN_UNDEFINED:\par
  142     default: \{\par
  143         break;\par
  144     \}\par
  145     \}\par
  146 \par
  147 \}\par
}
}
{\xe \v printString\:3-subscription-JsonParserGeneratorRK.cpp}
{\xe \v 3-subscription-JsonParserGeneratorRK.cpp\:printString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void printString (const char *  {\i str})}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 53 of file 3-subscription-JsonParserGeneratorRK.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    53                                   \{\par
   54     Serial.printf("\\"");\par
   55 \par
   56     for(size_t ii = 0; str[ii]; ii++) \{\par
   57         if (str[ii] == '"') \{\par
   58             Serial.printf("\\\\\\"");\par
   59         \}\par
   60         else\par
   61         if (str[ii] == '\\\\') \{\par
   62             Serial.printf("\\\\\\\\");\par
   63         \}\par
   64         else\par
   65         if (str[ii] >= 32 && str[ii] < 127) \{\par
   66             Serial.printf("%c", str[ii]);\par
   67         \}\par
   68         else \{\par
   69             Serial.printf("\\\\x%02x", str[ii]);\par
   70         \}\par
   71     \}\par
   72     Serial.printf("\\"");\par
   73 \}\par
}
}
{\xe \v setup\:3-subscription-JsonParserGeneratorRK.cpp}
{\xe \v 3-subscription-JsonParserGeneratorRK.cpp\:setup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setup ()}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 17 of file 3-subscription-JsonParserGeneratorRK.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    17              \{\par
   18     Serial.begin(9600);\par
   19     Particle.subscribe("jsonParserTest", subscriptionHandler, MY_DEVICES);\par
   20 \}\par
}
}
{\xe \v subscriptionHandler\:3-subscription-JsonParserGeneratorRK.cpp}
{\xe \v 3-subscription-JsonParserGeneratorRK.cpp\:subscriptionHandler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void subscriptionHandler (const char *  {\i event}, const char *  {\i data})}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 25 of file 3-subscription-JsonParserGeneratorRK.cpp.}\par
{
References JsonBuffer::addString(), JsonBuffer::clear(), jsonParser, JsonParser::parse(), and printJson().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    25                                                               \{\par
   26     int responseIndex = 0;\par
   27 \par
   28     const char *slashOffset = strrchr(event, '/');\par
   29     if (slashOffset) \{\par
   30         responseIndex = atoi(slashOffset + 1);\par
   31     \}\par
   32 \par
   33     if (responseIndex == 0) \{\par
   34         jsonParser.clear();\par
   35     \}\par
   36     jsonParser.addString(data);\par
   37 \par
   38     if (jsonParser.parse()) \{\par
   39         // Looks valid (we received all parts)\par
   40 \par
   41         // This printing thing is just for testing purposes, you should use the commands to\par
   42         // process data\par
   43         printJson(jsonParser);\par
   44     \}\par
   45 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v jsonParser\:3-subscription-JsonParserGeneratorRK.cpp}
{\xe \v 3-subscription-JsonParserGeneratorRK.cpp\:jsonParser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b JsonParserStatic}<2048, 100> jsonParser}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file 3-subscription-JsonParserGeneratorRK.cpp.}\par
{
Referenced by subscriptionHandler().}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/JsonParserGeneratorRK/README.md File Reference\par \pard\plain 
{\tc\tcl2 \v lib/JsonParserGeneratorRK/README.md}
{\xe \v lib/JsonParserGeneratorRK/README.md}
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/MFRC522/README.md File Reference\par \pard\plain 
{\tc\tcl2 \v lib/MFRC522/README.md}
{\xe \v lib/MFRC522/README.md}
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/MQTT/README.md File Reference\par \pard\plain 
{\tc\tcl2 \v lib/MQTT/README.md}
{\xe \v lib/MQTT/README.md}
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
README.md File Reference\par \pard\plain 
{\tc\tcl2 \v README.md}
{\xe \v README.md}
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/JsonParserGeneratorRK/src/JsonParserGeneratorRK.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v lib/JsonParserGeneratorRK/src/JsonParserGeneratorRK.cpp}
{\xe \v lib/JsonParserGeneratorRK/src/JsonParserGeneratorRK.cpp}
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Particle.h"}\par
{\f2 #include "JsonParserGeneratorRK.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for JsonParserGeneratorRK.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_json_parser_generator_r_k_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b JsonParserGeneratorRK}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static jsmntok_t * {\b JsonParserGeneratorRK::jsmn_alloc_token} (jsmn_parser *parser, jsmntok_t *tokens, size_t num_tokens)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b JsonParserGeneratorRK::jsmn_fill_token} (jsmntok_t *token, jsmntype_t type, int start, int end)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b JsonParserGeneratorRK::jsmn_parse_primitive} (jsmn_parser *parser, const char *js, size_t len, jsmntok_t *tokens, size_t num_tokens)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static int {\b JsonParserGeneratorRK::jsmn_parse_string} (jsmn_parser *parser, const char *js, size_t len, jsmntok_t *tokens, size_t num_tokens)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b JsonParserGeneratorRK::jsmn_parse} (jsmn_parser *parser, const char *js, size_t len, jsmntok_t *tokens, unsigned int num_tokens)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run JSON parser. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b JsonParserGeneratorRK::jsmn_init} (jsmn_parser *parser)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create JSON parser over an array of tokens. }{
}\par
}}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/JsonParserGeneratorRK/src/JsonParserGeneratorRK.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/JsonParserGeneratorRK/src/JsonParserGeneratorRK.h}
{\xe \v lib/JsonParserGeneratorRK/src/JsonParserGeneratorRK.h}
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Particle.h"}\par
{\f2 #include <vector>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for JsonParserGeneratorRK.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_json_parser_generator_r_k_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_json_parser_generator_r_k_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b JsonParserGeneratorRK::jsmntok_t}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
JSON token description. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b JsonParserGeneratorRK::jsmn_parser}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
JSON parser. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b JsonParserString}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class used internally for writing to strings. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b JsonBuffer}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Base class for managing a static or dynamic buffer, used by both {\b JsonParser} and {\b JsonWriter}. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b JsonParser}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
API to the {\b JsonParser}. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b JsonParserStatic< BUFFER_SIZE, MAX_TOKENS >}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a {\b JsonParser} with a static buffer. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b JsonReference}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class provides a fluent-style API for easily traversing a tree of JSON objects to find a value. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b JsonWriterContext}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Used internally by {\b JsonWriter}. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b JsonWriter}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for building a JSON string. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b JsonWriterStatic< BUFFER_SIZE >}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a {\b JsonWriter} with a statically allocated buffer. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b JsonWriterAutoObject}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for creating a JSON object with {\b JsonWriter}. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b JsonWriterAutoArray}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for creating a JSON array with {\b JsonWriter}. }}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b JsonModifier}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class for modifying a JSON object in place, without needing to make a copy of it. }}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b JsonParserGeneratorRK}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b JsonParserGeneratorRK::jsmntype_t} \{ {\b JsonParserGeneratorRK::JSMN_UNDEFINED} = 0, 
{\b JsonParserGeneratorRK::JSMN_OBJECT} = 1, 
{\b JsonParserGeneratorRK::JSMN_ARRAY} = 2, 
{\b JsonParserGeneratorRK::JSMN_STRING} = 3, 
{\b JsonParserGeneratorRK::JSMN_PRIMITIVE} = 4
 \}{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
JSON type identifier (object, array, string, primitive) }}}
\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b JsonParserGeneratorRK::jsmnerr} \{ {\b JsonParserGeneratorRK::JSMN_ERROR_NOMEM} = -1, 
{\b JsonParserGeneratorRK::JSMN_ERROR_INVAL} = -2, 
{\b JsonParserGeneratorRK::JSMN_ERROR_PART} = -3
 \}{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
JSMN error codes. }}}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b JsonParserGeneratorRK::jsmn_init} (jsmn_parser *parser)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create JSON parser over an array of tokens. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b JsonParserGeneratorRK::jsmn_parse} (jsmn_parser *parser, const char *js, size_t len, jsmntok_t *tokens, unsigned int num_tokens)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Run JSON parser. }{
}\par
}}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/JsonParserGeneratorRK/test/gcclib/helpers.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v lib/JsonParserGeneratorRK/test/gcclib/helpers.cpp}
{\xe \v lib/JsonParserGeneratorRK/test/gcclib/helpers.cpp}
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Particle.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for helpers.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "helpers_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b itoa} (int value, char *str, int base)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b utoa} (unsigned int value, char *str, int base)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b ltoa} (unsigned long value, char *str, int base)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b ultoa} (unsigned long value, char *str, int base)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b HAL_RNG_GetRandomNumber} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v HAL_RNG_GetRandomNumber\:helpers.cpp}
{\xe \v helpers.cpp\:HAL_RNG_GetRandomNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t HAL_RNG_GetRandomNumber (void )}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file helpers.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    72                                        \{\par
   73     // This isn't right, there should be a cryptographically sound random number here,\par
   74     // but for testing this will be fine.\par
   75     return (uint32_t) rand();\par
   76 \}\par
}
}
{\xe \v itoa\:helpers.cpp}
{\xe \v helpers.cpp\:itoa}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* itoa (int  {\i value}, char *  {\i str}, int  {\i base})}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4 of file helpers.cpp.}\par
{
Referenced by String::concat(), and String::String().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     4                                                \{\par
    5 \par
    6     if (base == 16) \{\par
    7         sprintf(str, "%x", value);\par
    8     \}\par
    9     else\par
   10     if (base == 8) \{\par
   11         sprintf(str, "%o", value);\par
   12     \}\par
   13     else \{\par
   14         sprintf(str, "%d", value);\par
   15     \}\par
   16 \par
   17     return str;\par
   18 \}\par
}
}
{\xe \v ltoa\:helpers.cpp}
{\xe \v helpers.cpp\:ltoa}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* ltoa (unsigned long  {\i value}, char *  {\i str}, int  {\i base})}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 38 of file helpers.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    38                                                         \{\par
   39 \par
   40     if (base == 16) \{\par
   41         sprintf(str, "%lx", value);\par
   42     \}\par
   43     else\par
   44     if (base == 8) \{\par
   45         sprintf(str, "%lo", value);\par
   46     \}\par
   47     else \{\par
   48         sprintf(str, "%ld", value);\par
   49     \}\par
   50 \par
   51     return str;\par
   52 \}\par
}
}
{\xe \v ultoa\:helpers.cpp}
{\xe \v helpers.cpp\:ultoa}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* ultoa (unsigned long  {\i value}, char *  {\i str}, int  {\i base})}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 55 of file helpers.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    55                                                          \{\par
   56 \par
   57     if (base == 16) \{\par
   58         sprintf(str, "%lx", value);\par
   59     \}\par
   60     else\par
   61     if (base == 8) \{\par
   62         sprintf(str, "%lo", value);\par
   63     \}\par
   64     else \{\par
   65         sprintf(str, "%lu", value);\par
   66     \}\par
   67 \par
   68     return str;\par
   69 \}\par
}
}
{\xe \v utoa\:helpers.cpp}
{\xe \v helpers.cpp\:utoa}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* utoa (unsigned int  {\i value}, char *  {\i str}, int  {\i base})}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 21 of file helpers.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    21                                                         \{\par
   22 \par
   23     if (base == 16) \{\par
   24         sprintf(str, "%x", value);\par
   25     \}\par
   26     else\par
   27     if (base == 8) \{\par
   28         sprintf(str, "%o", value);\par
   29     \}\par
   30     else \{\par
   31         sprintf(str, "%u", value);\par
   32     \}\par
   33 \par
   34     return str;\par
   35 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/JsonParserGeneratorRK/test/gcclib/Particle.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/JsonParserGeneratorRK/test/gcclib/Particle.h}
{\xe \v lib/JsonParserGeneratorRK/test/gcclib/Particle.h}
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdarg.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <cassert>}\par
{\f2 #include "spark_wiring_string.h"}\par
{\f2 #include "rng_hal.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for Particle.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_particle_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_particle_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Stream}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/JsonParserGeneratorRK/test/gcclib/rng_hal.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/JsonParserGeneratorRK/test/gcclib/rng_hal.h}
{\xe \v lib/JsonParserGeneratorRK/test/gcclib/rng_hal.h}
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copyright (c) 2015 Particle Industries, Inc. All rights reserved. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for rng_hal.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "rng__hal_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "rng__hal_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b HAL_RNG_Configuration} (void)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
uint32_t {\b HAL_RNG_GetRandomNumber} (void)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copyright (c) 2015 Particle Industries, Inc. All rights reserved. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Satish Nair \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid V1.0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 13-Jan-2015 This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\par
}This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.\par
You should have received a copy of the GNU Lesser General Public License along with this library; if not, see {\f2 http://www.gnu.org/licenses/}. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v HAL_RNG_Configuration\:rng_hal.h}
{\xe \v rng_hal.h\:HAL_RNG_Configuration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void HAL_RNG_Configuration (void )}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v HAL_RNG_GetRandomNumber\:rng_hal.h}
{\xe \v rng_hal.h\:HAL_RNG_GetRandomNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
uint32_t HAL_RNG_GetRandomNumber (void )}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file helpers.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    72                                        \{\par
   73     // This isn't right, there should be a cryptographically sound random number here,\par
   74     // but for testing this will be fine.\par
   75     return (uint32_t) rand();\par
   76 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/JsonParserGeneratorRK/test/gcclib/spark_wiring_print.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v lib/JsonParserGeneratorRK/test/gcclib/spark_wiring_print.cpp}
{\xe \v lib/JsonParserGeneratorRK/test/gcclib/spark_wiring_print.cpp}
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wrapper for wiring print. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <math.h>}\par
{\f2 #include <stdarg.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include "spark_wiring_print.h"}\par
{\f2 #include "spark_wiring_string.h"}\par
{\f2 #include "spark_wiring_stream.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for spark_wiring_print.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "spark__wiring__print_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Wrapper for wiring print. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mohit Bhoite \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid V1.0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 13-March-2013 Copyright (c) 2013-2015 Particle Industries, Inc. All rights reserved. Copyright (c) 2010 David A. Mellis. All right reserved.\par
}This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\par
This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.\par
You should have received a copy of the GNU Lesser General Public License along with this library; if not, see {\f2 http://www.gnu.org/licenses/}. \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/JsonParserGeneratorRK/test/gcclib/spark_wiring_stream.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/JsonParserGeneratorRK/test/gcclib/spark_wiring_stream.h}
{\xe \v lib/JsonParserGeneratorRK/test/gcclib/spark_wiring_stream.h}
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header for spark_wiring_stream.c module. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "spark_wiring_string.h"}\par
{\f2 #include "spark_wiring_print.h"}\par
{\f2 #include "system_tick_hal.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for spark_wiring_stream.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "spark__wiring__stream_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "spark__wiring__stream_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Stream}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header for spark_wiring_stream.c module. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mohit Bhoite \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid V1.0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 13-March-2013 Copyright (c) 2013-2015 Particle Industries, Inc. All rights reserved. Copyright (c) 2010 David A. Mellis. All right reserved.\par
}This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\par
This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.\par
You should have received a copy of the GNU Lesser General Public License along with this library; if not, see {\f2 http://www.gnu.org/licenses/}. \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/JsonParserGeneratorRK/test/gcclib/spark_wiring_string.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v lib/JsonParserGeneratorRK/test/gcclib/spark_wiring_string.cpp}
{\xe \v lib/JsonParserGeneratorRK/test/gcclib/spark_wiring_string.cpp}
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copyright (c) 2013-2015 Particle Industries, Inc. All rights reserved. ...mostly rewritten by Paul Stoffregen... Copyright (c) 2009-10 Hernando Barragan. All rights reserved. Copyright 2011, Paul Stoffregen, {\f2 paul@pjrc.com}. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "spark_wiring_string.h"}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <limits.h>}\par
{\f2 #include <ctype.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include "string_convert.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for spark_wiring_string.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "spark__wiring__string_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b StringPrintableHelper}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dtoa} (double val, unsigned char prec, char *sout)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} & {\b operator+} (const {\b StringSumHelper} &lhs, const {\b String} &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} & {\b operator+} (const {\b StringSumHelper} &lhs, const char *cstr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} & {\b operator+} (const {\b StringSumHelper} &lhs, char c)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} & {\b operator+} (const {\b StringSumHelper} &lhs, unsigned char num)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} & {\b operator+} (const {\b StringSumHelper} &lhs, int num)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} & {\b operator+} (const {\b StringSumHelper} &lhs, unsigned int num)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} & {\b operator+} (const {\b StringSumHelper} &lhs, long num)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} & {\b operator+} (const {\b StringSumHelper} &lhs, unsigned long num)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} & {\b operator+} (const {\b StringSumHelper} &lhs, float num)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b StringSumHelper} & {\b operator+} (const {\b StringSumHelper} &lhs, double num)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &os, const {\b String} &value)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copyright (c) 2013-2015 Particle Industries, Inc. All rights reserved. ...mostly rewritten by Paul Stoffregen... Copyright (c) 2009-10 Hernando Barragan. All rights reserved. Copyright 2011, Paul Stoffregen, {\f2 paul@pjrc.com}. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Mohit Bhoite \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid V1.0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 13-March-2013 This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\par
}This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.\par
You should have received a copy of the GNU Lesser General Public License along with this library; if not, see {\f2 http://www.gnu.org/licenses/}. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v dtoa\:spark_wiring_string.cpp}
{\xe \v spark_wiring_string.cpp\:dtoa}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dtoa (double  {\i val}, unsigned char  {\i prec}, char *  {\i sout})}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 39 of file spark_wiring_string.cpp.}\par
{
References ultoa().}\par
{
Referenced by String::concat(), and String::String().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    39                                                        \{\par
   40     bool negative = val<0;\par
   41     if (negative) \{\par
   42         val = -val;\par
   43         *sout++ = '-';\par
   44     \}\par
   45     long scale = 1;\par
   46     for (uint8_t i=0; i<prec; i++)\par
   47         scale *= 10;\par
   48     val *= scale;   // capture all the significant digits\par
   49     uint64_t fixed = uint64_t(val);\par
   50     if ((val-fixed)>=0.5)    // round last digit\par
   51         fixed++;\par
   52 \par
   53     unsigned long first = (unsigned long)(fixed / scale);\par
   54     unsigned long second = (unsigned long)(fixed % scale);\par
   55 \par
   56     ultoa(first, sout, 10, 1);\par
   57     if (prec) \{\par
   58         sout += strlen(sout);\par
   59         *sout++ = '.';\par
   60         ultoa(second, sout, 10, prec);\par
   61     \}\par
   62 \}\par
}
}
{\xe \v operator+\:spark_wiring_string.cpp}
{\xe \v spark_wiring_string.cpp\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringSumHelper}& operator+ (const {\b StringSumHelper} &  {\i lhs}, const {\b String} &  {\i rhs})}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lhs} \cell }{The string to append to. {\b String} lhs is not modified.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rhs} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the combined string \par
}}{
Definition at line 359 of file spark_wiring_string.cpp.}\par
{
References String::buffer, String::concat(), String::invalidate(), and String::len.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   360 \{\par
  361     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);\par
  362     if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();\par
  363     return a;\par
  364 \}\par
}
}
{\xe \v operator+\:spark_wiring_string.cpp}
{\xe \v spark_wiring_string.cpp\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringSumHelper}& operator+ (const {\b StringSumHelper} &  {\i lhs}, const char *  {\i cstr})}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lhs} \cell }{The string to append to. {\b String} lhs is not modified.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cstr} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the combined string \par
}}{
Definition at line 366 of file spark_wiring_string.cpp.}\par
{
References String::concat(), and String::invalidate().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   367 \{\par
  368     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);\par
  369     if (!cstr || !a.concat(cstr, strlen(cstr))) a.invalidate();\par
  370     return a;\par
  371 \}\par
}
}
{\xe \v operator+\:spark_wiring_string.cpp}
{\xe \v spark_wiring_string.cpp\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringSumHelper}& operator+ (const {\b StringSumHelper} &  {\i lhs}, char  {\i c})}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lhs} \cell }{The string to append to. {\b String} lhs is not modified.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i c} \cell }{The character to append\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the combined string \par
}}{
Definition at line 373 of file spark_wiring_string.cpp.}\par
{
References String::concat(), and String::invalidate().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   374 \{\par
  375     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);\par
  376     if (!a.concat(c)) a.invalidate();\par
  377     return a;\par
  378 \}\par
}
}
{\xe \v operator+\:spark_wiring_string.cpp}
{\xe \v spark_wiring_string.cpp\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringSumHelper}& operator+ (const {\b StringSumHelper} &  {\i lhs}, unsigned char  {\i num})}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lhs} \cell }{The string to append to. {\b String} lhs is not modified.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the combined string \par
}}{
Definition at line 380 of file spark_wiring_string.cpp.}\par
{
References String::concat(), and String::invalidate().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   381 \{\par
  382     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);\par
  383     if (!a.concat(num)) a.invalidate();\par
  384     return a;\par
  385 \}\par
}
}
{\xe \v operator+\:spark_wiring_string.cpp}
{\xe \v spark_wiring_string.cpp\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringSumHelper}& operator+ (const {\b StringSumHelper} &  {\i lhs}, int  {\i num})}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lhs} \cell }{The string to append to. {\b String} lhs is not modified.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the combined string \par
}}{
Definition at line 387 of file spark_wiring_string.cpp.}\par
{
References String::concat(), and String::invalidate().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   388 \{\par
  389     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);\par
  390     if (!a.concat(num)) a.invalidate();\par
  391     return a;\par
  392 \}\par
}
}
{\xe \v operator+\:spark_wiring_string.cpp}
{\xe \v spark_wiring_string.cpp\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringSumHelper}& operator+ (const {\b StringSumHelper} &  {\i lhs}, unsigned int  {\i num})}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lhs} \cell }{The string to append to. {\b String} lhs is not modified.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the combined string \par
}}{
Definition at line 394 of file spark_wiring_string.cpp.}\par
{
References String::concat(), and String::invalidate().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   395 \{\par
  396     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);\par
  397     if (!a.concat(num)) a.invalidate();\par
  398     return a;\par
  399 \}\par
}
}
{\xe \v operator+\:spark_wiring_string.cpp}
{\xe \v spark_wiring_string.cpp\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringSumHelper}& operator+ (const {\b StringSumHelper} &  {\i lhs}, long  {\i num})}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lhs} \cell }{The string to append to. {\b String} lhs is not modified.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the combined string \par
}}{
Definition at line 401 of file spark_wiring_string.cpp.}\par
{
References String::concat(), and String::invalidate().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   402 \{\par
  403     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);\par
  404     if (!a.concat(num)) a.invalidate();\par
  405     return a;\par
  406 \}\par
}
}
{\xe \v operator+\:spark_wiring_string.cpp}
{\xe \v spark_wiring_string.cpp\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringSumHelper}& operator+ (const {\b StringSumHelper} &  {\i lhs}, unsigned long  {\i num})}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lhs} \cell }{The string to append to. {\b String} lhs is not modified.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the combined string \par
}}{
Definition at line 408 of file spark_wiring_string.cpp.}\par
{
References String::concat(), and String::invalidate().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   409 \{\par
  410     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);\par
  411     if (!a.concat(num)) a.invalidate();\par
  412     return a;\par
  413 \}\par
}
}
{\xe \v operator+\:spark_wiring_string.cpp}
{\xe \v spark_wiring_string.cpp\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringSumHelper}& operator+ (const {\b StringSumHelper} &  {\i lhs}, float  {\i num})}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lhs} \cell }{The string to append to. {\b String} lhs is not modified.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the combined string \par
}}{
Definition at line 415 of file spark_wiring_string.cpp.}\par
{
References String::concat(), and String::invalidate().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   416 \{\par
  417     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);\par
  418     if (!a.concat(num)) a.invalidate();\par
  419     return a;\par
  420 \}\par
}
}
{\xe \v operator+\:spark_wiring_string.cpp}
{\xe \v spark_wiring_string.cpp\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b StringSumHelper}& operator+ (const {\b StringSumHelper} &  {\i lhs}, double  {\i num})}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lhs} \cell }{The string to append to. {\b String} lhs is not modified.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i num} \cell }{The value to append.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid the combined string \par
}}{
Definition at line 422 of file spark_wiring_string.cpp.}\par
{
References String::concat(), and String::invalidate().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   423 \{\par
  424     StringSumHelper &a = const_cast<StringSumHelper&>(lhs);\par
  425     if (!a.concat(num)) a.invalidate();\par
  426     return a;\par
  427 \}\par
}
}
{\xe \v operator<<\:spark_wiring_string.cpp}
{\xe \v spark_wiring_string.cpp\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream& operator<< (std::ostream &  {\i os}, const {\b String} &  {\i value})}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 807 of file spark_wiring_string.cpp.}\par
{
References String::c_str().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   807                                                                 \{\par
  808     os << '"' << value.c_str() << '"';\par
  809     return os;\par
  810 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/JsonParserGeneratorRK/test/gcclib/string_convert.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/JsonParserGeneratorRK/test/gcclib/string_convert.h}
{\xe \v lib/JsonParserGeneratorRK/test/gcclib/string_convert.h}
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "string__convert_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b ltoa} (long N, char *str, int base)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b ultoa} (unsigned long a, char *buffer, int radix, char pad=1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b utoa} (unsigned a, char *buffer, int radix)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b itoa} (int a, char *buffer, int radix)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v itoa\:string_convert.h}
{\xe \v string_convert.h\:itoa}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* itoa (int  {\i a}, char *  {\i buffer}, int  {\i radix})}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 4 of file helpers.cpp.}\par
{
Referenced by String::concat(), and String::String().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     4                                                \{\par
    5 \par
    6     if (base == 16) \{\par
    7         sprintf(str, "%x", value);\par
    8     \}\par
    9     else\par
   10     if (base == 8) \{\par
   11         sprintf(str, "%o", value);\par
   12     \}\par
   13     else \{\par
   14         sprintf(str, "%d", value);\par
   15     \}\par
   16 \par
   17     return str;\par
   18 \}\par
}
}
{\xe \v ltoa\:string_convert.h}
{\xe \v string_convert.h\:ltoa}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* ltoa (long  {\i N}, char *  {\i str}, int  {\i base})}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by String::concat(), and String::String().}\par
}
{\xe \v ultoa\:string_convert.h}
{\xe \v string_convert.h\:ultoa}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* ultoa (unsigned long  {\i a}, char *  {\i buffer}, int  {\i radix}, char  {\i pad} = {\f2 1})}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by String::concat(), dtoa(), and String::String().}\par
}
{\xe \v utoa\:string_convert.h}
{\xe \v string_convert.h\:utoa}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* utoa (unsigned  {\i a}, char *  {\i buffer}, int  {\i radix})}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Referenced by String::concat(), and String::String().}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/JsonParserGeneratorRK/test/gcclib/system_tick_hal.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/JsonParserGeneratorRK/test/gcclib/system_tick_hal.h}
{\xe \v lib/JsonParserGeneratorRK/test/gcclib/system_tick_hal.h}
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copyright (c) 2013-2015 Particle Industries, Inc. All rights reserved. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdint.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for system_tick_hal.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "system__tick__hal_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "system__tick__hal_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef uint32_t {\b system_tick_t}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copyright (c) 2013-2015 Particle Industries, Inc. All rights reserved. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Matthew McGowan \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Version:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid V1.0.0 \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Date:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid 25-Sept-2014 This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\par
}This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.\par
You should have received a copy of the GNU Lesser General Public License along with this library; if not, see {\f2 http://www.gnu.org/licenses/}. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v system_tick_t\:system_tick_hal.h}
{\xe \v system_tick_hal.h\:system_tick_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef uint32_t {\b system_tick_t}}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file system_tick_hal.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/JsonParserGeneratorRK/test/gcclib/test1.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v lib/JsonParserGeneratorRK/test/gcclib/test1.cpp}
{\xe \v lib/JsonParserGeneratorRK/test/gcclib/test1.cpp}
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Particle.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for test1.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "test1_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char *argv[])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:test1.cpp}
{\xe \v test1.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int  {\i argc}, char *  {\i argv}[])}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 5 of file test1.cpp.}\par
{
References String::c_str().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     5                                  \{\par
    6     String foo = "test";\par
    7     printf("%s\\n", foo.c_str());\par
    8     return 0;\par
    9 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/JsonParserGeneratorRK/test/JsonTest.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v lib/JsonParserGeneratorRK/test/JsonTest.cpp}
{\xe \v lib/JsonParserGeneratorRK/test/JsonTest.cpp}
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Particle.h"}\par
{\f2 #include "JsonParserGeneratorRK.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for JsonTest.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_json_test_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b assertJsonParserBuffer}(jp,  expected)\~ {\b _assertJsonParserBuffer}(jp, expected, __LINE__)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b assertJsonWriterBuffer}(jw,  expected)\~ {\b _assertJsonWriterBuffer}(jw, expected, __LINE__)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printTokens} ({\b JsonParser} &jp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printToken} ({\b JsonParser} &jp, const {\b JsonParserGeneratorRK::jsmntok_t} *tok)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printJson} ({\b JsonParser} &jp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b readTestData} (const char *filename)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _assertJsonParserBuffer} ({\b JsonParser} &jp, const char *expected, size_t line)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _assertJsonWriterBuffer} ({\b JsonWriter} &jw, const char *expected, size_t line)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char *argv[])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printIndent} (size_t indent)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printString} (const char *str)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printJsonInner} ({\b JsonParser} &jp, const {\b JsonParserGeneratorRK::jsmntok_t} *container, size_t indent)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v assertJsonParserBuffer\:JsonTest.cpp}
{\xe \v JsonTest.cpp\:assertJsonParserBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define assertJsonParserBuffer( jp,  expected)\~ {\b _assertJsonParserBuffer}(jp, expected, __LINE__)}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 44 of file JsonTest.cpp.}\par
}
{\xe \v assertJsonWriterBuffer\:JsonTest.cpp}
{\xe \v JsonTest.cpp\:assertJsonWriterBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define assertJsonWriterBuffer( jw,  expected)\~ {\b _assertJsonWriterBuffer}(jw, expected, __LINE__)}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file JsonTest.cpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v _assertJsonParserBuffer\:JsonTest.cpp}
{\xe \v JsonTest.cpp\:_assertJsonParserBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void _assertJsonParserBuffer ({\b JsonParser} &  {\i jp}, const char *  {\i expected}, size_t  {\i line})}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 30 of file JsonTest.cpp.}\par
{
References JsonBuffer::getBuffer(), and JsonBuffer::getOffset().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    30                                                                                 \{\par
   31     char *actual = (char *) malloc(jp.getOffset() + 1);\par
   32     strncpy(actual, jp.getBuffer(), jp.getOffset());\par
   33     actual[jp.getOffset()] = 0;\par
   34 \par
   35     size_t expectedLen = strlen(expected);\par
   36     if (expectedLen != jp.getOffset() || strcmp(actual, expected) != 0) \{\par
   37         printf("line %lu: expectedLen=%lu actualLen=%lu\\n", line, expectedLen, jp.getOffset());\par
   38         printf("expected: %s\\n", expected);\par
   39         printf("actual:   %s\\n", actual);\par
   40         assert(false);\par
   41     \}\par
   42     free(actual);\par
   43 \}\par
}
}
{\xe \v _assertJsonWriterBuffer\:JsonTest.cpp}
{\xe \v JsonTest.cpp\:_assertJsonWriterBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void _assertJsonWriterBuffer ({\b JsonWriter} &  {\i jw}, const char *  {\i expected}, size_t  {\i line})}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 47 of file JsonTest.cpp.}\par
{
References JsonBuffer::getBuffer(), and JsonBuffer::getOffset().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    47                                                                                 \{\par
   48     char *actual = (char *) malloc(jw.getOffset() + 1);\par
   49     strncpy(actual, jw.getBuffer(), jw.getOffset());\par
   50     actual[jw.getOffset()] = 0;\par
   51 \par
   52     size_t expectedLen = strlen(expected);\par
   53     if (expectedLen != jw.getOffset() || strcmp(actual, expected) != 0) \{\par
   54         printf("line %lu: expectedLen=%lu actualLen=%lu\\n", line, expectedLen, jw.getOffset());\par
   55         printf("expected: %s\\n", expected);\par
   56         printf("actual:   %s\\n", actual);\par
   57         assert(false);\par
   58     \}\par
   59     free(actual);\par
   60 \}\par
}
}
{\xe \v main\:JsonTest.cpp}
{\xe \v JsonTest.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int  {\i argc}, char *  {\i argv}[])}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file JsonTest.cpp.}\par
{
References JsonBuffer::addData(), JsonBuffer::addString(), JsonBuffer::allocate(), JsonModifier::appendArrayValue(), JsonParserGeneratorRK::jsmntok_t::end, JsonModifier::findLeftComma(), JsonModifier::findRightComma(), JsonModifier::finish(), JsonWriter::finishObjectOrArray(), JsonParser::getArraySize(), JsonParser::getKeyValueTokenByIndex(), JsonParser::getOuterArray(), JsonParser::getOuterObject(), JsonParser::getOuterToken(), JsonParser::getOuterValueByKey(), JsonParser::getReference(), JsonParser::getTokenByIndex(), JsonParser::getTokenJsonString(), JsonParser::getTokenValue(), JsonParser::getValueByColRow(), JsonParser::getValueByIndex(), JsonParser::getValueByKey(), JsonParser::getValueTokenByIndex(), JsonParser::getValueTokenByKey(), JsonReference::index(), JsonWriter::insertArrayValue(), JsonWriter::insertCheckSeparator(), JsonWriter::insertKeyArray(), JsonWriter::insertKeyObject(), JsonWriter::insertKeyValue(), JsonWriter::insertKeyVector(), JsonModifier::insertOrUpdateKeyValue(), JsonWriter::insertsprintf(), JsonWriter::insertString(), JsonWriter::insertValue(), JsonModifier::JsonModifier(), JsonWriter::JsonWriter(), JsonReference::key(), String::operator==(), JsonParser::parse(), readTestData(), JsonModifier::removeArrayIndex(), JsonModifier::removeKeyValue(), JsonWriter::setFloatPlaces(), JsonReference::size(), JsonParserGeneratorRK::jsmntok_t::start, JsonModifier::startAppend(), JsonWriter::startArray(), JsonModifier::startModify(), JsonWriter::startObject(), JsonReference::valueDouble(), JsonReference::valueFloat(), JsonReference::valueInt(), JsonReference::valueString(), and JsonReference::valueUnsignedLong().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    65                                  \{\par
   66 \par
   67     \{\par
   68         JsonParser jp;\par
   69         char *data2a = readTestData("test2a.json");\par
   70         jp.addData(data2a, strlen(data2a));\par
   71         free(data2a);\par
   72 \par
   73         jp.parse();\par
   74 \par
   75         String s;\par
   76 \par
   77         assert(jp.getValueByKey(jp.getOuterObject(), "range", s));\par
   78         assert(s == "Sheet1!A2:B7");\par
   79 \par
   80         assert(jp.getReference().key("range").valueString() == "Sheet1!A2:B7");\par
   81 \par
   82         assert(jp.getValueByKey(jp.getOuterObject(), "majorDimension", s));\par
   83         assert(s == "COLUMNS");\par
   84 \par
   85         assert(jp.getReference().key("majorDimension").valueString() == "COLUMNS");\par
   86 \par
   87         const JsonParserGeneratorRK::jsmntok_t *values;\par
   88         assert(jp.getValueTokenByKey(jp.getOuterObject(), "values", values));\par
   89         assert(jp.getArraySize(values) == 2);\par
   90 \par
   91         assert(jp.getReference().key("values").size() == 2);\par
   92 \par
   93         const JsonParserGeneratorRK::jsmntok_t *col[2];\par
   94         assert(jp.getValueTokenByIndex(values, 0, col[0]));\par
   95         assert(jp.getArraySize(col[0]) == 4);\par
   96 \par
   97         assert(jp.getValueTokenByIndex(values, 1, col[1]));\par
   98         assert(jp.getArraySize(col[1]) == 4);\par
   99 \par
  100         assert(jp.getReference().key("values").index(0).size() == 4);\par
  101 \par
  102         assert(jp.getValueByIndex(col[0], 0, s));\par
  103         assert(s == "Albert Albrecht");\par
  104 \par
  105         assert(jp.getReference().key("values").index(0).index(0).valueString() == "Albert Albrecht");\par
  106 \par
  107         assert(jp.getValueByIndex(col[0], 1, s));\par
  108         assert(s == "Bob Billings");\par
  109 \par
  110         assert(jp.getReference().key("values").index(0).index(1).valueString() == "Bob Billings");\par
  111 \par
  112         assert(jp.getValueByIndex(col[0], 2, s));\par
  113         assert(s == "Charlie Chaplin");\par
  114 \par
  115         assert(jp.getReference().key("values").index(0).index(2).valueString() == "Charlie Chaplin");\par
  116 \par
  117         assert(jp.getValueByIndex(col[0], 3, s));\par
  118         assert(s == "Dave Dink");\par
  119 \par
  120         assert(jp.getReference().key("values").index(0).index(3).valueString() == "Dave Dink");\par
  121 \par
  122         int intValue;\par
  123         assert(jp.getValueByIndex(col[1], 0, intValue));\par
  124         assert(intValue == 1234);\par
  125 \par
  126         assert(jp.getReference().key("values").index(1).index(0).valueInt() == 1234);\par
  127 \par
  128         assert(jp.getValueByIndex(col[1], 1, intValue));\par
  129         assert(intValue == 2234);\par
  130 \par
  131         assert(jp.getReference().key("values").index(1).index(1).valueInt() == 2234);\par
  132 \par
  133         assert(jp.getValueByIndex(col[1], 2, intValue));\par
  134         assert(intValue == 3234);\par
  135 \par
  136         assert(jp.getReference().key("values").index(1).index(2).valueInt() == 3234);\par
  137 \par
  138         assert(jp.getValueByIndex(col[1], 3, intValue));\par
  139         assert(intValue == 4234);\par
  140 \par
  141         assert(jp.getReference().key("values").index(1).index(3).valueInt() == 4234);\par
  142 \par
  143         //\par
  144 \par
  145         assert(jp.getValueByColRow(values, 0, 0, s));\par
  146         assert(s == "Albert Albrecht");\par
  147 \par
  148         assert(jp.getValueByColRow(values, 1, 0, intValue));\par
  149         assert(intValue == 1234);\par
  150 \par
  151         assert(jp.getValueByColRow(values, 0, 1, s));\par
  152         assert(s == "Bob Billings");\par
  153 \par
  154         assert(jp.getValueByColRow(values, 1, 1, intValue));\par
  155         assert(intValue == 2234);\par
  156 \par
  157         assert(jp.getValueByColRow(values, 1, 1, s));\par
  158         assert(s == "2234");\par
  159 \par
  160         // printJson(jp);\par
  161     \}\par
  162     \{\par
  163         JsonParser jp;\par
  164 \par
  165         char *data2b = readTestData("test2b.json");\par
  166         //printf("%s", data2b);\par
  167 \par
  168         jp.addData(data2b, strlen(data2b));\par
  169         free(data2b);\par
  170 \par
  171         jp.parse();\par
  172 \par
  173         const JsonParserGeneratorRK::jsmntok_t *key, *value;\par
  174         String s;\par
  175         int intValue;\par
  176         float floatValue;\par
  177         double doubleValue;\par
  178         bool boolValue;\par
  179 \par
  180         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 0));\par
  181         //printf("key: start=%d end=%d\\n", key->start, key->end);\par
  182         //printf("value: start=%d end=%d\\n", value->start, value->end);\par
  183         assert(key->start == 5);\par
  184         assert(key->end == 7);\par
  185         assert(jp.getTokenValue(key, s));\par
  186         assert(s == "t1");\par
  187         assert(value->start == 10);\par
  188         assert(value->end == 13);\par
  189 \par
  190         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 1));\par
  191         assert(key->start == 19);\par
  192         assert(key->end == 21);\par
  193         assert(value->start == 23);\par
  194         assert(value->end == 27);\par
  195         assert(jp.getTokenValue(value, intValue));\par
  196         assert(intValue == 1234);\par
  197 \par
  198         assert(jp.getTokenValue(key, s));\par
  199         assert(s== "t2");\par
  200 \par
  201         assert(jp.getValueTokenByKey(jp.getOuterObject(), "t2", value));\par
  202         assert(jp.getTokenValue(value, intValue));\par
  203         assert(intValue == 1234);\par
  204 \par
  205         assert(jp.getValueByKey(jp.getOuterObject(), "t2", intValue));\par
  206         assert(intValue == 1234);\par
  207 \par
  208         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 2));\par
  209         assert(jp.getTokenValue(value, floatValue));\par
  210         assert(floatValue == 1234.5);\par
  211         assert(jp.getTokenValue(value, doubleValue));\par
  212         assert(doubleValue == 1234.5);\par
  213 \par
  214         assert(jp.getTokenValue(key, s));\par
  215         assert(s == "t3");\par
  216 \par
  217         assert(jp.getValueTokenByKey(jp.getOuterObject(), "t3", value));\par
  218         assert(jp.getTokenValue(value, floatValue));\par
  219         assert(floatValue == 1234.5);\par
  220 \par
  221 \par
  222         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 3));\par
  223         assert(jp.getTokenValue(key, s));\par
  224         assert(s == "t4");\par
  225         assert(jp.getTokenValue(value, boolValue));\par
  226         assert(boolValue);\par
  227 \par
  228         assert(jp.getValueTokenByKey(jp.getOuterObject(), "t4", value));\par
  229         assert(jp.getTokenValue(value, boolValue));\par
  230         assert(boolValue);\par
  231 \par
  232         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 4));\par
  233         assert(jp.getTokenValue(key, s));\par
  234         assert(s == "t5");\par
  235         assert(jp.getTokenValue(value, boolValue));\par
  236         assert(!boolValue);\par
  237 \par
  238         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 6));\par
  239         assert(jp.getTokenValue(key, s));\par
  240         assert(s == "t7");\par
  241 \par
  242         assert(jp.getTokenValue(value, s));\par
  243         assert(s == "\\"quoted\\"");\par
  244 \par
  245         assert(!jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 999));\par
  246         assert(!jp.getValueTokenByKey(jp.getOuterObject(), "xxx", value));\par
  247 \par
  248 \par
  249         //printJson(jp);\par
  250 \par
  251 \par
  252     \}\par
  253     // Static buffer test\par
  254     \{\par
  255         JsonParserStatic<256, 25> jp;\par
  256 \par
  257         char *data2b = readTestData("test2b.json");\par
  258 \par
  259         jp.addData(data2b, strlen(data2b));\par
  260         free(data2b);\par
  261 \par
  262         jp.parse();\par
  263 \par
  264         const JsonParserGeneratorRK::jsmntok_t *key, *value;\par
  265         char buf[256];\par
  266         size_t bufLen;\par
  267         int intValue;\par
  268         float floatValue;\par
  269         double doubleValue;\par
  270         bool boolValue;\par
  271 \par
  272         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 0));\par
  273         //printf("key: start=%d end=%d\\n", key->start, key->end);\par
  274         //printf("value: start=%d end=%d\\n", value->start, value->end);\par
  275         assert(key->start == 5);\par
  276         assert(key->end == 7);\par
  277         assert(value->start == 10);\par
  278         assert(value->end == 13);\par
  279         bufLen = sizeof(buf);\par
  280         assert(jp.getTokenValue(value, buf, bufLen));\par
  281         assert(bufLen == 4); // includes null terminator\par
  282         assert(strcmp(buf, "abc") == 0);\par
  283 \par
  284         // Test exactly-sized buffer with null\par
  285         bufLen = 4;\par
  286         assert(jp.getTokenValue(value, buf, bufLen));\par
  287         assert(bufLen == 4);\par
  288         assert(strcmp(buf, "abc") == 0);\par
  289 \par
  290         // Test short buffer\par
  291         bufLen = 3;\par
  292         assert(jp.getTokenValue(value, buf, bufLen));\par
  293         assert(bufLen == 4);\par
  294         assert(strcmp(buf, "ab") == 0);\par
  295 \par
  296         // Test null buffer sizing\par
  297         assert(jp.getTokenValue(value, NULL, bufLen));\par
  298         assert(bufLen == 4);\par
  299 \par
  300 \par
  301         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 1));\par
  302         assert(key->start == 19);\par
  303         assert(key->end == 21);\par
  304         assert(value->start == 23);\par
  305         assert(value->end == 27);\par
  306         assert(jp.getTokenValue(value, intValue));\par
  307         assert(intValue == 1234);\par
  308 \par
  309         assert(jp.getValueTokenByKey(jp.getOuterObject(), "t2", value));\par
  310         assert(jp.getTokenValue(value, intValue));\par
  311         assert(intValue == 1234);\par
  312 \par
  313         assert(jp.getValueByKey(jp.getOuterObject(), "t2", intValue));\par
  314         assert(intValue == 1234);\par
  315 \par
  316         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 2));\par
  317         assert(jp.getTokenValue(value, floatValue));\par
  318         assert(floatValue == 1234.5);\par
  319         assert(jp.getTokenValue(value, doubleValue));\par
  320         assert(doubleValue == 1234.5);\par
  321 \par
  322         assert(jp.getValueTokenByKey(jp.getOuterObject(), "t3", value));\par
  323         assert(jp.getTokenValue(value, floatValue));\par
  324         assert(floatValue == 1234.5);\par
  325 \par
  326 \par
  327         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 3));\par
  328         assert(jp.getTokenValue(value, boolValue));\par
  329         assert(boolValue);\par
  330 \par
  331         assert(jp.getValueTokenByKey(jp.getOuterObject(), "t4", value));\par
  332         assert(jp.getTokenValue(value, boolValue));\par
  333         assert(boolValue);\par
  334 \par
  335         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 4));\par
  336         assert(jp.getTokenValue(value, boolValue));\par
  337         assert(!boolValue);\par
  338 \par
  339         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 6));\par
  340 \par
  341         bufLen = sizeof(buf);\par
  342         assert(jp.getTokenValue(value, buf, bufLen));\par
  343         assert(bufLen == 9); // includes null\par
  344         assert(strcmp(buf, "\\"quoted\\"") == 0);\par
  345 \par
  346         assert(!jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 999));\par
  347         assert(!jp.getValueTokenByKey(jp.getOuterObject(), "xxx", value));\par
  348 \par
  349     \}\par
  350 \par
  351     // Static buffer too small\par
  352     \{\par
  353         JsonParserStatic<50, 25> jp;\par
  354 \par
  355         char *data2b = readTestData("test2b.json");\par
  356 \par
  357         assert(!jp.addData(data2b, strlen(data2b)));\par
  358 \par
  359         free(data2b);\par
  360     \}\par
  361 \par
  362     // Static buffer tokens too small\par
  363     \{\par
  364         JsonParserStatic<256, 5> jp;\par
  365 \par
  366         char *data2b = readTestData("test2b.json");\par
  367 \par
  368         assert(jp.addData(data2b, strlen(data2b)));\par
  369         free(data2b);\par
  370 \par
  371         assert(!jp.parse());\par
  372     \}\par
  373 \par
  374     // Unicode and some other odd data tests\par
  375     \{\par
  376         JsonParser jp;\par
  377         char *data = readTestData("test2c.json");\par
  378         jp.addData(data, strlen(data));\par
  379         free(data);\par
  380 \par
  381         jp.parse();\par
  382 \par
  383         String s;\par
  384         int intValue;\par
  385 \par
  386         // UTF-8 test: "t1":"ab\\"\\u00A2c\\u20AC"\par
  387         assert(jp.getValueByKey(jp.getOuterObject(), "t1", s));\par
  388 \par
  389         const char *sc = s;\par
  390         printf("%s\\n", sc);\par
  391 \par
  392         const unsigned char *uc = (const unsigned char *)sc;\par
  393 \par
  394         size_t ii = 0;\par
  395         assert(sc[ii++] == 'a');\par
  396         assert(sc[ii++] == 'b');\par
  397         assert(sc[ii++] == '"');\par
  398 \par
  399         assert(uc[ii++] == 0xc2);\par
  400         assert(uc[ii++] == 0xa2);\par
  401 \par
  402         assert(uc[ii++] == 0xe2);\par
  403         assert(uc[ii++] == 0x82);\par
  404         assert(uc[ii++] == 0xac);\par
  405 \par
  406 \par
  407         const JsonParserGeneratorRK::jsmntok_t *t2obj;\par
  408         assert(jp.getValueTokenByKey(jp.getOuterObject(), "t2", t2obj));\par
  409 \par
  410         assert(jp.getValueByKey(t2obj, "a", s));\par
  411         assert(s == "foo");\par
  412 \par
  413         const JsonParserGeneratorRK::jsmntok_t *t3obj;\par
  414         assert(jp.getValueTokenByKey(jp.getOuterObject(), "t3", t3obj));\par
  415 \par
  416 \par
  417         assert(jp.getValueByIndex(t3obj, 0, intValue));\par
  418         assert(intValue == 1);\par
  419 \par
  420         assert(jp.getValueByIndex(t3obj, 1, intValue));\par
  421         assert(intValue == 2);\par
  422 \par
  423         assert(jp.getValueByIndex(t3obj, 2, intValue));\par
  424         assert(intValue == 3);\par
  425 \par
  426         assert(jp.getValueByIndex(t3obj, 2, s));\par
  427         assert(s == "3");\par
  428 \par
  429         // Using fluent API\par
  430         assert(jp.getReference().key("t2").key("a").valueString() == "foo");\par
  431         assert(jp.getReference().key("t3").index(0).valueInt() == 1);\par
  432         assert(jp.getReference().key("t3").index(1).valueInt() == 2);\par
  433         assert(jp.getReference().key("t3").index(2).valueInt() == 3);\par
  434         assert(jp.getReference().key("t3").index(2).valueUnsignedLong() == 3);\par
  435         assert(jp.getReference().key("t3").index(2).valueString() == "3");\par
  436         assert(jp.getReference().key("t3").index(2).valueFloat() == 3.0);\par
  437         assert(jp.getReference().key("t3").index(2).valueDouble() == 3.0);\par
  438 \par
  439     \}\par
  440 \par
  441     // Test large data from OpenWeatherMap:\par
  442     // https://openweathermap.org/forecast5\par
  443     // http://api.openweathermap.org/data/2.5/forecast?id=524901&APPID=YOUR_API_KEY\par
  444     \{\par
  445         JsonParser jp;\par
  446         char *data = readTestData("test2d.json");\par
  447         size_t dataLen = strlen(data);\par
  448 \par
  449         // Break it up into 255 byte segments like a subscription\par
  450         for(size_t offset = 0; offset < dataLen; offset += 255) \{\par
  451             size_t count = dataLen - offset;\par
  452             if (count > 255) \{\par
  453                 count = 255;\par
  454             \}\par
  455             jp.addData(&data[offset], count);\par
  456         \}\par
  457         free(data);\par
  458 \par
  459         jp.parse();\par
  460 \par
  461         /*\par
  462         \{"city":\{"id":524901,"name":"Moscow","coord":\{"lon":37.615555,"lat":55.75222\},"country":"RU","population":0,"sys":\{"population":0\}\},\par
  463             "cod":"200","message":0.0168,"cnt":40,\par
  464             "list":[\{"dt":1478984400,"main":\{"temp":267.67,"temp_min":267.324,"temp_max":267.67,"pressure":1010.4,"sea_level":1031.53,"grnd_level":1010.4,"humidity":90,"temp_kf":0.34\},\par
  465                 "weather":[\{"id":600,"main":"Snow","description":"light snow","icon":"13n"\}],"clouds":\{"all":88\},"wind":\{"speed":4.93,"deg":278.007\},"snow":\{"3h":0.22125\},"sys":\{"pod":"n"\},"dt_txt":"2016-11-12 21:00:00"\},\par
  466             \{"dt":1478995200,"main":\{"temp":268.12,"temp_min":267.864\par
  467          */\par
  468         String strValue;\par
  469         int intValue;\par
  470         float floatValue;\par
  471 \par
  472         const JsonParserGeneratorRK::jsmntok_t *cityToken; // is an object\par
  473 \par
  474         assert(jp.getValueTokenByKey(jp.getOuterObject(), "city", cityToken));\par
  475 \par
  476         assert(jp.getValueByKey(cityToken, "id", intValue));\par
  477         assert(intValue == 524901);\par
  478 \par
  479         assert(jp.getValueByKey(cityToken, "name", strValue));\par
  480         assert(strValue == "Moscow");\par
  481 \par
  482         assert(jp.getValueByKey(cityToken, "country", strValue));\par
  483         assert(strValue == "RU");\par
  484 \par
  485         const JsonParserGeneratorRK::jsmntok_t *listToken; // is an array\par
  486         assert(jp.getValueTokenByKey(jp.getOuterObject(), "list", listToken));\par
  487         assert(jp.getArraySize(listToken) > 1);\par
  488 \par
  489         const JsonParserGeneratorRK::jsmntok_t *listObj; // is an object\par
  490         assert(jp.getValueTokenByIndex(listToken, 0, listObj));\par
  491 \par
  492         assert(jp.getValueByKey(listObj, "dt", intValue));\par
  493         assert(intValue == 1478984400);\par
  494 \par
  495         const JsonParserGeneratorRK::jsmntok_t *mainObj; // is an array\par
  496         assert(jp.getValueTokenByKey(listObj, "main", mainObj));\par
  497 \par
  498         assert(jp.getValueByKey(mainObj, "temp", floatValue));\par
  499         assert(floatValue >= 267.6 && floatValue <= 267.7); // 267.67\par
  500 \par
  501         // Second in the list\par
  502         assert(jp.getValueTokenByIndex(listToken, 1, listObj));\par
  503 \par
  504         assert(jp.getValueByKey(listObj, "dt", intValue));\par
  505         assert(intValue == 1478995200);\par
  506 \par
  507         // This is the last array element to make sure we've parsed correctly all the way to to the end\par
  508         // \{"dt":1479405600,"main":\{"temp":267.329,"temp_min":267.329,"temp_max":267.329,"pressure":1024.37,"sea_level":1045.84,"grnd_level":1024.37,"humidity":91,"temp_kf":0\},"weather":[\{"id":600,"main":"Snow","description":"light snow","icon":"13n"\}],"clouds":\{"all":80\},"wind":\{"speed":4.95,"deg":179.502\},"snow":\{"3h":0.105\},"sys":\{"pod":"n"\},"dt_txt":"2016-11-17 18:00:00"\}]\}\par
  509         assert(jp.getValueTokenByIndex(listToken, jp.getArraySize(listToken) - 1, listObj));\par
  510 \par
  511         assert(jp.getValueByKey(listObj, "dt", intValue));\par
  512         assert(intValue == 1479405600);\par
  513 \par
  514         assert(jp.getValueByKey(listObj, "dt_txt", strValue));\par
  515         assert(strValue == "2016-11-17 18:00:00");\par
  516 \par
  517 \par
  518     \}\par
  519     // Test large data from wunderground.com\par
  520     \{\par
  521         JsonParser jp;\par
  522         char *data = readTestData("test2e.json");\par
  523         size_t dataLen = strlen(data);\par
  524 \par
  525         // Break it up into 255 byte segments like a subscription\par
  526         for(size_t offset = 0; offset < dataLen; offset += 255) \{\par
  527             size_t count = dataLen - offset;\par
  528             if (count > 255) \{\par
  529                 count = 255;\par
  530             \}\par
  531             jp.addData(&data[offset], count);\par
  532         \}\par
  533         free(data);\par
  534 \par
  535         jp.parse();\par
  536 \par
  537         // Use the fluent-style API here\par
  538         assert(jp.getReference().key("response").key("version").valueString() == "0.1");\par
  539 \par
  540         assert(jp.getReference().key("forecast").key("txt_forecast").key("date").valueString() == "12:25 PM EST");\par
  541         assert(jp.getReference().key("forecast").key("txt_forecast").key("forecastday").key("period").valueInt() == 7);\par
  542 \par
  543     \}\par
  544 \par
  545     // Test data from Github issue\par
  546     // https://github.com/rickkas7/JsonParserGeneratorRK/issues/1\par
  547     // \{"A--":\{"M":\{"M":2,"U":5000,"T":10,"C":[0,255]\}\}\}\par
  548     \{\par
  549         JsonParser jp;\par
  550         String s;\par
  551 \par
  552         char *data = readTestData("test2f.json");\par
  553 \par
  554         jp.addString(data);\par
  555         free(data);\par
  556 \par
  557         bool bResult = jp.parse();\par
  558         assert(bResult);\par
  559 \par
  560         // Check fluent parser\par
  561         assert(jp.getReference().key("A--").key("M").key("U").valueInt() == 5000);\par
  562 \par
  563         // Check iteration\par
  564         for(size_t ii = 0; ; ii++) \{\par
  565             const JsonParserGeneratorRK::jsmntok_t *keyToken;\par
  566             const JsonParserGeneratorRK::jsmntok_t *valueToken;\par
  567             String name;\par
  568 \par
  569             if (!jp.getKeyValueTokenByIndex(jp.getOuterObject(), keyToken, valueToken, ii)) \{\par
  570                 // Reached end\par
  571                 assert(ii == 1);\par
  572                 break;\par
  573             \}\par
  574 \par
  575             bResult = jp.getTokenValue(keyToken, name);\par
  576             assert(bResult);\par
  577 \par
  578             assert(name == "A--");\par
  579 \par
  580             const JsonParserGeneratorRK::jsmntok_t *valueTokenInnerM;\par
  581 \par
  582             bResult = jp.getValueTokenByKey(valueToken, "M", valueTokenInnerM);\par
  583             assert(bResult);\par
  584 \par
  585             // Convert back to a JSON string\par
  586             bResult = jp.getTokenJsonString(valueTokenInnerM, s);\par
  587             assert(bResult);\par
  588             assert(s == "\{\\"M\\":2,\\"U\\":5000,\\"T\\":10,\\"C\\":[0,255]\}");\par
  589 \par
  590             // Parse inner\par
  591             for(size_t jj = 0; ; jj++) \{\par
  592                 const JsonParserGeneratorRK::jsmntok_t *keyTokenInner;\par
  593                 const JsonParserGeneratorRK::jsmntok_t *valueTokenInner;\par
  594 \par
  595                 if (!jp.getKeyValueTokenByIndex(valueTokenInnerM, keyTokenInner, valueTokenInner, jj)) \{\par
  596                     // Reached end\par
  597                     break;\par
  598                 \}\par
  599                 bResult = jp.getTokenValue(keyTokenInner, name);\par
  600                 assert(bResult);\par
  601 \par
  602                 int intValue;\par
  603 \par
  604                 if (name == "M") \{\par
  605                     bResult = jp.getTokenValue(valueTokenInner, intValue);\par
  606                     assert(bResult);\par
  607                     assert(intValue == 2);\par
  608                 \}\par
  609                 else\par
  610                 if (name == "U") \{\par
  611                     bResult = jp.getTokenValue(valueTokenInner, intValue);\par
  612                     assert(bResult);\par
  613                     assert(intValue == 5000);\par
  614 \par
  615                     // Convert back to a string\par
  616                     bResult = jp.getTokenJsonString(valueTokenInner, s);\par
  617                     assert(bResult);\par
  618 \par
  619                     assert(s == "5000");\par
  620                 \}\par
  621                 else\par
  622                 if (name == "T") \{\par
  623                     bResult = jp.getTokenValue(valueTokenInner, intValue);\par
  624                     assert(bResult);\par
  625                     assert(intValue == 10);\par
  626                 \}\par
  627                 else\par
  628                 if (name == "C") \{\par
  629                     assert(jp.getArraySize(valueTokenInner) == 2);\par
  630 \par
  631                     bResult = jp.getValueByIndex(valueTokenInner, 0, intValue);\par
  632                     assert(bResult);\par
  633                     assert(intValue == 0);\par
  634 \par
  635                     bResult = jp.getValueByIndex(valueTokenInner, 1, intValue);\par
  636                     assert(bResult);\par
  637                     assert(intValue == 255);\par
  638 \par
  639                     // Convert back to a string\par
  640                     bResult = jp.getTokenJsonString(valueTokenInner, s);\par
  641                     assert(bResult);\par
  642 \par
  643                     assert(s == "[0,255]");\par
  644                 \}\par
  645                 else \{\par
  646                     assert(0);\par
  647                 \}\par
  648             \}\par
  649 \par
  650             // Test converting back to JSON\par
  651             // \{"A--":\{"M":\{"M":2,"U":5000,"T":10,"C":[0,255]\}\}\}\par
  652             String s;\par
  653             bResult = jp.getTokenJsonString(jp.getOuterToken(), s);\par
  654             assert(bResult);\par
  655 \par
  656             const char *expected = "\{\\"A--\\":\{\\"M\\":\{\\"M\\":2,\\"U\\":5000,\\"T\\":10,\\"C\\":[0,255]\}\}\}";\par
  657 \par
  658             assert(s == expected);\par
  659 \par
  660             char newJsonBuf[64];\par
  661             size_t bufLen = sizeof(newJsonBuf);\par
  662             bResult = jp.getTokenJsonString(jp.getOuterToken(), newJsonBuf, bufLen);\par
  663             assert(bResult);\par
  664 \par
  665             assert(bufLen = (strlen(expected) + 1));\par
  666             assert(strcmp(newJsonBuf, expected) == 0);\par
  667 \par
  668         \}\par
  669 \par
  670         \{\par
  671             // \{"DID":"0000111122223333395abcd","NOM":"T","BV":"3.8","SOC":"3","PWR":"F","CHG":"T"\}\par
  672             JsonParserStatic<256, 14> jp;\par
  673             String s;\par
  674 \par
  675             char *data = readTestData("test2g.json");\par
  676 \par
  677             jp.addString(data);\par
  678             free(data);\par
  679 \par
  680             bool bResult = jp.parse();\par
  681             assert(bResult);\par
  682 \par
  683             bResult = jp.getOuterValueByKey("DID", s);\par
  684             assert(bResult);\par
  685             assert(s == "0000111122223333395abcd");\par
  686 \par
  687 \par
  688             bResult = jp.getOuterValueByKey("NOM", s);\par
  689             assert(bResult);\par
  690             assert(s == "T");\par
  691 \par
  692             float f;\par
  693             bResult = jp.getOuterValueByKey("BV", f);\par
  694             assert(bResult);\par
  695             assert(f > 3.7 && f < 3.9);\par
  696 \par
  697             int i;\par
  698             bResult = jp.getOuterValueByKey("SOC", i);\par
  699             assert(bResult);\par
  700             assert(i == 3);\par
  701 \par
  702             bResult = jp.getOuterValueByKey("PWR", s);\par
  703             assert(bResult);\par
  704             assert(s == "F");\par
  705 \par
  706             bResult = jp.getOuterValueByKey("CHG", s);\par
  707             assert(bResult);\par
  708             assert(s == "T");\par
  709 \par
  710         \}\par
  711     \}\par
  712 \par
  713     // Calling parse on an empty buffer should return false\par
  714     // https://github.com/rickkas7/JsonParserGeneratorRK/issues/7\par
  715     \{\par
  716         JsonParser jp;\par
  717         String s;\par
  718 \par
  719         jp.addString("");\par
  720         \par
  721         bool bResult = jp.parse();\par
  722         assert(!bResult);\par
  723     \}\par
  724 \par
  725     \{\par
  726         // https://community.particle.io/t/jsonparsergeneratorrk-parsing-a-child-key-from-a-firebase-get-webhook/56395\par
  727         // \{"-M5sN1MfCHcXHkLBlwWW":\{"aug":false,"fan":true,"ign":true\}\}\par
  728         JsonParserStatic<256, 14> jp;\par
  729         String s;\par
  730 \par
  731         char *data = readTestData("test2h.json");\par
  732 \par
  733         jp.addString(data);\par
  734         free(data);\par
  735 \par
  736         bool bResult = jp.parse();\par
  737         assert(bResult);\par
  738 \par
  739         const JsonParserGeneratorRK::jsmntok_t *firstObject;\par
  740         bResult = jp.getValueTokenByIndex(jp.getOuterObject(), 1, firstObject);\par
  741         assert(bResult);\par
  742         assert(firstObject != 0);\par
  743 \par
  744         bool bValue;\par
  745 \par
  746         bResult = jp.getValueByKey(firstObject, "aug", bValue);\par
  747         assert(bResult);\par
  748         assert(bValue == false);\par
  749 \par
  750         bResult = jp.getValueByKey(firstObject, "fan", bValue);\par
  751         assert(bResult);\par
  752         assert(bValue == true);\par
  753 \par
  754         bResult = jp.getValueByKey(firstObject, "ign", bValue);\par
  755         assert(bResult);\par
  756         assert(bValue == true);\par
  757 \par
  758     \}\par
  759 \par
  760     // Writer test, unallocated buffer\par
  761     \{\par
  762         JsonWriter jw;\par
  763         jw.addString("abcdefgh");\par
  764         assertJsonWriterBuffer(jw, "abcdefgh");\par
  765     \}\par
  766     // Writer test, small allocated buffer\par
  767     \{\par
  768         JsonWriter jw;\par
  769         jw.allocate(6);\par
  770         jw.addString("abcdefgh");\par
  771         assertJsonWriterBuffer(jw, "abcdefgh");\par
  772     \}\par
  773     // Writer test - sprintf\par
  774     \{\par
  775         JsonWriterStatic<100> jw;\par
  776 \par
  777         jw.insertsprintf("%04x", 0x1234);\par
  778         assertJsonWriterBuffer(jw, "1234");\par
  779     \}\par
  780     // Writer test - string insert Unicode\par
  781     \{\par
  782         JsonWriterStatic<100> jw;\par
  783 \par
  784         char tmp[4];\par
  785         tmp[0] = 0xc2;\par
  786         tmp[1] = 0xa2;\par
  787         tmp[2] = 0;\par
  788 \par
  789         jw.insertString(tmp, true);\par
  790         assertJsonWriterBuffer(jw, "\\"\\\\u00A2\\"");\par
  791     \}\par
  792     \{\par
  793         JsonWriterStatic<100> jw;\par
  794         char tmp[4];\par
  795         tmp[0]= 0xe2;\par
  796         tmp[1]= 0x82;\par
  797         tmp[2] = 0xac;\par
  798         tmp[3] = 0;\par
  799 \par
  800         jw.insertString(tmp, false);\par
  801         assertJsonWriterBuffer(jw, "\\\\u20AC");\par
  802     \}\par
  803 \par
  804     // Writer test - special chars\par
  805     \{\par
  806         JsonWriterStatic<100> jw;\par
  807 \par
  808         jw.insertString("\\b\\f\\n\\r\\t\\"\\\\", false);\par
  809         assertJsonWriterBuffer(jw, "\\\\b\\\\f\\\\n\\\\r\\\\t\\\\\\"\\\\\\\\");\par
  810 \par
  811     \}\par
  812 \par
  813     // Writer test - simple array\par
  814     \{\par
  815         JsonWriterStatic<256> jw;\par
  816 \par
  817         jw.startArray();\par
  818 \par
  819         jw.insertArrayValue(true);\par
  820         jw.insertArrayValue(1234);\par
  821         jw.insertArrayValue("test");\par
  822 \par
  823         jw.finishObjectOrArray();\par
  824 \par
  825         //printf("'%s'\\n", jw.getBuffer());\par
  826 \par
  827         assertJsonWriterBuffer(jw, "[true,1234,\\"test\\"]");\par
  828 \par
  829     \}\par
  830 \par
  831     // Writer test - simple object\par
  832     \{\par
  833         JsonWriterStatic<256> jw;\par
  834 \par
  835         jw.startObject();\par
  836 \par
  837         jw.insertKeyValue("a", true);\par
  838         jw.insertKeyValue("b", 1234);\par
  839         jw.insertKeyValue("c", "test");\par
  840 \par
  841         jw.finishObjectOrArray();\par
  842 \par
  843         assertJsonWriterBuffer(jw, "\{\\"a\\":true,\\"b\\":1234,\\"c\\":\\"test\\"\}");\par
  844 \par
  845     \}\par
  846 \par
  847     // Writer test - null termination test\par
  848     \{\par
  849         char buf[256];\par
  850         memset(buf, 'x', sizeof(buf));\par
  851         JsonWriter jw(buf, sizeof(buf));\par
  852 \par
  853         jw.startObject();\par
  854 \par
  855         jw.insertKeyValue("a", true);\par
  856         jw.insertKeyValue("b", 1234);\par
  857         jw.insertKeyValue("c", "test");\par
  858 \par
  859         jw.finishObjectOrArray();\par
  860 \par
  861         assertJsonWriterBuffer(jw, "\{\\"a\\":true,\\"b\\":1234,\\"c\\":\\"test\\"\}");\par
  862 \par
  863     \}\par
  864 \par
  865     // Writer test - nested\par
  866     \{\par
  867         JsonWriterStatic<256> jw;\par
  868 \par
  869         jw.startObject();\par
  870 \par
  871         jw.insertKeyArray("a");\par
  872         jw.insertArrayValue(123);\par
  873         jw.insertArrayValue(456);\par
  874         jw.insertArrayValue(789);\par
  875         jw.finishObjectOrArray();\par
  876 \par
  877         jw.insertKeyObject("b");\par
  878         jw.insertKeyValue("ba", true);\par
  879         jw.insertKeyValue("bb", 1234);\par
  880         jw.finishObjectOrArray();\par
  881 \par
  882         jw.finishObjectOrArray();\par
  883 \par
  884         assertJsonWriterBuffer(jw, "\{\\"a\\":[123,456,789],\\"b\\":\{\\"ba\\":true,\\"bb\\":1234\}\}");\par
  885 \par
  886     \}\par
  887 \par
  888     // Writer test - array of objects - low level API\par
  889     \{\par
  890         JsonWriterStatic<256> jw;\par
  891 \par
  892         jw.startArray();\par
  893 \par
  894         for(int ii = 0; ii < 5; ii++) \{\par
  895             // This used to be necessary, but now startObject takes care of this automatically\par
  896             // jw.insertCheckSeparator();\par
  897             jw.startObject();\par
  898             jw.insertKeyValue("ii", ii);\par
  899 \par
  900             jw.finishObjectOrArray();\par
  901         \}\par
  902 \par
  903         jw.finishObjectOrArray();\par
  904 \par
  905         // printf("'%s'\\n", jw.getBuffer());\par
  906 \par
  907         assertJsonWriterBuffer(jw, "[\{\\"ii\\":0\},\{\\"ii\\":1\},\{\\"ii\\":2\},\{\\"ii\\":3\},\{\\"ii\\":4\}]");\par
  908 \par
  909     \}\par
  910 \par
  911     // Writer test - float places object\par
  912     \{\par
  913         JsonWriterStatic<256> jw;\par
  914 \par
  915         jw.startObject();\par
  916 \par
  917         jw.setFloatPlaces(2);\par
  918         jw.insertKeyValue("a", 12.3333);\par
  919 \par
  920         jw.setFloatPlaces(0);\par
  921         jw.insertKeyValue("b", (double)12.77777777);\par
  922 \par
  923         jw.finishObjectOrArray();\par
  924 \par
  925         assertJsonWriterBuffer(jw, "\{\\"a\\":12.33,\\"b\\":13\}");\par
  926 \par
  927     \}\par
  928 \par
  929     // Writer test - int array\par
  930     \{\par
  931         JsonWriterStatic<256> jw;\par
  932 \par
  933         int array[3];\par
  934         array[0] = 1;\par
  935         array[1] = 2;\par
  936         array[2] = 3;\par
  937 \par
  938         jw.startObject();\par
  939 \par
  940         jw.setFloatPlaces(2);\par
  941         jw.insertKeyValue("a", "test");\par
  942 \par
  943         jw.insertKeyArray("b", array, sizeof(array)/sizeof(array[0]));\par
  944         \par
  945         // This closes the outer object\par
  946         jw.finishObjectOrArray();\par
  947 \par
  948         assertJsonWriterBuffer(jw, "\{\\"a\\":\\"test\\",\\"b\\":[1,2,3]\}");\par
  949     \}\par
  950 \par
  951     // Writer test - float vector\par
  952     \{\par
  953         JsonWriterStatic<256> jw;\par
  954 \par
  955         std::vector<float> vector;\par
  956         vector.push_back(1.1);\par
  957         vector.push_back(2.2);\par
  958         vector.push_back(3.333);\par
  959 \par
  960         jw.startObject();\par
  961 \par
  962         jw.setFloatPlaces(2);\par
  963         jw.insertKeyValue("a", "test");\par
  964         jw.insertKeyVector("b", vector);\par
  965 \par
  966         // This closes the outer object\par
  967         jw.finishObjectOrArray();\par
  968 \par
  969         assertJsonWriterBuffer(jw, "\{\\"a\\":\\"test\\",\\"b\\":[1.10,2.20,3.33]\}");\par
  970 \par
  971     \}\par
  972  \par
  973     // Writer test - float vector #2\par
  974     \{\par
  975         JsonWriterStatic<256> jw;\par
  976 \par
  977         std::vector<float> vector;\par
  978         vector.push_back(1.1);\par
  979         vector.push_back(2.2);\par
  980         vector.push_back(3.333);\par
  981         if (vector.size() > 2) \{\par
  982             // Remove the first (oldest) element\par
  983             vector.erase(vector.begin());\par
  984         \}\par
  985 \par
  986         jw.startObject();\par
  987 \par
  988         jw.setFloatPlaces(2);\par
  989         jw.insertKeyValue("a", "test");\par
  990         jw.insertKeyVector("b", vector);\par
  991 \par
  992         \par
  993         // This closes the outer object\par
  994         jw.finishObjectOrArray();\par
  995 \par
  996         assertJsonWriterBuffer(jw, "\{\\"a\\":\\"test\\",\\"b\\":[2.20,3.33]\}");\par
  997 \par
  998     \}\par
  999 \par
 1000     // Modifier test - make string longer\par
 1001     \{\par
 1002         JsonParserStatic<512, 32> jp;\par
 1003 \par
 1004         char *data2b = readTestData("test2b.json");\par
 1005         //printf("%s", data2b);\par
 1006 \par
 1007         jp.addData(data2b, strlen(data2b));\par
 1008         free(data2b);\par
 1009 \par
 1010         jp.parse();\par
 1011 \par
 1012         // printTokens(jp);\par
 1013         const JsonParserGeneratorRK::jsmntok_t *key, *value;\par
 1014 \par
 1015         bool bResult = jp.getValueTokenByKey(jp.getOuterToken(), "t1", value);\par
 1016         assert(bResult);\par
 1017 \par
 1018         JsonModifier mod(jp);\par
 1019         bResult = mod.startModify(value);\par
 1020         assert(bResult);\par
 1021 \par
 1022         mod.insertString("this is a test");\par
 1023         mod.finish();\par
 1024 \par
 1025         // printf("after modify\\n");\par
 1026         // printTokens(jp);\par
 1027 \par
 1028         String s;\par
 1029         int intValue;\par
 1030         float floatValue;\par
 1031         double doubleValue;\par
 1032         bool boolValue;\par
 1033 \par
 1034         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 0));\par
 1035         //printf("key: start=%d end=%d\\n", key->start, key->end);\par
 1036         //printf("value: start=%d end=%d\\n", value->start, value->end);\par
 1037         assert(key->start == 5);\par
 1038         assert(key->end == 7);\par
 1039         assert(jp.getTokenValue(key, s));\par
 1040         assert(s == "t1");\par
 1041 \par
 1042         assert(value->start == 10);\par
 1043         assert(value->end == 24);\par
 1044         assert(jp.getTokenValue(value, s));\par
 1045         assert(s == "this is a test");\par
 1046 \par
 1047         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 1));\par
 1048         assert(jp.getTokenValue(value, intValue));\par
 1049         assert(intValue == 1234);\par
 1050 \par
 1051         assert(jp.getTokenValue(key, s));\par
 1052         assert(s== "t2");\par
 1053 \par
 1054         assert(jp.getValueByKey(jp.getOuterObject(), "t2", intValue));\par
 1055         assert(intValue == 1234);\par
 1056 \par
 1057         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 2));\par
 1058         assert(jp.getTokenValue(value, floatValue));\par
 1059         assert(floatValue == 1234.5);\par
 1060 \par
 1061         assert(jp.getValueTokenByKey(jp.getOuterObject(), "t3", value));\par
 1062         assert(jp.getTokenValue(value, floatValue));\par
 1063         assert(floatValue == 1234.5);\par
 1064 \par
 1065         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 3));\par
 1066         assert(jp.getTokenValue(key, s));\par
 1067         assert(s == "t4");\par
 1068         assert(jp.getTokenValue(value, boolValue));\par
 1069         assert(boolValue);\par
 1070 \par
 1071         assert(jp.getValueTokenByKey(jp.getOuterObject(), "t4", value));\par
 1072         assert(jp.getTokenValue(value, boolValue));\par
 1073         assert(boolValue);\par
 1074 \par
 1075         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 4));\par
 1076         assert(jp.getTokenValue(key, s));\par
 1077         assert(s == "t5");\par
 1078         assert(jp.getTokenValue(value, boolValue));\par
 1079         assert(!boolValue);\par
 1080 \par
 1081         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 6));\par
 1082         assert(jp.getTokenValue(key, s));\par
 1083         assert(s == "t7");\par
 1084 \par
 1085         assert(jp.getTokenValue(value, s));\par
 1086         assert(s == "\\"quoted\\"");\par
 1087     \}\par
 1088 \par
 1089 \par
 1090     // Modifier test - make string shorter\par
 1091     \{\par
 1092         JsonParserStatic<512, 32> jp;\par
 1093 \par
 1094         char *data2b = readTestData("test2b.json");\par
 1095         //printf("%s", data2b);\par
 1096 \par
 1097         jp.addData(data2b, strlen(data2b));\par
 1098         free(data2b);\par
 1099 \par
 1100         jp.parse();\par
 1101 \par
 1102         // printTokens(jp);\par
 1103         const JsonParserGeneratorRK::jsmntok_t *key, *value;\par
 1104 \par
 1105         bool bResult = jp.getValueTokenByKey(jp.getOuterToken(), "t1", value);\par
 1106         assert(bResult);\par
 1107 \par
 1108         JsonModifier mod(jp);\par
 1109         bResult = mod.startModify(value);\par
 1110         assert(bResult);\par
 1111 \par
 1112         mod.insertString("x");\par
 1113         mod.finish();\par
 1114 \par
 1115         // printf("after modify\\n");\par
 1116         // printTokens(jp);\par
 1117 \par
 1118         String s;\par
 1119         int intValue;\par
 1120         float floatValue;\par
 1121         double doubleValue;\par
 1122         bool boolValue;\par
 1123 \par
 1124         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 0));\par
 1125         //printf("key: start=%d end=%d\\n", key->start, key->end);\par
 1126         //printf("value: start=%d end=%d\\n", value->start, value->end);\par
 1127         assert(key->start == 5);\par
 1128         assert(key->end == 7);\par
 1129         assert(jp.getTokenValue(key, s));\par
 1130         assert(s == "t1");\par
 1131 \par
 1132         assert(value->start == 10);\par
 1133         assert(value->end == 11);\par
 1134         assert(jp.getTokenValue(value, s));\par
 1135         assert(s == "x");\par
 1136 \par
 1137         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 1));\par
 1138         assert(jp.getTokenValue(value, intValue));\par
 1139         assert(intValue == 1234);\par
 1140 \par
 1141         assert(jp.getTokenValue(key, s));\par
 1142         assert(s== "t2");\par
 1143 \par
 1144         assert(jp.getValueByKey(jp.getOuterObject(), "t2", intValue));\par
 1145         assert(intValue == 1234);\par
 1146 \par
 1147         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 2));\par
 1148         assert(jp.getTokenValue(value, floatValue));\par
 1149         assert(floatValue == 1234.5);\par
 1150 \par
 1151         assert(jp.getValueTokenByKey(jp.getOuterObject(), "t3", value));\par
 1152         assert(jp.getTokenValue(value, floatValue));\par
 1153         assert(floatValue == 1234.5);\par
 1154 \par
 1155         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 3));\par
 1156         assert(jp.getTokenValue(key, s));\par
 1157         assert(s == "t4");\par
 1158         assert(jp.getTokenValue(value, boolValue));\par
 1159         assert(boolValue);\par
 1160 \par
 1161         assert(jp.getValueTokenByKey(jp.getOuterObject(), "t4", value));\par
 1162         assert(jp.getTokenValue(value, boolValue));\par
 1163         assert(boolValue);\par
 1164 \par
 1165         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 4));\par
 1166         assert(jp.getTokenValue(key, s));\par
 1167         assert(s == "t5");\par
 1168         assert(jp.getTokenValue(value, boolValue));\par
 1169         assert(!boolValue);\par
 1170 \par
 1171         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 6));\par
 1172         assert(jp.getTokenValue(key, s));\par
 1173         assert(s == "t7");\par
 1174 \par
 1175         assert(jp.getTokenValue(value, s));\par
 1176         assert(s == "\\"quoted\\"");\par
 1177     \}\par
 1178 \par
 1179     // Modifier test - change integer (same size)\par
 1180     \{\par
 1181         JsonParserStatic<512, 32> jp;\par
 1182 \par
 1183         char *data2b = readTestData("test2b.json");\par
 1184         //printf("%s", data2b);\par
 1185 \par
 1186         jp.addData(data2b, strlen(data2b));\par
 1187         free(data2b);\par
 1188 \par
 1189         jp.parse();\par
 1190 \par
 1191         // printTokens(jp);\par
 1192         const JsonParserGeneratorRK::jsmntok_t *key, *value;\par
 1193 \par
 1194         bool bResult = jp.getValueTokenByKey(jp.getOuterToken(), "t2", value);\par
 1195         assert(bResult);\par
 1196 \par
 1197         JsonModifier mod(jp);\par
 1198         bResult = mod.startModify(value);\par
 1199         assert(bResult);\par
 1200 \par
 1201         mod.insertValue((int)9999);\par
 1202         mod.finish();\par
 1203 \par
 1204         // printf("after modify\\n");\par
 1205         // printTokens(jp);\par
 1206 \par
 1207         String s;\par
 1208         int intValue;\par
 1209         float floatValue;\par
 1210         double doubleValue;\par
 1211         bool boolValue;\par
 1212 \par
 1213         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 0));\par
 1214         //printf("key: start=%d end=%d\\n", key->start, key->end);\par
 1215         //printf("value: start=%d end=%d\\n", value->start, value->end);\par
 1216         assert(jp.getTokenValue(key, s));\par
 1217         assert(s == "t1");\par
 1218 \par
 1219         assert(jp.getTokenValue(value, s));\par
 1220         assert(s == "abc");\par
 1221 \par
 1222         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 1));\par
 1223         assert(jp.getTokenValue(value, intValue));\par
 1224         assert(intValue == 9999);\par
 1225 \par
 1226         assert(jp.getTokenValue(key, s));\par
 1227         assert(s== "t2");\par
 1228 \par
 1229         assert(jp.getValueByKey(jp.getOuterObject(), "t2", intValue));\par
 1230         assert(intValue == 9999);\par
 1231 \par
 1232         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 2));\par
 1233         assert(jp.getTokenValue(value, floatValue));\par
 1234         assert(floatValue == 1234.5);\par
 1235 \par
 1236         assert(jp.getValueTokenByKey(jp.getOuterObject(), "t3", value));\par
 1237         assert(jp.getTokenValue(value, floatValue));\par
 1238         assert(floatValue == 1234.5);\par
 1239 \par
 1240         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 3));\par
 1241         assert(jp.getTokenValue(key, s));\par
 1242         assert(s == "t4");\par
 1243         assert(jp.getTokenValue(value, boolValue));\par
 1244         assert(boolValue);\par
 1245 \par
 1246         assert(jp.getValueTokenByKey(jp.getOuterObject(), "t4", value));\par
 1247         assert(jp.getTokenValue(value, boolValue));\par
 1248         assert(boolValue);\par
 1249 \par
 1250         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 4));\par
 1251         assert(jp.getTokenValue(key, s));\par
 1252         assert(s == "t5");\par
 1253         assert(jp.getTokenValue(value, boolValue));\par
 1254         assert(!boolValue);\par
 1255 \par
 1256         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 6));\par
 1257         assert(jp.getTokenValue(key, s));\par
 1258         assert(s == "t7");\par
 1259 \par
 1260         assert(jp.getTokenValue(value, s));\par
 1261         assert(s == "\\"quoted\\"");\par
 1262     \}\par
 1263 \par
 1264     // Modifier test - change double\par
 1265     \{\par
 1266         JsonParserStatic<512, 32> jp;\par
 1267 \par
 1268         char *data2b = readTestData("test2b.json");\par
 1269         //printf("%s", data2b);\par
 1270 \par
 1271         jp.addData(data2b, strlen(data2b));\par
 1272         free(data2b);\par
 1273 \par
 1274         jp.parse();\par
 1275 \par
 1276         // printTokens(jp);\par
 1277         const JsonParserGeneratorRK::jsmntok_t *key, *value;\par
 1278 \par
 1279         bool bResult = jp.getValueTokenByKey(jp.getOuterToken(), "t3", value);\par
 1280         assert(bResult);\par
 1281 \par
 1282         JsonModifier mod(jp);\par
 1283         bResult = mod.startModify(value);\par
 1284         assert(bResult);\par
 1285 \par
 1286         mod.insertValue((double)12345.6);\par
 1287         mod.finish();\par
 1288 \par
 1289         // printf("after modify\\n");\par
 1290         // printTokens(jp);\par
 1291 \par
 1292         String s;\par
 1293         int intValue;\par
 1294         float floatValue;\par
 1295         double doubleValue;\par
 1296         bool boolValue;\par
 1297 \par
 1298         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 0));\par
 1299         //printf("key: start=%d end=%d\\n", key->start, key->end);\par
 1300         //printf("value: start=%d end=%d\\n", value->start, value->end);\par
 1301         assert(jp.getTokenValue(key, s));\par
 1302         assert(s == "t1");\par
 1303 \par
 1304         assert(jp.getTokenValue(value, s));\par
 1305         assert(s == "abc");\par
 1306 \par
 1307         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 1));\par
 1308         assert(jp.getTokenValue(value, intValue));\par
 1309         assert(intValue == 1234);\par
 1310 \par
 1311         assert(jp.getTokenValue(key, s));\par
 1312         assert(s== "t2");\par
 1313 \par
 1314         assert(jp.getValueByKey(jp.getOuterObject(), "t2", intValue));\par
 1315         assert(intValue == 1234);\par
 1316 \par
 1317         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 2));\par
 1318         assert(jp.getTokenValue(value, doubleValue));\par
 1319         assert(doubleValue == 12345.6);\par
 1320 \par
 1321         assert(jp.getValueTokenByKey(jp.getOuterObject(), "t3", value));\par
 1322         assert(jp.getTokenValue(value, doubleValue));\par
 1323         assert(doubleValue == 12345.6);\par
 1324 \par
 1325         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 3));\par
 1326         assert(jp.getTokenValue(key, s));\par
 1327         assert(s == "t4");\par
 1328         assert(jp.getTokenValue(value, boolValue));\par
 1329         assert(boolValue);\par
 1330 \par
 1331         assert(jp.getValueTokenByKey(jp.getOuterObject(), "t4", value));\par
 1332         assert(jp.getTokenValue(value, boolValue));\par
 1333         assert(boolValue);\par
 1334 \par
 1335         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 4));\par
 1336         assert(jp.getTokenValue(key, s));\par
 1337         assert(s == "t5");\par
 1338         assert(jp.getTokenValue(value, boolValue));\par
 1339         assert(!boolValue);\par
 1340 \par
 1341         assert(jp.getKeyValueTokenByIndex(jp.getOuterObject(), key, value, 6));\par
 1342         assert(jp.getTokenValue(key, s));\par
 1343         assert(s == "t7");\par
 1344 \par
 1345         assert(jp.getTokenValue(value, s));\par
 1346         assert(s == "\\"quoted\\"");\par
 1347     \}\par
 1348 \par
 1349     // Array test low-level findLeftCommand. findRightComma\par
 1350     \{\par
 1351         JsonParserStatic<512, 32> jp;\par
 1352 \par
 1353         jp.addString("[1, 2 , 3]");\par
 1354 \par
 1355         jp.parse();\par
 1356 \par
 1357         //printTokens(jp);\par
 1358 \par
 1359         JsonModifier mod(jp);\par
 1360 \par
 1361         const JsonParserGeneratorRK::jsmntok_t *arrayToken = jp.getOuterArray();\par
 1362 \par
 1363         const JsonParserGeneratorRK::jsmntok_t *tok;\par
 1364 \par
 1365         tok = jp.getTokenByIndex(arrayToken, 0);\par
 1366         assert(mod.findLeftComma(tok) == -1);\par
 1367         assert(mod.findRightComma(tok) == 2);\par
 1368 \par
 1369         tok = jp.getTokenByIndex(arrayToken, 1);\par
 1370         assert(mod.findLeftComma(tok) == 2);\par
 1371         assert(mod.findRightComma(tok) == 6);\par
 1372 \par
 1373         tok = jp.getTokenByIndex(arrayToken, 2);\par
 1374         assert(mod.findLeftComma(tok) == 6);\par
 1375         assert(mod.findRightComma(tok) == -1);\par
 1376 \par
 1377         mod.removeArrayIndex(arrayToken, 0);\par
 1378         // printTokens(jp);\par
 1379 \par
 1380         const char *expected = "[ 2 , 3]";\par
 1381         assertJsonParserBuffer(jp, expected);\par
 1382 \par
 1383         mod.removeArrayIndex(arrayToken, 1);\par
 1384         // printTokens(jp);\par
 1385 \par
 1386         expected = "[ 2 ]";\par
 1387         assertJsonParserBuffer(jp, expected);\par
 1388 \par
 1389         mod.removeArrayIndex(arrayToken, 0);\par
 1390 \par
 1391         expected = "[  ]";\par
 1392         assertJsonParserBuffer(jp, expected);\par
 1393 \par
 1394         arrayToken = jp.getOuterArray();\par
 1395         mod.startAppend(arrayToken);\par
 1396 \par
 1397         mod.insertCheckSeparator();\par
 1398         mod.insertValue(4);\par
 1399 \par
 1400         mod.finish();\par
 1401         //printTokens(jp);\par
 1402 \par
 1403         expected = "[  4]";\par
 1404         assertJsonParserBuffer(jp, expected);\par
 1405 \par
 1406         mod.startAppend(arrayToken);\par
 1407 \par
 1408         mod.insertCheckSeparator();\par
 1409         mod.insertValue(5);\par
 1410 \par
 1411         mod.finish();\par
 1412         //printTokens(jp);\par
 1413 \par
 1414         expected = "[  4,5]";\par
 1415         assertJsonParserBuffer(jp, expected);\par
 1416 \par
 1417     \}\par
 1418 \par
 1419     // Array test low-level findLeftCommand. findRightComma with strings\par
 1420     \{\par
 1421         JsonParserStatic<512, 32> jp;\par
 1422 \par
 1423         jp.addString("[\\"a\\", \\"b\\" ,\\"c\\" ]");\par
 1424 \par
 1425         jp.parse();\par
 1426 \par
 1427         //printTokens(jp);\par
 1428 \par
 1429         JsonModifier mod(jp);\par
 1430 \par
 1431         const JsonParserGeneratorRK::jsmntok_t *arrayToken = jp.getOuterArray();\par
 1432 \par
 1433         const JsonParserGeneratorRK::jsmntok_t *tok;\par
 1434 \par
 1435         tok = jp.getTokenByIndex(arrayToken, 0);\par
 1436         assert(mod.findLeftComma(tok) == -1);\par
 1437         assert(mod.findRightComma(tok) == 4);\par
 1438 \par
 1439         tok = jp.getTokenByIndex(arrayToken, 1);\par
 1440         assert(mod.findLeftComma(tok) == 4);\par
 1441         assert(mod.findRightComma(tok) == 10);\par
 1442 \par
 1443         tok = jp.getTokenByIndex(arrayToken, 2);\par
 1444         assert(mod.findLeftComma(tok) == 10);\par
 1445         assert(mod.findRightComma(tok) == -1);\par
 1446 \par
 1447         mod.removeArrayIndex(arrayToken, 0);\par
 1448         // printTokens(jp);\par
 1449 \par
 1450         const char *expected = "[ \\"b\\" ,\\"c\\" ]";\par
 1451         assertJsonParserBuffer(jp, expected);\par
 1452 \par
 1453         mod.removeArrayIndex(arrayToken, 0);\par
 1454         expected = "[ \\"c\\" ]";\par
 1455         assertJsonParserBuffer(jp, expected);\par
 1456 \par
 1457         mod.removeArrayIndex(arrayToken, 0);\par
 1458         expected = "[  ]";\par
 1459         assertJsonParserBuffer(jp, expected);\par
 1460         // printTokens(jp);\par
 1461 \par
 1462         arrayToken = jp.getOuterArray();\par
 1463         mod.startAppend(arrayToken);\par
 1464 \par
 1465         //mod.insertCheckSeparator();\par
 1466         mod.insertArrayValue("d");\par
 1467 \par
 1468         mod.finish();\par
 1469         //printTokens(jp);\par
 1470 \par
 1471         expected = "[  \\"d\\"]";\par
 1472         assertJsonParserBuffer(jp, expected);\par
 1473 \par
 1474         mod.startAppend(arrayToken);\par
 1475 \par
 1476         mod.insertArrayValue("e");\par
 1477 \par
 1478         mod.finish();\par
 1479         // printTokens(jp);\par
 1480 \par
 1481         expected = "[  \\"d\\",\\"e\\"]";\par
 1482         assertJsonParserBuffer(jp, expected);\par
 1483 \par
 1484     \}\par
 1485 \par
 1486     // Object test removeKeyValue insertKeyValue\par
 1487     // Note: uses low-level API, probably best to use insertOrUpdateKeyValue in most code\par
 1488     \{\par
 1489         JsonParserStatic<512, 32> jp;\par
 1490 \par
 1491         jp.addString("\{\\"a\\":1, \\"b\\":\\"x\\" ,\\"c\\":3 \}");\par
 1492 \par
 1493         jp.parse();\par
 1494 \par
 1495         //printTokens(jp);\par
 1496 \par
 1497         JsonModifier mod(jp);\par
 1498 \par
 1499         mod.removeKeyValue(jp.getOuterObject(), "a");\par
 1500 \par
 1501         //printTokens(jp);\par
 1502         const char *expected = "\{ \\"b\\":\\"x\\" ,\\"c\\":3 \}";\par
 1503         assertJsonParserBuffer(jp, expected);\par
 1504 \par
 1505         mod.removeKeyValue(jp.getOuterObject(), "c");\par
 1506 \par
 1507         //printTokens(jp);\par
 1508         expected = "\{ \\"b\\":\\"x\\"  \}";\par
 1509         assertJsonParserBuffer(jp, expected);\par
 1510 \par
 1511         mod.removeKeyValue(jp.getOuterObject(), "b");\par
 1512 \par
 1513         //printTokens(jp);\par
 1514         expected = "\{   \}";\par
 1515         assertJsonParserBuffer(jp, expected);\par
 1516 \par
 1517 \par
 1518         mod.startAppend(jp.getOuterObject());\par
 1519 \par
 1520         mod.insertKeyValue("d", (int)4);\par
 1521 \par
 1522         mod.finish();\par
 1523         //printTokens(jp);\par
 1524         expected = "\{   \\"d\\":4\}";\par
 1525         assertJsonParserBuffer(jp, expected);\par
 1526 \par
 1527 \par
 1528         mod.startAppend(jp.getOuterObject());\par
 1529 \par
 1530         mod.insertKeyValue("e", "test");\par
 1531 \par
 1532         mod.finish();\par
 1533         //printTokens(jp);\par
 1534         expected = "\{   \\"d\\":4,\\"e\\":\\"test\\"\}";\par
 1535         assertJsonParserBuffer(jp, expected);\par
 1536     \}\par
 1537 \par
 1538     // High level insertOrUpdateKeyValue API test\par
 1539     \{\par
 1540         JsonParserStatic<512, 32> jp;\par
 1541 \par
 1542         jp.addString("\{\}");\par
 1543 \par
 1544         jp.parse();\par
 1545 \par
 1546         //printTokens(jp);\par
 1547 \par
 1548         JsonModifier mod(jp);\par
 1549 \par
 1550         mod.insertOrUpdateKeyValue(jp.getOuterObject(), "a", (int)1);\par
 1551 \par
 1552         // printTokens(jp);\par
 1553 \par
 1554         const char *expected = "\{\\"a\\":1\}";\par
 1555         assertJsonParserBuffer(jp, expected);\par
 1556 \par
 1557         mod.insertOrUpdateKeyValue(jp.getOuterObject(), "b", "x");\par
 1558 \par
 1559         // printTokens(jp);\par
 1560 \par
 1561         expected = "\{\\"a\\":1,\\"b\\":\\"x\\"\}";\par
 1562         assertJsonParserBuffer(jp, expected);\par
 1563 \par
 1564         mod.insertOrUpdateKeyValue(jp.getOuterObject(), "b", "xxx");\par
 1565 \par
 1566         // printTokens(jp);\par
 1567 \par
 1568         expected = "\{\\"a\\":1,\\"b\\":\\"xxx\\"\}";\par
 1569         assertJsonParserBuffer(jp, expected);\par
 1570 \par
 1571         // Updating a value will reorder the keys in the object\par
 1572         mod.insertOrUpdateKeyValue(jp.getOuterObject(), "a", (int)999);\par
 1573 \par
 1574         expected = "\{\\"b\\":\\"xxx\\",\\"a\\":999\}";\par
 1575         assertJsonParserBuffer(jp, expected);\par
 1576 \par
 1577         // String to number\par
 1578         mod.insertOrUpdateKeyValue(jp.getOuterObject(), "b", (int)123);\par
 1579 \par
 1580         expected = "\{\\"a\\":999,\\"b\\":123\}";\par
 1581         assertJsonParserBuffer(jp, expected);\par
 1582 \par
 1583         // Number to string\par
 1584         mod.insertOrUpdateKeyValue(jp.getOuterObject(), "b", "x");\par
 1585 \par
 1586         expected = "\{\\"a\\":999,\\"b\\":\\"x\\"\}";\par
 1587         assertJsonParserBuffer(jp, expected);\par
 1588 \par
 1589         // bool\par
 1590         mod.insertOrUpdateKeyValue(jp.getOuterObject(), "c", true);\par
 1591 \par
 1592         expected = "\{\\"a\\":999,\\"b\\":\\"x\\",\\"c\\":true\}";\par
 1593         assertJsonParserBuffer(jp, expected);\par
 1594 \par
 1595         // float\par
 1596         mod.insertOrUpdateKeyValue(jp.getOuterObject(), "d", 3.5);\par
 1597 \par
 1598         expected = "\{\\"a\\":999,\\"b\\":\\"x\\",\\"c\\":true,\\"d\\":3.500000\}";\par
 1599         assertJsonParserBuffer(jp, expected);\par
 1600 \par
 1601     \}\par
 1602 \par
 1603     // High level appendArrayValue API test\par
 1604     \{\par
 1605         JsonParserStatic<512, 32> jp;\par
 1606 \par
 1607         jp.addString("[]");\par
 1608 \par
 1609         jp.parse();\par
 1610 \par
 1611         // printTokens(jp);\par
 1612 \par
 1613         JsonModifier mod(jp);\par
 1614 \par
 1615         mod.appendArrayValue(jp.getOuterArray(), (int)1);\par
 1616 \par
 1617         // printTokens(jp);\par
 1618 \par
 1619         const char *expected = "[1]";\par
 1620         assertJsonParserBuffer(jp, expected);\par
 1621 \par
 1622 \par
 1623         mod.appendArrayValue(jp.getOuterArray(), (int)2);\par
 1624 \par
 1625         //printTokens(jp);\par
 1626 \par
 1627         expected = "[1,2]";\par
 1628         assertJsonParserBuffer(jp, expected);\par
 1629 \par
 1630         mod.appendArrayValue(jp.getOuterArray(), (float)3.5);\par
 1631 \par
 1632         //printTokens(jp);\par
 1633 \par
 1634         expected = "[1,2,3.500000]";\par
 1635         assertJsonParserBuffer(jp, expected);\par
 1636 \par
 1637         mod.appendArrayValue(jp.getOuterArray(), (bool)true);\par
 1638 \par
 1639         //printTokens(jp);\par
 1640 \par
 1641         expected = "[1,2,3.500000,true]";\par
 1642         assertJsonParserBuffer(jp, expected);\par
 1643 \par
 1644         mod.appendArrayValue(jp.getOuterArray(), "xxx");\par
 1645 \par
 1646         // printTokens(jp);\par
 1647 \par
 1648         expected = "[1,2,3.500000,true,\\"xxx\\"]";\par
 1649         assertJsonParserBuffer(jp, expected);\par
 1650 \par
 1651     \}\par
 1652 \par
 1653     // Array in object test\par
 1654     \{\par
 1655         JsonParserStatic<512, 32> jp;\par
 1656 \par
 1657         jp.addString("\{\\"t2\\":\{\\"a\\":\\"foo\\"\},\\"t3\\":[1, 2, 3]\}");\par
 1658 \par
 1659         jp.parse();\par
 1660 \par
 1661         JsonModifier mod(jp);\par
 1662 \par
 1663         const JsonParserGeneratorRK::jsmntok_t *arrayToken = 0;\par
 1664         const char *expected;\par
 1665 \par
 1666         bool bResult = jp.getValueTokenByKey(jp.getOuterObject(), "t3", arrayToken);\par
 1667         assert(bResult);\par
 1668         assert(arrayToken);\par
 1669 \par
 1670         mod.appendArrayValue(arrayToken, 4);\par
 1671 \par
 1672         expected = "\{\\"t2\\":\{\\"a\\":\\"foo\\"\},\\"t3\\":[1, 2, 3,4]\}";\par
 1673         assertJsonParserBuffer(jp, expected);\par
 1674     \}\par
 1675 \par
 1676     // Object in object test\par
 1677     \{\par
 1678         JsonParserStatic<512, 32> jp;\par
 1679 \par
 1680         jp.addString("\{\\"t2\\":\{\\"a\\":\\"foo\\"\},\\"t3\\":[1, 2, 3]\}");\par
 1681 \par
 1682         jp.parse();\par
 1683 \par
 1684         JsonModifier mod(jp);\par
 1685 \par
 1686         const JsonParserGeneratorRK::jsmntok_t *t2Token = 0;\par
 1687         const char *expected;\par
 1688 \par
 1689         bool bResult = jp.getValueTokenByKey(jp.getOuterObject(), "t2", t2Token);\par
 1690         assert(bResult);\par
 1691         assert(t2Token);\par
 1692 \par
 1693         mod.insertOrUpdateKeyValue(t2Token, "b", "xxx");\par
 1694 \par
 1695         expected = "\{\\"t2\\":\{\\"a\\":\\"foo\\",\\"b\\":\\"xxx\\"\},\\"t3\\":[1, 2, 3]\}";\par
 1696         assertJsonParserBuffer(jp, expected);\par
 1697 \par
 1698 \par
 1699         jp.getValueTokenByKey(jp.getOuterObject(), "t2", t2Token);\par
 1700         mod.insertOrUpdateKeyValue(t2Token, "b", "x");\par
 1701 \par
 1702         expected = "\{\\"t2\\":\{\\"a\\":\\"foo\\",\\"b\\":\\"x\\"\},\\"t3\\":[1, 2, 3]\}";\par
 1703         assertJsonParserBuffer(jp, expected);\par
 1704 \par
 1705         jp.getValueTokenByKey(jp.getOuterObject(), "t2", t2Token);\par
 1706         mod.insertOrUpdateKeyValue(t2Token, "a", (int)5);\par
 1707 \par
 1708         expected = "\{\\"t2\\":\{\\"b\\":\\"x\\",\\"a\\":5\},\\"t3\\":[1, 2, 3]\}";\par
 1709         assertJsonParserBuffer(jp, expected);\par
 1710     \}\par
 1711 \par
 1712     // Append an object to an array\par
 1713     \{\par
 1714         JsonParserStatic<512, 32> jp;\par
 1715 \par
 1716         jp.addString("[]");\par
 1717 \par
 1718         jp.parse();\par
 1719 \par
 1720         JsonModifier mod(jp);\par
 1721 \par
 1722         //printTokens(jp);\par
 1723 \par
 1724         mod.startAppend(jp.getOuterArray());\par
 1725 \par
 1726         mod.startObject();\par
 1727 \par
 1728         mod.insertKeyValue("a", (int)1);\par
 1729         mod.insertKeyValue("b", (bool)false);\par
 1730         mod.insertKeyValue("c", "x");\par
 1731 \par
 1732         mod.finishObjectOrArray();\par
 1733 \par
 1734         mod.finish();\par
 1735 \par
 1736         //printTokens(jp);\par
 1737 \par
 1738         const char *expected;\par
 1739         expected = "[\{\\"a\\":1,\\"b\\":false,\\"c\\":\\"x\\"\}]";\par
 1740         assertJsonParserBuffer(jp, expected);\par
 1741 \par
 1742         // Add another item to the array\par
 1743         mod.startAppend(jp.getOuterArray());\par
 1744 \par
 1745         mod.startObject();\par
 1746 \par
 1747         mod.insertKeyValue("a", (int)999);\par
 1748 \par
 1749         mod.finishObjectOrArray();\par
 1750 \par
 1751         mod.finish();\par
 1752 \par
 1753         //printTokens(jp);\par
 1754 \par
 1755         expected = "[\{\\"a\\":1,\\"b\\":false,\\"c\\":\\"x\\"\},\{\\"a\\":999\}]";\par
 1756         assertJsonParserBuffer(jp, expected);\par
 1757 \par
 1758     \}\par
 1759 \par
 1760     // Append an array to an object\par
 1761     \{\par
 1762         JsonParserStatic<512, 32> jp;\par
 1763 \par
 1764         jp.addString("\{\}");\par
 1765 \par
 1766         jp.parse();\par
 1767 \par
 1768         JsonModifier mod(jp);\par
 1769 \par
 1770         mod.startAppend(jp.getOuterObject());\par
 1771 \par
 1772         mod.insertKeyArray("a");\par
 1773 \par
 1774         mod.insertArrayValue(1);\par
 1775         mod.insertArrayValue(2);\par
 1776         mod.insertArrayValue(3);\par
 1777 \par
 1778         mod.finishObjectOrArray();\par
 1779 \par
 1780         mod.finish();\par
 1781 \par
 1782         //printTokens(jp);\par
 1783         assertJsonParserBuffer(jp, "\{\\"a\\":[1,2,3]\}");\par
 1784 \par
 1785         // Add another object to the array\par
 1786 \par
 1787         mod.startAppend(jp.getOuterObject());\par
 1788 \par
 1789         mod.insertKeyArray("b");\par
 1790 \par
 1791         mod.insertArrayValue("test");\par
 1792 \par
 1793         mod.finishObjectOrArray();\par
 1794 \par
 1795         mod.finish();\par
 1796 \par
 1797         //printTokens(jp);\par
 1798 \par
 1799         assertJsonParserBuffer(jp, "\{\\"a\\":[1,2,3],\\"b\\":[\\"test\\"]\}");\par
 1800 \par
 1801         // Add a simple value to the object\par
 1802         mod.insertOrUpdateKeyValue(jp.getOuterObject(), "c", "xxx");\par
 1803 \par
 1804         assertJsonParserBuffer(jp, "\{\\"a\\":[1,2,3],\\"b\\":[\\"test\\"],\\"c\\":\\"xxx\\"\}");\par
 1805 \par
 1806         //printTokens(jp);\par
 1807 \par
 1808         // Change an array value to a simple value\par
 1809         mod.insertOrUpdateKeyValue(jp.getOuterObject(), "b", (int)99);\par
 1810 \par
 1811         assertJsonParserBuffer(jp, "\{\\"a\\":[1,2,3],\\"c\\":\\"xxx\\",\\"b\\":99\}");\par
 1812 \par
 1813     \}\par
 1814 \par
 1815 \}\par
}
}
{\xe \v printIndent\:JsonTest.cpp}
{\xe \v JsonTest.cpp\:printIndent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void printIndent (size_t  {\i indent})}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1861 of file JsonTest.cpp.}\par
{
Referenced by printJsonInner().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1861                                 \{\par
 1862     for(size_t ii = 0; ii < 2 * indent; ii++) \{\par
 1863         printf(" ");\par
 1864     \}\par
 1865 \}\par
}
}
{\xe \v printJson\:JsonTest.cpp}
{\xe \v JsonTest.cpp\:printJson}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void printJson ({\b JsonParser} &  {\i jp})}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1963 of file JsonTest.cpp.}\par
{
References JsonParser::getOuterToken(), and printJsonInner().}\par
{
Referenced by subscriptionHandler().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1963                                \{\par
 1964     printJsonInner(jp, jp.getOuterToken(), 0);\par
 1965 \}\par
}
}
{\xe \v printJsonInner\:JsonTest.cpp}
{\xe \v JsonTest.cpp\:printJsonInner}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void printJsonInner ({\b JsonParser} &  {\i jp}, const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i container}, size_t  {\i indent})}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1889 of file JsonTest.cpp.}\par
{
References JsonParserGeneratorRK::jsmntok_t::end, JsonBuffer::getBuffer(), JsonParser::getKeyValueTokenByIndex(), JsonParser::getTokenValue(), JsonParser::getValueTokenByIndex(), JsonParserGeneratorRK::JSMN_ARRAY, JsonParserGeneratorRK::JSMN_OBJECT, JsonParserGeneratorRK::JSMN_PRIMITIVE, JsonParserGeneratorRK::JSMN_STRING, JsonParserGeneratorRK::JSMN_UNDEFINED, printIndent(), printJsonInner(), printString(), JsonParserGeneratorRK::jsmntok_t::start, and JsonParserGeneratorRK::jsmntok_t::type.}\par
{
Referenced by printJson(), and printJsonInner().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1889                                                                                                     \{\par
 1890 \par
 1891     switch(container->type) \{\par
 1892     case JsonParserGeneratorRK::JSMN_OBJECT: \{\par
 1893         printIndent(indent);\par
 1894         printf("\{\\n");\par
 1895 \par
 1896         for(size_t ii = 0; ; ii++) \{\par
 1897             const JsonParserGeneratorRK::jsmntok_t *keyToken;\par
 1898             const JsonParserGeneratorRK::jsmntok_t *valueToken;\par
 1899 \par
 1900             if (!jp.getKeyValueTokenByIndex(container, keyToken, valueToken, ii)) \{\par
 1901                 break;\par
 1902             \}\par
 1903             if (ii > 0) \{\par
 1904                 printf(",\\n");\par
 1905             \}\par
 1906 \par
 1907             String keyName;\par
 1908             jp.getTokenValue(keyToken, keyName);\par
 1909 \par
 1910             printIndent(indent + 1);\par
 1911             printString(keyName);\par
 1912             printf(":");\par
 1913             printJsonInner(jp, valueToken, indent + 1);\par
 1914         \}\par
 1915         printf("\\n");\par
 1916         printIndent(indent);\par
 1917         printf("\}\\n");\par
 1918         break;\par
 1919     \}\par
 1920     case JsonParserGeneratorRK::JSMN_ARRAY: \{\par
 1921         printIndent(indent);\par
 1922         printf("[\\n");\par
 1923 \par
 1924         for(size_t ii = 0; ; ii++) \{\par
 1925             const JsonParserGeneratorRK::jsmntok_t *valueToken;\par
 1926 \par
 1927             if (!jp.getValueTokenByIndex(container, ii, valueToken)) \{\par
 1928                 break;\par
 1929             \}\par
 1930             if (ii > 0) \{\par
 1931                 printf(",\\n");\par
 1932             \}\par
 1933             printIndent(indent + 1);\par
 1934             printJsonInner(jp, valueToken, indent + 1);\par
 1935         \}\par
 1936         printf("\\n");\par
 1937         printIndent(indent);\par
 1938         printf("]\\n");\par
 1939         break;\par
 1940     \}\par
 1941     case JsonParserGeneratorRK::JSMN_STRING: \{\par
 1942         printf("\\"");\par
 1943         for(int ii = container->start; ii < container->end; ii++) \{\par
 1944             printf("%c", jp.getBuffer()[ii]);\par
 1945         \}\par
 1946         printf("\\"");\par
 1947         break;\par
 1948     \}\par
 1949     case JsonParserGeneratorRK::JSMN_PRIMITIVE: \{\par
 1950         for(int ii = container->start; ii < container->end; ii++) \{\par
 1951             printf("%c", jp.getBuffer()[ii]);\par
 1952         \}\par
 1953         break;\par
 1954     \}\par
 1955     case JsonParserGeneratorRK::JSMN_UNDEFINED:\par
 1956     default: \{\par
 1957         break;\par
 1958     \}\par
 1959     \}\par
 1960 \par
 1961 \}\par
}
}
{\xe \v printString\:JsonTest.cpp}
{\xe \v JsonTest.cpp\:printString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void printString (const char *  {\i str})}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1867 of file JsonTest.cpp.}\par
{
Referenced by printJsonInner().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1867                                   \{\par
 1868     printf("\\"");\par
 1869 \par
 1870     for(size_t ii = 0; str[ii]; ii++) \{\par
 1871         if (str[ii] == '"') \{\par
 1872             printf("\\\\\\"");\par
 1873         \}\par
 1874         else\par
 1875         if (str[ii] == '\\\\') \{\par
 1876             printf("\\\\\\\\");\par
 1877         \}\par
 1878         else\par
 1879         if (str[ii] >= 32 && str[ii] < 127) \{\par
 1880             printf("%c", str[ii]);\par
 1881         \}\par
 1882         else \{\par
 1883             printf("\\\\x%02x", str[ii]);\par
 1884         \}\par
 1885     \}\par
 1886     printf("\\"");\par
 1887 \}\par
}
}
{\xe \v printToken\:JsonTest.cpp}
{\xe \v JsonTest.cpp\:printToken}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void printToken ({\b JsonParser} &  {\i jp}, const {\b JsonParserGeneratorRK::jsmntok_t} *  {\i tok})}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1827 of file JsonTest.cpp.}\par
{
References JsonParserGeneratorRK::jsmntok_t::end, JsonBuffer::getBuffer(), JsonParserGeneratorRK::JSMN_ARRAY, JsonParserGeneratorRK::JSMN_OBJECT, JsonParserGeneratorRK::JSMN_PRIMITIVE, JsonParserGeneratorRK::JSMN_STRING, JsonParserGeneratorRK::JSMN_UNDEFINED, JsonParserGeneratorRK::jsmntok_t::size, JsonParserGeneratorRK::jsmntok_t::start, and JsonParserGeneratorRK::jsmntok_t::type.}\par
{
Referenced by printTokens().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1827                                                                            \{\par
 1828     char tempBuf[1024];\par
 1829 \par
 1830     const char *typeName = "UNKNOWN";\par
 1831     switch(tok->type) \{\par
 1832     case JsonParserGeneratorRK::JSMN_UNDEFINED:\par
 1833         typeName = "UNDEFINED";\par
 1834         break;\par
 1835 \par
 1836     case JsonParserGeneratorRK::JSMN_OBJECT:\par
 1837         typeName = "OBJECT";\par
 1838         break;\par
 1839 \par
 1840     case JsonParserGeneratorRK::JSMN_ARRAY:\par
 1841         typeName = "ARRAY";\par
 1842         break;\par
 1843 \par
 1844     case JsonParserGeneratorRK::JSMN_STRING:\par
 1845         typeName = "STRING";\par
 1846         break;\par
 1847 \par
 1848     case JsonParserGeneratorRK::JSMN_PRIMITIVE:\par
 1849         typeName = "PRIMITIVE";\par
 1850         break;\par
 1851     \}\par
 1852 \par
 1853     memcpy(tempBuf, jp.getBuffer() + tok->start, tok->end - tok->start);\par
 1854     tempBuf[tok->end - tok->start] = 0;\par
 1855 \par
 1856     printf("type=%s start=%d end=%d size=%d %s\\n", typeName, tok->start, tok->end, tok->size, tempBuf);\par
 1857 \}\par
}
}
{\xe \v printTokens\:JsonTest.cpp}
{\xe \v JsonTest.cpp\:printTokens}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void printTokens ({\b JsonParser} &  {\i jp})}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 1818 of file JsonTest.cpp.}\par
{
References JsonParser::getTokens(), JsonParser::getTokensEnd(), and printToken().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  1818                                  \{\par
 1819     JsonParserGeneratorRK::jsmntok_t *tokensEnd = jp.getTokensEnd();\par
 1820 \par
 1821     for(JsonParserGeneratorRK::jsmntok_t *tok = jp.getTokens(); tok < tokensEnd; tok++) \{\par
 1822         printToken(jp, tok);\par
 1823     \}\par
 1824 \par
 1825 \}\par
}
}
{\xe \v readTestData\:JsonTest.cpp}
{\xe \v JsonTest.cpp\:readTestData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* readTestData (const char *  {\i filename})}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8 of file JsonTest.cpp.}\par
{
Referenced by main().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     8                                          \{\par
    9     char *data;\par
   10 \par
   11     FILE *fd = fopen(filename, "r");\par
   12     if (!fd) \{\par
   13         printf("failed to open %s", filename);\par
   14         return 0;\par
   15     \}\par
   16 \par
   17     fseek(fd, 0, SEEK_END);\par
   18     size_t size = ftell(fd);\par
   19     fseek(fd, 0, SEEK_SET);\par
   20 \par
   21     data = (char *) malloc(size + 1);\par
   22     fread(data, 1, size, fd);\par
   23     data[size] = 0;\par
   24 \par
   25     fclose(fd);\par
   26 \par
   27     return data;\par
   28 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/MFRC522/src/MFRC522.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v lib/MFRC522/src/MFRC522.cpp}
{\xe \v lib/MFRC522/src/MFRC522.cpp}
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "MFRC522.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for MFRC522.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_m_f_r_c522_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/MFRC522/src/MFRC522/MFRC522.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/MFRC522/src/MFRC522/MFRC522.h}
{\xe \v lib/MFRC522/src/MFRC522/MFRC522.h}
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../MFRC522.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for MFRC522.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_m_f_r_c522_2_m_f_r_c522_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/MFRC522/src/MFRC522.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/MFRC522/src/MFRC522.h}
{\xe \v lib/MFRC522/src/MFRC522.h}
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Particle.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for MFRC522.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_m_f_r_c522_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_m_f_r_c522_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MFRC522}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MFRC522::Uid}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b MFRC522::MIFARE_Key}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef uint16_t {\b word}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v word\:MFRC522.h}
{\xe \v MFRC522.h\:word}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef uint16_t {\b word}}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
MFRC522.h - Library to use ARDUINO RFID MODULE KIT 13.56 MHZ WITH TAGS SPI W AND R BY COOQROBOT. Based on code Dr.Leong ( WWW.B2CQSHOP.COM ) Created by Miguel Balboa (circuitito.com), Jan, 2012. Rewritten by S\'F8ren Thing Andersen (access.thing.dk), fall of 2013 (Translation to English, refactored, comments, anti collision, cascade levels.) Released into the public domain.\par
Please read this file for an overview and then {\b MFRC522.cpp} for comments on the specific functions. Search for "mf-rc522" on ebay.com to purchase the MF-RC522 board.\par
There are three hardware components involved: 1) The micro controller: An Arduino 2) The PCD (short for Proximity Coupling Device): NXP {\b MFRC522} Contactless Reader IC 3) The PICC (short for Proximity Integrated Circuit Card): A card or tag using the ISO 14443A interface, eg Mifare or NTAG203.\par
The microcontroller and card reader uses SPI for communication. The protocol is described in the {\b MFRC522} datasheet: {\f2 http://www.nxp.com/documents/data_sheet/MFRC522.pdf}\par
The card reader and the tags communicate using a 13.56MHz electromagnetic field. The protocol is defined in ISO/IEC 14443-3 Identification cards \'96 Contactless integrated circuit cards \'96 Proximity cards \'96 Part 3: Initialization and anticollision". A free version of the final draft can be found at {\f2 http://wg8.de/wg8n1496_17n3613_Ballot_FCD14443-3.pdf} Details are found in chapter 6, Type A \'96 Initialization and anticollision.\par
If only the PICC UID is wanted, the above documents has all the needed information. To read and write from MIFARE PICCs, the MIFARE protocol is used after the PICC has been selected. The MIFARE Classic chips and protocol is described in the datasheets: 1K: {\f2 http://www.nxp.com/documents/data_sheet/MF1S503x.pdf} 4K: {\f2 http://www.nxp.com/documents/data_sheet/MF1S703x.pdf} Mini: {\f2 http://www.idcardmarket.com/download/mifare_S20_datasheet.pdf} The MIFARE Ultralight chip and protocol is described in the datasheets: Ultralight: {\f2 http://www.nxp.com/documents/data_sheet/MF0ICU1.pdf} Ultralight C: {\f2 http://www.nxp.com/documents/short_data_sheet/MF0ICU2_SDS.pdf}\par
MIFARE Classic 1K (MF1S503x): Has 16 sectors * 4 blocks/sector * 16 bytes/block = 1024 bytes. The blocks are numbered 0-63. Block 3 in each sector is the Sector Trailer. See {\f2 http://www.nxp.com/documents/data_sheet/MF1S503x.pdf} sections 8.6 and 8.7: Bytes 0-5: Key A Bytes 6-8: Access Bits Bytes 9: User data Bytes 10-15: Key B (or user data) Block 0 is read only manufacturer data. To access a block, an authentication using a key from the block's sector must be performed first. Example: To read from block 10, first authenticate using a key from sector 3 (blocks 8-11). All keys are set to FFFFFFFFFFFFh at chip delivery. Warning: Please read section 8.7 "Memory Access". It includes this text: if the PICC detects a format violation the whole sector is irreversibly blocked. To use a block in "value block" mode (for Increment/Decrement operations) you need to change the sector trailer. Use PICC_SetAccessBits() to calculate the bit patterns. MIFARE Classic 4K (MF1S703x): Has (32 sectors * 4 blocks/sector + 8 sectors * 16 blocks/sector) * 16 bytes/block = 4096 bytes. The blocks are numbered 0-255. The last block in each sector is the Sector Trailer like above. MIFARE Classic Mini (MF1 IC S20): Has 5 sectors * 4 blocks/sector * 16 bytes/block = 320 bytes. The blocks are numbered 0-19. The last block in each sector is the Sector Trailer like above.\par
MIFARE Ultralight (MF0ICU1): Has 16 pages of 4 bytes = 64 bytes. Pages 0 + 1 is used for the 7-byte UID. Page 2 contains the last chech digit for the UID, one byte manufacturer internal data, and the lock bytes (see {\f2 http://www.nxp.com/documents/data_sheet/MF0ICU1.pdf} section 8.5.2) Page 3 is OTP, One Time Programmable bits. Once set to 1 they cannot revert to 0. Pages 4-15 are read/write unless blocked by the lock bytes in page 2. MIFARE Ultralight C (MF0ICU2): Has 48 pages of 4 bytes = 64 bytes. Pages 0 + 1 is used for the 7-byte UID. Page 2 contains the last chech digit for the UID, one byte manufacturer internal data, and the lock bytes (see {\f2 http://www.nxp.com/documents/data_sheet/MF0ICU1.pdf} section 8.5.2) Page 3 is OTP, One Time Programmable bits. Once set to 1 they cannot revert to 0. Pages 4-39 are read/write unless blocked by the lock bytes in page 2. Page 40 Lock bytes Page 41 16 bit one way counter Pages 42-43 Authentication configuration Pages 44-47 Authentication key \par
}{
Definition at line 83 of file MFRC522.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/MQTT/src/MQTT.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v lib/MQTT/src/MQTT.cpp}
{\xe \v lib/MQTT/src/MQTT.cpp}
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "MQTT.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for MQTT.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_m_q_t_t_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LOGGING}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTQOS0_HEADER_MASK}\~ (0 << 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTQOS1_HEADER_MASK}\~ (1 << 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTQOS2_HEADER_MASK}\~ (2 << 1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DUP_FLAG_OFF_MASK}\~ (0<<3)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DUP_FLAG_ON_MASK}\~ (1<<3)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v DUP_FLAG_OFF_MASK\:MQTT.cpp}
{\xe \v MQTT.cpp\:DUP_FLAG_OFF_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DUP_FLAG_OFF_MASK\~ (0<<3)}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file MQTT.cpp.}\par
}
{\xe \v DUP_FLAG_ON_MASK\:MQTT.cpp}
{\xe \v MQTT.cpp\:DUP_FLAG_ON_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DUP_FLAG_ON_MASK\~ (1<<3)}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 10 of file MQTT.cpp.}\par
}
{\xe \v LOGGING\:MQTT.cpp}
{\xe \v MQTT.cpp\:LOGGING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LOGGING}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 3 of file MQTT.cpp.}\par
}
{\xe \v MQTTQOS0_HEADER_MASK\:MQTT.cpp}
{\xe \v MQTT.cpp\:MQTTQOS0_HEADER_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTQOS0_HEADER_MASK\~ (0 << 1)}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 5 of file MQTT.cpp.}\par
}
{\xe \v MQTTQOS1_HEADER_MASK\:MQTT.cpp}
{\xe \v MQTT.cpp\:MQTTQOS1_HEADER_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTQOS1_HEADER_MASK\~ (1 << 1)}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 6 of file MQTT.cpp.}\par
}
{\xe \v MQTTQOS2_HEADER_MASK\:MQTT.cpp}
{\xe \v MQTT.cpp\:MQTTQOS2_HEADER_MASK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTQOS2_HEADER_MASK\~ (2 << 1)}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7 of file MQTT.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/MQTT/src/MQTT/MQTT.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/MQTT/src/MQTT/MQTT.h}
{\xe \v lib/MQTT/src/MQTT/MQTT.h}
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../MQTT.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for MQTT.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_m_q_t_t_2_m_q_t_t_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lib/MQTT/src/MQTT.h File Reference\par \pard\plain 
{\tc\tcl2 \v lib/MQTT/src/MQTT.h}
{\xe \v lib/MQTT/src/MQTT.h}
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "application.h"}\par
{\f2 #include "spark_wiring_string.h"}\par
{\f2 #include "spark_wiring_tcpclient.h"}\par
{\f2 #include "spark_wiring_usbserial.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for MQTT.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_m_q_t_t_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_m_q_t_t_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MQTT}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_MAX_PACKET_SIZE}\~ 255\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTT_DEFAULT_KEEPALIVE}\~ 15\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTPROTOCOLVERSION}\~ 3\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTCONNECT}\~ 1 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTCONNACK}\~ 2 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTPUBLISH}\~ 3 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTPUBACK}\~ 4 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTPUBREC}\~ 5 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTPUBREL}\~ 6 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTPUBCOMP}\~ 7 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTSUBSCRIBE}\~ 8 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTSUBACK}\~ 9 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTUNSUBSCRIBE}\~ 10 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTUNSUBACK}\~ 11 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTPINGREQ}\~ 12 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTPINGRESP}\~ 13 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTDISCONNECT}\~ 14 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MQTTReserved}\~ 15 << 4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b debug_print}(fmt, ...)\~ ((void)0)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v debug_print\:MQTT.h}
{\xe \v MQTT.h\:debug_print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define debug_print( fmt,   {\i ...})\~ ((void)0)}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 101 of file MQTT.h.}\par
}
{\xe \v MQTT_DEFAULT_KEEPALIVE\:MQTT.h}
{\xe \v MQTT.h\:MQTT_DEFAULT_KEEPALIVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_DEFAULT_KEEPALIVE\~ 15}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 76 of file MQTT.h.}\par
}
{\xe \v MQTT_MAX_PACKET_SIZE\:MQTT.h}
{\xe \v MQTT.h\:MQTT_MAX_PACKET_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTT_MAX_PACKET_SIZE\~ 255}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 73 of file MQTT.h.}\par
}
{\xe \v MQTTCONNACK\:MQTT.h}
{\xe \v MQTT.h\:MQTTCONNACK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTCONNACK\~ 2 << 4}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 80 of file MQTT.h.}\par
}
{\xe \v MQTTCONNECT\:MQTT.h}
{\xe \v MQTT.h\:MQTTCONNECT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTCONNECT\~ 1 << 4}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 79 of file MQTT.h.}\par
}
{\xe \v MQTTDISCONNECT\:MQTT.h}
{\xe \v MQTT.h\:MQTTDISCONNECT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTDISCONNECT\~ 14 << 4}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 92 of file MQTT.h.}\par
}
{\xe \v MQTTPINGREQ\:MQTT.h}
{\xe \v MQTT.h\:MQTTPINGREQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTPINGREQ\~ 12 << 4}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 90 of file MQTT.h.}\par
}
{\xe \v MQTTPINGRESP\:MQTT.h}
{\xe \v MQTT.h\:MQTTPINGRESP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTPINGRESP\~ 13 << 4}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 91 of file MQTT.h.}\par
}
{\xe \v MQTTPROTOCOLVERSION\:MQTT.h}
{\xe \v MQTT.h\:MQTTPROTOCOLVERSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTPROTOCOLVERSION\~ 3}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 78 of file MQTT.h.}\par
}
{\xe \v MQTTPUBACK\:MQTT.h}
{\xe \v MQTT.h\:MQTTPUBACK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTPUBACK\~ 4 << 4}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 82 of file MQTT.h.}\par
}
{\xe \v MQTTPUBCOMP\:MQTT.h}
{\xe \v MQTT.h\:MQTTPUBCOMP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTPUBCOMP\~ 7 << 4}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 85 of file MQTT.h.}\par
}
{\xe \v MQTTPUBLISH\:MQTT.h}
{\xe \v MQTT.h\:MQTTPUBLISH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTPUBLISH\~ 3 << 4}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 81 of file MQTT.h.}\par
}
{\xe \v MQTTPUBREC\:MQTT.h}
{\xe \v MQTT.h\:MQTTPUBREC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTPUBREC\~ 5 << 4}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 83 of file MQTT.h.}\par
}
{\xe \v MQTTPUBREL\:MQTT.h}
{\xe \v MQTT.h\:MQTTPUBREL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTPUBREL\~ 6 << 4}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 84 of file MQTT.h.}\par
}
{\xe \v MQTTReserved\:MQTT.h}
{\xe \v MQTT.h\:MQTTReserved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTReserved\~ 15 << 4}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 93 of file MQTT.h.}\par
}
{\xe \v MQTTSUBACK\:MQTT.h}
{\xe \v MQTT.h\:MQTTSUBACK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTSUBACK\~ 9 << 4}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 87 of file MQTT.h.}\par
}
{\xe \v MQTTSUBSCRIBE\:MQTT.h}
{\xe \v MQTT.h\:MQTTSUBSCRIBE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTSUBSCRIBE\~ 8 << 4}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 86 of file MQTT.h.}\par
}
{\xe \v MQTTUNSUBACK\:MQTT.h}
{\xe \v MQTT.h\:MQTTUNSUBACK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTUNSUBACK\~ 11 << 4}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 89 of file MQTT.h.}\par
}
{\xe \v MQTTUNSUBSCRIBE\:MQTT.h}
{\xe \v MQTT.h\:MQTTUNSUBSCRIBE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MQTTUNSUBSCRIBE\~ 10 << 4}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 88 of file MQTT.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/2020_photon_code.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/2020_photon_code.cpp}
{\xe \v src/2020_photon_code.cpp}
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Particle.h"}\par
{\f2 #include <MQTT.h>}\par
{\f2 #include <MFRC522.h>}\par
{\f2 #include "Commandparser.h"}\par
{\f2 #include <JsonParserGeneratorRK.h>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for 2020_photon_code.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "2020__photon__code_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CHARGEROFFSET}\~ 0\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
constant that sets for which Photon this program is intended }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEBUGPORT}\~ Serial\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SIZEOFUSERLIST}\~ 2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SS_PIN_CHARGER1}\~ A1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SS_PIN_CHARGER2}\~ A2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RST_PIN}\~ A0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXTRA_DIGITAL_BREAKOUT_1}\~ D0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXTRA_DIGITAL_BREAKOUT_2}\~ D1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXTRA_DIGITAL_BREAKOUT_3}\~ D3\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b WAKEUP_OLIMEX}\~ D2\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RESET_OLIMEX}\~ D4\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PILOT_FEEDBACK_CAR_1}\~ A6\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PILOT_FEEDBACK_CAR_2}\~ A7\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AUTHENTICATION_CAR1}\~ D5\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b AUTHENTICATION_CAR2}\~ D6\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b EXTRA}\~ D7\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b resetOlimex} ({\b String} input)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sends reset signal to EV charger controller. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b WifiSignal} ({\b String} input)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return wifi strength. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b resetParticle} ({\b String} input)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resets Photon. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b progModeOlmx} ({\b String} input)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets Olimex into programming mode. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b blinkRFIDled} (int charger, int action)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
unused function to blink the Photon LED }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b activeCharger} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return 1 if socket 1 is used, 2 if socket 2 is used, and 3 if both are in use. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b switchTest} ({\b String} valueString)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Switches between renewable mode (-input "true") and manual setpoint mode. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b maxCurrentC1} ({\b String} setPointStr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets max Current output at socket 1 in manual mode. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b maxCurrentC2} ({\b String} setPointStr)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets max Current output at socket 2 in manual mode. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b maxCurrentC1_test} (unsigned int setPoint)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets max Current output at socket 1/3 in renewable mode and publishes new setpoint at "HANevse/photonMaxC1" or C3. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b maxCurrentC2_test} (unsigned int setPoint)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets max Current output at socket 2/4 in renewable mode and publishes new setpoint at "HANevse/photonMaxC2" or C4. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} {\b getUserIdAtSocket} (int socket)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns RFID tag at the asked socket. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b allowUser_callback} (byte *payload, unsigned int length)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Callback function to process and execute approval or denial to charge from Pi, then {\b MQTT} publish reason to website GUI. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b initRFID} ({\b String} input)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialises RFID reader. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b readRFIDCard} (int Charger)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks and reads RFID tag at the asked socket, then {\b MQTT} publishes it for Pi. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setup} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inital setup for pin assignments and serial links start. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b loop} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Main running function that executes all other functions; runs over 5times/second. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b readSerialOlimex} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reconnect} (void)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function to reconnect to {\b MQTT} server if not connected and subscribe to needed topics. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b callback} (char *topic, byte *payload, unsigned int length)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Main function for {\b MQTT} client to check for new messages and execute callback functions. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b charToString} (const char in[], {\b String} &out)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deprecated function to convert char to {\b String} - the {\b String} class already has one. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getMeasure_callback} (byte *payload, unsigned int length)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Callback function to automatically set max Currents from {\b MQTT} message if in renewable mode. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b STARTUP} (WiFi.selectAntenna(ANT_EXTERNAL))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b add_Measurement} (float phaseVoltageL1, float phaseVoltageL2, float phaseVoltageL3, float currentL1, float currentL2, float currentL3, float {\b Frequency}, unsigned long Timestamp, int socketId=0, {\b String} userId="00")\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function ran for each socket every 30s in main loop to send measurements through {\b MQTT}. }{
}\par
}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Current} [2][3]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Power} [2][3]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b PhaseVoltage} [2][3]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b LineVoltage} [2][3]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Energy} [2]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Frequency} [2]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b CurrentList} [20]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b numberOfZeroReadings} [2]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} {\b UIDtagCharger1} ="No ID"\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
var to hold swiped RFID tag at first socket }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} {\b UIDtagCharger2} ="No ID"\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
var to hold swiped RFID tag at second socket }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MQTT} {\b client} ("broker.hivemq.com", 1883, MQTT_DEFAULT_KEEPALIVE, {\b callback}, 512)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b MQTT} client details; do not set last number to over 512! }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} {\b test} = "0"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b counter} =1\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MFRC522} {\b mfrc522_Charger1} ({\b SS_PIN_CHARGER1}, {\b RST_PIN})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MFRC522} {\b mfrc522_Charger2} ({\b SS_PIN_CHARGER2}, {\b RST_PIN})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b LatestStartTime} [2] =\{0,0\}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds latest start of new charge if charger is in use. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b handledCharger} =0\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds last handled socket (0 for first socket) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} {\b ShareVar}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b TESTCASE} = false\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
var that holds the charging mode (TRUE = renewable) }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ushort {\b Pianswer} =0\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
var that holds answer from Pi but is unused now }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b String} {\b currentStr} =""\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b nextTime} [2] = \{30000,30000\}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Next timestamp to publish measurements in ms. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v AUTHENTICATION_CAR1\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:AUTHENTICATION_CAR1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AUTHENTICATION_CAR1\~ D5}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 76 of file 2020_photon_code.cpp.}\par
}
{\xe \v AUTHENTICATION_CAR2\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:AUTHENTICATION_CAR2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define AUTHENTICATION_CAR2\~ D6}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 77 of file 2020_photon_code.cpp.}\par
}
{\xe \v CHARGEROFFSET\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:CHARGEROFFSET}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CHARGEROFFSET\~ 0}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
constant that sets for which Photon this program is intended }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For Photon 1 set it to 0, for Photon 2 set to 2. Any more and program would need to be edited. \par
}{
Definition at line 59 of file 2020_photon_code.cpp.}\par
}
{\xe \v DEBUGPORT\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:DEBUGPORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEBUGPORT\~ Serial}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 60 of file 2020_photon_code.cpp.}\par
}
{\xe \v EXTRA\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:EXTRA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXTRA\~ D7}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 78 of file 2020_photon_code.cpp.}\par
}
{\xe \v EXTRA_DIGITAL_BREAKOUT_1\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:EXTRA_DIGITAL_BREAKOUT_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXTRA_DIGITAL_BREAKOUT_1\~ D0}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 69 of file 2020_photon_code.cpp.}\par
}
{\xe \v EXTRA_DIGITAL_BREAKOUT_2\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:EXTRA_DIGITAL_BREAKOUT_2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXTRA_DIGITAL_BREAKOUT_2\~ D1}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 70 of file 2020_photon_code.cpp.}\par
}
{\xe \v EXTRA_DIGITAL_BREAKOUT_3\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:EXTRA_DIGITAL_BREAKOUT_3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define EXTRA_DIGITAL_BREAKOUT_3\~ D3}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 71 of file 2020_photon_code.cpp.}\par
}
{\xe \v PILOT_FEEDBACK_CAR_1\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:PILOT_FEEDBACK_CAR_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PILOT_FEEDBACK_CAR_1\~ A6}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 74 of file 2020_photon_code.cpp.}\par
}
{\xe \v PILOT_FEEDBACK_CAR_2\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:PILOT_FEEDBACK_CAR_2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PILOT_FEEDBACK_CAR_2\~ A7}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 75 of file 2020_photon_code.cpp.}\par
}
{\xe \v RESET_OLIMEX\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:RESET_OLIMEX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RESET_OLIMEX\~ D4}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 73 of file 2020_photon_code.cpp.}\par
}
{\xe \v RST_PIN\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:RST_PIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RST_PIN\~ A0}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 67 of file 2020_photon_code.cpp.}\par
}
{\xe \v SIZEOFUSERLIST\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:SIZEOFUSERLIST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SIZEOFUSERLIST\~ 2}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 61 of file 2020_photon_code.cpp.}\par
}
{\xe \v SS_PIN_CHARGER1\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:SS_PIN_CHARGER1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SS_PIN_CHARGER1\~ A1}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 65 of file 2020_photon_code.cpp.}\par
}
{\xe \v SS_PIN_CHARGER2\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:SS_PIN_CHARGER2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SS_PIN_CHARGER2\~ A2}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 66 of file 2020_photon_code.cpp.}\par
}
{\xe \v WAKEUP_OLIMEX\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:WAKEUP_OLIMEX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define WAKEUP_OLIMEX\~ D2}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file 2020_photon_code.cpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v activeCharger\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:activeCharger}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int activeCharger ()}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return 1 if socket 1 is used, 2 if socket 2 is used, and 3 if both are in use. }}\par
{
Definition at line 195 of file 2020_photon_code.cpp.}\par
{
References Current.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   195                     \{\par
  196     int number = 0;\par
  197     for (int i=0; i<3; i++) \{\par
  198         if (Current[0][i] != 0.0) \{\par
  199             number += 1;\par
  200             break;\par
  201         \}\par
  202     \}\par
  203     \par
  204     for (int i=0; i<3; i++) \{\par
  205         if (Current[1][i] != 0.0) \{\par
  206             number += 2;\par
  207             break;\par
  208         \}\par
  209     \}\par
  210     \par
  211     return number;\par
  212 \}\par
}
}
{\xe \v add_Measurement\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:add_Measurement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void add_Measurement (float  {\i phaseVoltageL1}, float  {\i phaseVoltageL2}, float  {\i phaseVoltageL3}, float  {\i currentL1}, float  {\i currentL2}, float  {\i currentL3}, float  {\i Frequency}, unsigned long  {\i Timestamp}, int  {\i socketId} = {\f2 0}, {\b String}  {\i userId} = {\f2 "00"})}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function ran for each socket every 30s in main loop to send measurements through {\b MQTT}. }}\par
{
Definition at line 510 of file 2020_photon_code.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   510                                                                                                                                                                                                                           \{\par
  511     \par
  512     //< Filter to skip if current values are impossibly high or under 0.1A\par
  513     //if ((currentL1 > 50.0)||(currentL2 > 50.0)||(currentL3 > 50.0)) \par
  514     //    return;\par
  515     //if ((currentL1 < 0.1)&&(currentL2 < 0.1)&&(currentL3 < 0.1) )\par
  516     //    return;\par
  517 \par
  518     //This rounds floats to 3 decimal places\par
  519     // float newvar = (float)(((int)(oldvar * 1000 + .5)) / 1000); \par
  520     \par
  521     // phaseVoltageL1 = (float)(((int)(phaseVoltageL1 * 1000 + .5)) / 1000);\par
  522     // phaseVoltageL2 = (float)(((int)(phaseVoltageL2 * 1000 + .5)) / 1000);\par
  523     // phaseVoltageL3 = (float)(((int)(phaseVoltageL3 * 1000 + .5)) / 1000);\par
  524     // currentL1 = (float)(((int)(currentL1 * 1000 + .5)) / 1000);\par
  525     // currentL2 = (float)(((int)(currentL2 * 1000 + .5)) / 1000);\par
  526     // currentL3 = (float)(((int)(currentL3 * 1000 + .5)) / 1000);\par
  527     // Frequency = (float)(((int)(Frequency * 1000 + .5)) / 1000);\par
  528 \par
  529 \par
  530     JsonWriterStatic<512> jsonMessage;     \par
  531         \{\par
  532         JsonWriterAutoObject obj(&jsonMessage);\par
  533         // Add various types of data        \par
  534         jsonMessage.insertKeyValue("V1", phaseVoltageL1);\par
  535         jsonMessage.insertKeyValue("V2", phaseVoltageL2);\par
  536         jsonMessage.insertKeyValue("V3", phaseVoltageL3);\par
  537         jsonMessage.insertKeyValue("I1", currentL1);\par
  538         jsonMessage.insertKeyValue("I2", currentL2);\par
  539         jsonMessage.insertKeyValue("I3", currentL3);\par
  540         //jsonMessage.insertKeyValue("P", Power);\par
  541         //jsonMessage.insertKeyValue("E", Energy);\par
  542         jsonMessage.insertKeyValue("F", Frequency);\par
  543           \par
  544         jsonMessage.insertKeyValue("UserID", userId);\par
  545         jsonMessage.insertKeyValue("SocketID", socketId);\par
  546         jsonMessage.insertKeyValue("Time", Timestamp);\par
  547         \}\par
  548 \par
  549 \par
  550     for(int i=0; i<3; i++) \{\par
  551         if(client.publish("HANevse/photonMeasure", jsonMessage.getBuffer())) \{\par
  552             break;\par
  553         \}\par
  554     \}\par
  555 \}\par
}
}
{\xe \v allowUser_callback\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:allowUser_callback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void allowUser_callback (byte *  {\i payload}, unsigned int  {\i length})}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Callback function to process and execute approval or denial to charge from Pi, then {\b MQTT} publish reason to website GUI. }}\par
{
Definition at line 438 of file 2020_photon_code.cpp.}\par
{
References client, String::concat(), String::operator=(), Pianswer, UIDtagCharger1, and UIDtagCharger2.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   438                                                             \{\par
  439     char payl[length+1];\par
  440     char *endchar;\par
  441         \par
  442     memcpy(payl, payload, length);\par
  443     payl[length] = NULL;\par
  444     int port = (int) strtol(payl, &endchar, 10);\par
  445     //action=1  successfully start new charge (charger is free and last stopped session > 20 sec ago)\par
  446     //action=2  charger is free, but you already swiped the card in the last 20 sec (second swipe within 20sec)\par
  447     //action=3  charger is occupied by another user\par
  448     //action=4  succesful stop of charge session\par
  449     //action=5  you just started a charge at this charger, but had another consecutive RFID swipe within 20 seconds\par
  450     //action=6  you are already charging at another charger\par
  451     //action=7  succesful RFID read, but you are not in the userlist\par
  452     int socketNr = port - 1 - CHARGEROFFSET;\par
  453     \par
  454     String topic_str = "HANevse/photonConverted/";\par
  455     topic_str.concat(port);\par
  456 \par
  457     endchar = endchar + 1;\par
  458     if (port == (1 + CHARGEROFFSET))\par
  459         port = AUTHENTICATION_CAR1;\par
  460     else if (port == (2 + CHARGEROFFSET))\par
  461         port = AUTHENTICATION_CAR2;\par
  462     else\par
  463         return; //port = EXTRA;\par
  464         \par
  465     int retPi = (int) strtol(endchar, &endchar, 10);\par
  466     Pianswer = retPi; \par
  467     // if (Pianswer == 0)\par
  468         // Pianswer = 9;\par
  469 \par
  470     switch(retPi) \{\par
  471         case 1:\par
  472             digitalWrite(port, HIGH);\par
  473             LatestStartTime[socketNr] = Time.now();\par
  474             client.publish(topic_str, "successful start new charge");\par
  475             break;\par
  476         case 2:\par
  477             client.publish(topic_str, "charger is free, but card was swiped in the last 20 sec");\par
  478             break;\par
  479         case 3:\par
  480             client.publish(topic_str, "charger is occupied by another user");\par
  481             break;\par
  482         case 4:\par
  483             digitalWrite(port, LOW);\par
  484             if (socketNr == 0)\par
  485                 UIDtagCharger1="No ID";\par
  486             else if (socketNr == 1)\par
  487                 UIDtagCharger2="No ID";\par
  488             client.publish(topic_str, "successful stop charge session");\par
  489             break;\par
  490         case 5:\par
  491             client.publish(topic_str, "consecutive RFID swipe within 20s of new charge start");\par
  492             break;\par
  493         case 6:\par
  494             client.publish(topic_str, "you are already charging at another charger");\par
  495             break;\par
  496         case 7:\par
  497             client.publish(topic_str, "you are in the userlist, but not verified by admin");\par
  498             break;\par
  499         case 8:\par
  500             client.publish(topic_str, "successful RFID read, but you are not in the userlist");\par
  501             break;\par
  502         default:\par
  503             client.publish(topic_str, "ERROR: unknown scenario");\par
  504         \par
  505     \}\par
  506     \par
  507 \}\par
}
}
{\xe \v blinkRFIDled\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:blinkRFIDled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void blinkRFIDled (int  {\i charger}, int  {\i action})}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
unused function to blink the Photon LED }}\par
{
Definition at line 179 of file 2020_photon_code.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   179                                           \{\par
  180     //action=1  succesfull start new charge (charger is free and last stoped session > 20 sec ago)\par
  181     //action=2  charger is free, but you allready swiped the card in the last 20 sec (second swipe within 20sec)\par
  182     //action=3  charger is occupied by annother user\par
  183     //action=4  succesful stop this charge session\par
  184     //action=5  you just started a charge on this charger, but have another consecutive RFID read/swipe within 20 seconds\par
  185     //action=6  you are already charging at another charger\par
  186     //action=7  succesfull RFID read, but you are not in the userlist\par
  187     \par
  188     digitalWrite(D7,HIGH);\par
  189     delay(100);\par
  190     digitalWrite(D7,LOW);\par
  191     return;\par
  192 \}\par
}
}
{\xe \v callback\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:callback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void callback (char *  {\i topic}, byte *  {\i payload}, unsigned int  {\i length})}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Main function for {\b MQTT} client to check for new messages and execute callback functions. }}\par
{
Definition at line 671 of file 2020_photon_code.cpp.}\par
{
References maxCurrentC1(), maxCurrentC2(), String::operator=(), resetOlimex(), resetParticle(), switchTest(), test, and TESTCASE.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   671                                                                \{\par
  672     test = "99";\par
  673     time_t time = Time.now();\par
  674     //DEBUGPORT.println(time);\par
  675     DEBUGPORT.print("MQTT>\\tCallback function is called at: ");\par
  676     DEBUGPORT.println(Time.format(time, TIME_FORMAT_DEFAULT));\par
  677 \par
  678     if (CHARGEROFFSET==0) \{\par
  679          if (strcmp(topic, "HANevse/allowUser")==0)\par
  680         \{\par
  681             allowUser_callback(payload, length);\par
  682             //client.publish("HANevse/photonConverted", "test photon responds");\par
  683         \}\par
  684         else\par
  685          if ( (strcmp(topic, "HANevse/energyMeter")==0) && TESTCASE )\par
  686         \{\par
  687             getMeasure_callback(payload, length);\par
  688             //client.publish("HANevse/photonTest", "test photon responds");\par
  689         \}\par
  690         else\par
  691          if (strcmp(topic, "HANevse/resetOlimex")==0)\par
  692         \{\par
  693             char payl[length+1];\par
  694             memcpy(payl, payload, length);\par
  695             payl[length] = NULL;\par
  696             resetOlimex(payl);\par
  697         \}\par
  698         else\par
  699          if (strcmp(topic, "HANevse/resetPhoton")==0)\par
  700         \{\par
  701             resetParticle("1");\par
  702         \}\par
  703         else\par
  704          if (strcmp(topic, "HANevse/switchTest1")==0)\par
  705         \{\par
  706             char payl[length+1];\par
  707             memcpy(payl, payload, length);\par
  708             payl[length] = NULL;\par
  709             switchTest(payl);\par
  710         \}\par
  711         else\par
  712          if ((strcmp(topic, "HANevse/maxC1")==0)  && !TESTCASE )\par
  713         \{\par
  714             char payl[length+1];\par
  715             memcpy(payl, payload, length);\par
  716             payl[length] = NULL;\par
  717             maxCurrentC1(payl);\par
  718             //client.publish("HANevse/photonTest", "test photon responds");\par
  719         \}\par
  720         else\par
  721          if ((strcmp(topic, "HANevse/maxC2")==0) && !TESTCASE )\par
  722         \{\par
  723             char payl[length+1];\par
  724             memcpy(payl, payload, length);\par
  725             payl[length] = NULL;\par
  726             maxCurrentC2(payl);\par
  727             //client.publish("HANevse/photonTest", "test photon responds");\par
  728         \}\par
  729     \}\par
  730     else \{\par
  731          if (strcmp(topic, "HANevse/allowUser")==0)\par
  732         \{\par
  733             allowUser_callback(payload, length);\par
  734             //client.publish("HANevse/photonConverted", "test photon responds");\par
  735         \}\par
  736         else\par
  737          if ( (strcmp(topic, "HANevse/energyMeter")==0) && TESTCASE )\par
  738         \{\par
  739             getMeasure_callback(payload, length);\par
  740             //client.publish("HANevse/photonTest", "test photon responds");\par
  741         \}\par
  742         else\par
  743          if (strcmp(topic, "HANevse/resetOlimex")==0)\par
  744         \{\par
  745             char payl[length+1];\par
  746             memcpy(payl, payload, length);\par
  747             payl[length] = NULL;\par
  748             resetOlimex(payl);\par
  749         \}\par
  750         else\par
  751          if (strcmp(topic, "HANevse/resetPhoton")==0)\par
  752         \{\par
  753             resetParticle("1");\par
  754         \}\par
  755         else\par
  756          if (strcmp(topic, "HANevse/switchTest2")==0)\par
  757         \{\par
  758             char payl[length+1];\par
  759             memcpy(payl, payload, length);\par
  760             payl[length] = NULL;\par
  761             switchTest(payl);\par
  762         \}\par
  763         else\par
  764          if ((strcmp(topic, "HANevse/maxC3")==0)  && !TESTCASE )\par
  765         \{\par
  766             char payl[length+1];\par
  767             memcpy(payl, payload, length);\par
  768             payl[length] = NULL;\par
  769             maxCurrentC1(payl);\par
  770             //client.publish("HANevse/photonTest", "test photon responds");\par
  771         \}\par
  772         else\par
  773          if ((strcmp(topic, "HANevse/maxC4")==0) && !TESTCASE )\par
  774         \{\par
  775             char payl[length+1];\par
  776             memcpy(payl, payload, length);\par
  777             payl[length] = NULL;\par
  778             maxCurrentC2(payl);\par
  779             //client.publish("HANevse/photonTest", "test photon responds");\par
  780         \}\par
  781     \}\par
  782 \}\par
}
}
{\xe \v charToString\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:charToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void charToString (const char  {\i in}[], {\b String} &  {\i out})}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deprecated function to convert char to {\b String} - the {\b String} class already has one. }}\par
{
Definition at line 140 of file 2020_photon_code.cpp.}\par
{
References String::operator=().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   140                                                 \{\par
  141     byte index = 0;\par
  142     const char *pointer = in;\par
  143     out = "";\par
  144 \par
  145     while (*pointer++) \{\par
  146       out.concat(in[index++]);\par
  147       \}\par
  148 \}\par
}
}
{\xe \v getMeasure_callback\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:getMeasure_callback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void getMeasure_callback (byte *  {\i payload}, unsigned int  {\i length})}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Callback function to automatically set max Currents from {\b MQTT} message if in renewable mode. }}\par
{
Definition at line 316 of file 2020_photon_code.cpp.}\par
{
References JsonBuffer::clear(), maxCurrentC1_test(), maxCurrentC2_test(), and JsonParser::parse().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   316                                                              \{\par
  317 \par
  318     //int sockets = 1;\par
  319     //char p[length + 1];\par
  320     //memcpy(p, payload, length);\par
  321     \par
  322     //int setPoint =  (String(p)).toInt();\par
  323     \par
  324     int setP = 0;\par
  325     \par
  326     JsonParser parser1;\par
  327     parser1.clear();\par
  328     parser1.addData( (char*)(payload), length); \par
  329     parser1.parse();\par
  330 \par
  331 //    parser1.getOuterValueByKey("I1", EMeterData.PhaseCurrent[0]);\par
  332 //    parser1.getOuterValueByKey("I2", EMeterData.PhaseCurrent[1]);\par
  333 //    parser1.getOuterValueByKey("I3", EMeterData.PhaseCurrent[2]);\par
  334 //    parser1.getOuterValueByKey("Sockets", sockets);\par
  335 \par
  336     parser1.getOuterValueByKey("setPoint", setP);\par
  337     \par
  338     unsigned int setPoint = setP;\par
  339     //client.publish("HANevse/photonMax", String(setPoint));\par
  340     // if (activeCharger() != 0)\par
  341     // \{\par
  342       maxCurrentC1_test(setPoint); //Emeter3, I1\par
  343       delay(10);\par
  344       maxCurrentC2_test(setPoint); //Emeter3, I1\par
  345     // \}\par
  346 \}\par
}
}
{\xe \v getUserIdAtSocket\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:getUserIdAtSocket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String} getUserIdAtSocket (int  {\i socket})}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns RFID tag at the asked socket. }}\par
{
Definition at line 307 of file 2020_photon_code.cpp.}\par
{
References UIDtagCharger1, and UIDtagCharger2.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   307                                      \{\par
  308     if (socket == 1+CHARGEROFFSET)\par
  309         return UIDtagCharger1;\par
  310     if (socket == 2+CHARGEROFFSET)\par
  311         return UIDtagCharger2;\par
  312     return "00";\par
  313 \}\par
}
}
{\xe \v initRFID\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:initRFID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int initRFID ({\b String}  {\i input})}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialises RFID reader. }}\par
{
Definition at line 558 of file 2020_photon_code.cpp.}\par
{
Referenced by setup().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   558                            \{\par
  559     //additional config for debugging RFID readers\par
  560     pinMode(SS_PIN_CHARGER1, OUTPUT);\par
  561     digitalWrite(SS_PIN_CHARGER1, HIGH);\par
  562     pinMode(SS_PIN_CHARGER2, OUTPUT);\par
  563     digitalWrite(SS_PIN_CHARGER2, HIGH);\par
  564   \par
  565     SPI.begin(D0);      // Initiate  SPI bus\par
  566     //Particle.process();\par
  567     delay(50);\par
  568     mfrc522_Charger1.PCD_Init();   // Initiate MFRC522\par
  569     delay(500);\par
  570     mfrc522_Charger2.PCD_Init();   // Initiate MFRC522\par
  571     //mfrc522_Charger1.PCD_SetAntennaGain(mfrc522.RxGain_max);\par
  572     mfrc522_Charger1.PCD_SetAntennaGain(mfrc522_Charger1.RxGain_max);\par
  573     mfrc522_Charger2.PCD_SetAntennaGain(mfrc522_Charger2.RxGain_max);\par
  574     \par
  575     DEBUGPORT.println("Approach your card to the reader...");\par
  576     DEBUGPORT.println();    \par
  577     return 1;\par
  578 \}\par
}
}
{\xe \v loop\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:loop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void loop ()}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Main running function that executes all other functions; runs over 5times/second. }}\par
{
Definition at line 879 of file 2020_photon_code.cpp.}\par
{
References client, handledCharger, LatestStartTime, String::operator=(), readRFIDCard(), readSerialOlimex(), reconnect(), UIDtagCharger1, and UIDtagCharger2.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   879             \{\par
  880     //Check the connection to the Particle server\par
  881     if (Particle.connected() == false) \{\par
  882         Particle.connect();\par
  883     \}\par
  884     //Check the connection to the MQTT broker and let client take care of messages in buffers\par
  885     if (client.isConnected()) \{\par
  886         client.loop();\par
  887     \}\par
  888     else reconnect();\par
  889     \par
  890     Particle.process();\par
  891     //currentStr = String(Current[0][0],1)+" "+String( Current[0][1],1)+" "+String(Current[0][2],1)+" "+String(Current[1][0],1)+" "+String( Current[1][1],1)+" "+String(Current[1][2],1)+" "+String(Frequency[0],2);\par
  892 //+    currentStr = String(Current[0][0],1)+" "+String( PhaseVoltage[0][1],1)+" "+String(LineVoltage[0][2],1)+" "+String(Power[1][0],1)+" "+String( Energy[1],1)+" "+String(Current[1][2],1)+" "+String(Frequency[0],2);\par
  893     //currentStr=String(Current[1][2],1)+" "+currentStr.substring(0, max(200, currentStr.length()))\par
  894     //currentStr = String(CurrentList[0],1)+" "+String(CurrentList[1],1)+" "+String(CurrentList[2],1)+" "+String(CurrentList[3],1)+" "+String(CurrentList[4],1)+" "+String(CurrentList[5],1)+" "+String(CurrentList[6],1)+" "+String(CurrentList[7],1)+" "+String(CurrentList[8],1)+" "+String(CurrentList[9],1)+" "+String(CurrentList[10],1)+" "+String(CurrentList[11],1)+" "+String(CurrentList[12],1)+" "+String(CurrentList[13],1)+" "+String(CurrentList[14],1)+" "+String(CurrentList[15],1)+" "+String(CurrentList[16],1)+" "+String(CurrentList[17],1)+" "+String(CurrentList[18],1)+" "+String(CurrentList[19],1);\par
  895     \par
  896     //int Charger =1; //+\par
  897     \par
  898     //Read measurements from Olimex and save for which socket\par
  899     int Charger = readSerialOlimex() + CHARGEROFFSET; //+\par
  900     Particle.process();\par
  901     // !!!! This runs multiple times a second for some reason (serial) \par
  902     // if(counter>10)\{\par
  903     //  counter = 0;\par
  904     // !!!! DEBUGPORT.println("LatestStartTime>\\t"+String(LatestStartTime[0])+", "+String(LatestStartTime[1]));\par
  905     //  DEBUGPORT.println(String(Current[1][0]+ Current[1][1]+ Current[1][2]));\par
  906     // \}\par
  907     // counter++;\par
  908 \par
  909     // store new measurement value if it is received correctly from energymeter (via the Olimex).\par
  910     if(millis()>nextTime[handledCharger] && (Charger==1+CHARGEROFFSET || Charger==2+CHARGEROFFSET)) //+ all the if\{\}\par
  911     \{\par
  912         Particle.process();\par
  913         //getUserIdAtSocket(Charger)\par
  914         int tempCharger = Charger;\par
  915         Charger = handledCharger + 1;\par
  916         //if(((activeCharger()==Charger) || (activeCharger() == 3)) && (getUserIdAtSocket(Charger)!="00"))\par
  917         //\{\par
  918             //getUserIdAtSocket(Charger+CHARGEROFFSET);\par
  919             add_Measurement(PhaseVoltage[Charger-1][0], PhaseVoltage[Charger-1][1], PhaseVoltage[Charger-1][2], Current[Charger-1][0], Current[Charger-1][1], Current[Charger-1][2], /*Power[Charger-1][0]+Power[Charger-1][1]+Power[Charger-1][2], Energy[Charger-1],*/ Frequency[Charger-1], Time.now(), Charger+CHARGEROFFSET, getUserIdAtSocket(Charger+CHARGEROFFSET));\par
  920         //\}\par
  921         Charger = tempCharger;\par
  922         nextTime[handledCharger] = millis() + 30000; //every 30 sec\par
  923     \}\par
  924     \par
  925 //     run loop very often to check new RFID cards\par
  926     Particle.process(); //+\par
  927     bool Authorized_Charger1=readRFIDCard(1+CHARGEROFFSET); //+\par
  928     delay(5);\par
  929     //if (Pianswer == 1 || Pianswer ==4 )    \par
  930     //    Authorized_Charger1 = TRUE;\par
  931     bool Authorized_Charger2=readRFIDCard(2+CHARGEROFFSET); //+\par
  932     //delay(5);\par
  933     //if (Pianswer == 1 || Pianswer ==4 )  //+    \par
  934     //      Authorized_Charger2 = TRUE;     //+\par
  935     \par
  936     \par
  937     //DEBUGPORT.println(Current[0][0]+ Current[0][1]+ Current[0][2],4);\par
  938     //DEBUGPORT.println(String(LatestStartTime[0]+60));\par
  939     //DEBUGPORT.println(String(Time.now()));\par
  940     //DEBUGPORT.println((LatestStartTime[0] + 60 < Time.now()),DEC);\par
  941     //if ((LatestStartTime[0] + 60 < Time.now()) && (Current[0][0]+ Current[0][1]+ Current[0][2]) < 1)\par
  942     //if (((numberOfZeroReadings[0]>10 && (LatestStartTime[0] + 60 < Time.now()))|| ((Time.now()<LatestStartTime[0] + 70)&&(LatestStartTime[0] + 60 < Time.now()))) && (Current[0][0]+ Current[0][1]+ Current[0][2]) < 1)\par
  943     \par
  944     // if 10+ Zero current readings have been taken or last start of new charge was over 1min ago and total Current is under 1A for first socket stop charge and reset StartTIme var\par
  945     if( ((numberOfZeroReadings[0]>10)||(LatestStartTime[0] + 70 > Time.now()) )&& (LatestStartTime[0] + 60 < Time.now()) && (Current[0][0]+ Current[0][1]+ Current[0][2]) < 1)\par
  946     \{   \par
  947         //timeout with current almost zero\par
  948         DEBUGPORT.println("Timeout charger"+String(CHARGEROFFSET+1));\par
  949         digitalWrite(AUTHENTICATION_CAR1,LOW);\par
  950         LatestStartTime[0]=2147483548;\par
  951     \}\par
  952     //DEBUGPORT.println(Current[1][0]+ Current[1][1]+ Current[1][2],4);\par
  953     //DEBUGPORT.println(String(LatestStartTime[1]+60));\par
  954     //DEBUGPORT.println(String(Time.now()));\par
  955     //DEBUGPORT.println((LatestStartTime[1] + 60 < Time.now()),DEC);\par
  956     \par
  957     // if 10+ Zero current readings have been taken or last start of new charge was over 1min ago and total Current is under 1A for second socket stop charge and reset StartTIme var\par
  958     if( ((numberOfZeroReadings[1]>10)||(LatestStartTime[1] + 70 > Time.now()) )&& (LatestStartTime[1] + 60 < Time.now()) && (Current[1][0]+ Current[1][1]+ Current[1][2]) < 1)\par
  959     \{\par
  960         //timeout with current almost zero\par
  961         DEBUGPORT.println("Timeout charger"+String(CHARGEROFFSET+2));\par
  962         digitalWrite(AUTHENTICATION_CAR2,LOW);\par
  963         //digitalWrite(D7,LOW);\par
  964         LatestStartTime[1]=2147483548;\par
  965     \}\par
  966     delay(100);\par
  967 \par
  968 \par
  969     //Reset the UIDtag if there is no car charging and last wsipe was over 1min ago at first socket\par
  970     if ((activeCharger()!=1)&&(activeCharger()!=3)&&(UIDtagCharger1!="No ID")&& (LatestStartTime[0] + 60 < Time.now()) )\{\par
  971         \par
  972         JsonWriterStatic<512> jsonMessage;\par
  973 \par
  974         \{\par
  975         JsonWriterAutoObject obj(&jsonMessage);\par
  976         \par
  977         jsonMessage.insertKeyValue("UserId", UIDtagCharger1);\par
  978         jsonMessage.insertKeyValue("Charger", (1 + CHARGEROFFSET));\par
  979         jsonMessage.insertKeyValue("StartTime", Time.now());\par
  980         \}\par
  981         client.publish("HANevse/updateUser", jsonMessage.getBuffer());\par
  982 \par
  983         UIDtagCharger1="No ID";\par
  984     \}\par
  985 \par
  986         \par
  987     if ((activeCharger()!=2)&&(activeCharger()!=3)&&(UIDtagCharger2!="No ID")&& (LatestStartTime[1] + 60 < Time.now()) )\{\par
  988         \par
  989         JsonWriterStatic<512> jsonMessage;\par
  990 \par
  991         \{\par
  992         JsonWriterAutoObject obj(&jsonMessage);\par
  993         \par
  994         jsonMessage.insertKeyValue("UserId", UIDtagCharger2);\par
  995         jsonMessage.insertKeyValue("Charger", (2 + CHARGEROFFSET));\par
  996         jsonMessage.insertKeyValue("StartTime", Time.now());\par
  997         \}\par
  998         client.publish("HANevse/updateUser", jsonMessage.getBuffer());\par
  999 \par
 1000         UIDtagCharger2="No ID";\par
 1001     \}\par
 1002             \par
 1003     handledCharger = !handledCharger;\par
 1004 \}\par
}
}
{\xe \v maxCurrentC1\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:maxCurrentC1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int maxCurrentC1 ({\b String}  {\i setPointStr})}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets max Current output at socket 1 in manual mode. }}\par
{
Definition at line 229 of file 2020_photon_code.cpp.}\par
{
References TESTCASE, and String::toInt().}\par
{
Referenced by callback(), and switchTest().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   229                                      \{\par
  230     unsigned int setPoint = setPointStr.toInt();\par
  231     if (setPoint < 7)\par
  232         setPoint = 6;\par
  233     byte olimexMessage[4] = \{0xFE,1,setPoint,0xFF\};\par
  234     if (!TESTCASE) \{\par
  235         Serial1.write(olimexMessage,4);\par
  236         DEBUGPORT.println("maxCurrentC"+String(CHARGEROFFSET+1)+">\\tNew setpoint set at "+String(setPoint)+" Amps.");\par
  237         return 0;\par
  238     \}\par
  239     return 1;\par
  240 \}\par
}
}
{\xe \v maxCurrentC1_test\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:maxCurrentC1_test}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int maxCurrentC1_test (unsigned int  {\i setPoint})}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets max Current output at socket 1/3 in renewable mode and publishes new setpoint at "HANevse/photonMaxC1" or C3. }}\par
{
Definition at line 257 of file 2020_photon_code.cpp.}\par
{
References client, String::concat(), String::String(), and TESTCASE.}\par
{
Referenced by getMeasure_callback().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   257                                              \{\par
  258     if (setPoint < 7)\par
  259         setPoint = 6;\par
  260     byte olimexMessage[4] = \{0xFE, 1, setPoint, 0xFF\};\par
  261     if (TESTCASE) \{\par
  262         Serial1.write(olimexMessage,4);\par
  263         DEBUGPORT.println("maxCurrentC"+String(CHARGEROFFSET+1)+">\\tNew setpoint set at "+String(setPoint)+" Amps.");\par
  264         String topic_str = "HANevse/photonMaxC";\par
  265         topic_str.concat(CHARGEROFFSET+1);\par
  266         client.publish(topic_str, String(setPoint)); \par
  267         return 0;\par
  268     \}\par
  269     return 1;\par
  270 \}\par
}
}
{\xe \v maxCurrentC2\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:maxCurrentC2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int maxCurrentC2 ({\b String}  {\i setPointStr})}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets max Current output at socket 2 in manual mode. }}\par
{
Definition at line 243 of file 2020_photon_code.cpp.}\par
{
References TESTCASE, and String::toInt().}\par
{
Referenced by callback(), and switchTest().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   243                                      \{\par
  244     unsigned int setPoint = setPointStr.toInt();\par
  245     if (setPoint < 7)\par
  246         setPoint = 6;\par
  247     byte olimexMessage[4] = \{0xFE, 2, setPoint, 0xFF\};\par
  248     if (!TESTCASE) \{\par
  249         Serial1.write(olimexMessage,4);\par
  250         DEBUGPORT.println("maxCurrentC"+String(CHARGEROFFSET+2)+">\\tNew setpoint set at "+String(setPoint)+" Amps.");\par
  251         return 0;\par
  252     \}\par
  253     return 1;\par
  254 \}\par
}
}
{\xe \v maxCurrentC2_test\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:maxCurrentC2_test}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int maxCurrentC2_test (unsigned int  {\i setPoint})}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets max Current output at socket 2/4 in renewable mode and publishes new setpoint at "HANevse/photonMaxC2" or C4. }}\par
{
Definition at line 273 of file 2020_photon_code.cpp.}\par
{
References client, String::concat(), String::String(), and TESTCASE.}\par
{
Referenced by getMeasure_callback().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   273                                              \{\par
  274     if (setPoint < 7)\par
  275         setPoint = 6;\par
  276     byte olimexMessage[4] = \{0xFE,2,setPoint,0xFF\};\par
  277     if (TESTCASE) \{\par
  278         Serial1.write(olimexMessage,4);\par
  279         DEBUGPORT.println("maxCurrentC"+String(CHARGEROFFSET+2)+">\\tNew setpoint set at "+String(setPoint)+" Amps.");\par
  280         String topic_str = "HANevse/photonMaxC";\par
  281         topic_str.concat(CHARGEROFFSET+2);\par
  282         client.publish(topic_str, String(setPoint)); \par
  283         return 0;\par
  284     \}\par
  285     return 1;\par
  286 \}\par
}
}
{\xe \v progModeOlmx\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:progModeOlmx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int progModeOlmx ({\b String}  {\i input})}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets Olimex into programming mode. }}\par
{
Definition at line 169 of file 2020_photon_code.cpp.}\par
{
References resetOlimex().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   169                                \{\par
  170     digitalWrite(WAKEUP_OLIMEX, HIGH);\par
  171     delay(500);\par
  172     resetOlimex("");\par
  173     delay(500);\par
  174     digitalWrite(WAKEUP_OLIMEX, LOW);\par
  175     return 1;\par
  176 \}\par
}
}
{\xe \v readRFIDCard\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:readRFIDCard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool readRFIDCard (int  {\i Charger})}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks and reads RFID tag at the asked socket, then {\b MQTT} publishes it for Pi. }}\par
{
Definition at line 581 of file 2020_photon_code.cpp.}\par
{
References Pianswer, String::substring(), UIDtagCharger1, and UIDtagCharger2.}\par
{
Referenced by loop().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   581                                \{\par
  582    // DEBUGPORT.print("readCard>\\t");\par
  583     bool Authorized = true;\par
  584     Pianswer = 0;\par
  585     if(Charger==1+CHARGEROFFSET)\par
  586     \{\par
  587       // Look for new cards\par
  588         if ( ! mfrc522_Charger1.PICC_IsNewCardPresent()) \par
  589         \{\par
  590             return false;\par
  591         \}\par
  592         // Select one of the cards\par
  593         if ( ! mfrc522_Charger1.PICC_ReadCardSerial()) \par
  594         \{\par
  595             return false;\par
  596         \}\par
  597   \par
  598         //Show UID on serial monitor\par
  599         DEBUGPORT.print("readCard>\\tUID tag on charger1:");\par
  600         String content = "";        \par
  601         //byte letter;\par
  602         for (byte i = 0; i < mfrc522_Charger1.uid.size; i++) \par
  603         \{\par
  604             DEBUGPORT.print(mfrc522_Charger1.uid.uidByte[i] < 0x10 ? " 0" : " ");\par
  605             DEBUGPORT.print(mfrc522_Charger1.uid.uidByte[i], HEX);\par
  606             content.concat(String(mfrc522_Charger1.uid.uidByte[i] < 0x10 ? " 0" : " "));\par
  607             content.concat(String(mfrc522_Charger1.uid.uidByte[i], HEX));\par
  608         \}\par
  609         JsonWriterStatic<512> jsonMessage;\par
  610 \par
  611         //Authorized=testUser(content,Charger);\par
  612         UIDtagCharger1=content.substring(1); //??? why does it start at 1?\par
  613 \par
  614         \{\par
  615         JsonWriterAutoObject obj(&jsonMessage);\par
  616 \par
  617         jsonMessage.insertKeyValue("UserId", UIDtagCharger1);\par
  618         jsonMessage.insertKeyValue("Charger", Charger);\par
  619         jsonMessage.insertKeyValue("StartTime", Time.now());\par
  620         \}\par
  621         client.publish("HANevse/updateUser", jsonMessage.getBuffer());\par
  622     \}\par
  623     if(Charger==2+CHARGEROFFSET)\par
  624     \{\par
  625     \par
  626         // Look for new cards\par
  627         if ( ! mfrc522_Charger2.PICC_IsNewCardPresent()) \par
  628         \{\par
  629             return false;\par
  630         \}\par
  631         // Select one of the cards\par
  632         if ( ! mfrc522_Charger2.PICC_ReadCardSerial()) \par
  633         \{\par
  634             return false;\par
  635         \}\par
  636         //DEBUGPORT.println("Read something on charger2");\par
  637         //Show UID on serial monitor\par
  638         DEBUGPORT.print("readCard>\\tUID tag on charger2:");\par
  639         String content = "";        \par
  640         //byte letter;\par
  641         for (byte i = 0; i < mfrc522_Charger2.uid.size; i++) \par
  642         \{\par
  643             DEBUGPORT.print(mfrc522_Charger2.uid.uidByte[i] < 0x10 ? " 0" : " ");\par
  644             DEBUGPORT.print(mfrc522_Charger2.uid.uidByte[i], HEX);\par
  645             content.concat(String(mfrc522_Charger2.uid.uidByte[i] < 0x10 ? " 0" : " "));\par
  646             content.concat(String(mfrc522_Charger2.uid.uidByte[i], HEX));\par
  647         \}\par
  648         //Authorized=testUser(content,Charger);\par
  649         UIDtagCharger2=content.substring(1);\par
  650         JsonWriterStatic<512> jsonMessage;\par
  651 \par
  652         \{\par
  653         JsonWriterAutoObject obj(&jsonMessage);\par
  654         \par
  655         jsonMessage.insertKeyValue("UserId", UIDtagCharger2);\par
  656         jsonMessage.insertKeyValue("Charger", Charger);\par
  657         jsonMessage.insertKeyValue("StartTime", Time.now());\par
  658         \}\par
  659         client.publish("HANevse/updateUser", jsonMessage.getBuffer());\par
  660         \par
  661     \}\par
  662     DEBUGPORT.println("");\par
  663        \par
  664     delay(500);\par
  665     // This whole function is not interrupted by callback() so Pianswer can't be changed in the meantime\par
  666     //client.publish("HANevse/checkupdateUser", String(Pianswer));  \par
  667      return Authorized;\par
  668 \}\par
}
}
{\xe \v readSerialOlimex\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:readSerialOlimex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int readSerialOlimex ()}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function to read from Olimex serial port and run {\b stringParse()} Returns the last charger socket it received data from. \par
}{
Definition at line 271 of file Commandparser.h.}\par
{
References buff, bufpos, and stringParse().}\par
{
Referenced by loop().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   271                        \{\par
  272     int Charger;\par
  273      char input;\par
  274   //if (millis()>(lastUpload+RSTTIMEOUT))\{\par
  275    // softReset();\par
  276   //\}\par
  277   for(int k=0;k<10;k++)\{\par
  278   if (Serial1.available()) \{\par
  279     input = Serial1.read();\par
  280     //DEBUGPORT.print(input,HEX);\par
  281     //DEBUGPORT.print(" ");\par
  282     if (bufpos<BUFSIZE)\par
  283     \{\par
  284         buff[bufpos] = input;\par
  285         bufpos++;    \par
  286     \}\par
  287     else\par
  288     \{\par
  289         bufpos=0;\par
  290         DEBUGPORT.print("loopread>\\tSerial Read Error!");\par
  291     \}\par
  292     if (input == '\\n') \{ // we hebben een regel binnen, tot aan \\n   //  0x0A\par
  293       Charger = stringParse(buff, bufpos);\par
  294       //Maak de buffer leeg\par
  295       for (int i=0; i<BUFSIZE; i++)\par
  296       \{ buff[i] = 0;\}\par
  297       bufpos = 0;\par
  298     \}\par
  299   \}\par
  300 \}\par
  301 return Charger;\par
  302 \}\par
}
}
{\xe \v reconnect\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:reconnect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void reconnect (void )}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function to reconnect to {\b MQTT} server if not connected and subscribe to needed topics. }}\par
{
Definition at line 785 of file 2020_photon_code.cpp.}\par
{
References client.}\par
{
Referenced by loop().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   785                      \{\par
  786     while (!client.isConnected()) \{\par
  787         DEBUGPORT.print("MQTT>\\tConnecting to MQTT broker...");\par
  788         if (CHARGEROFFSET==0) \{\par
  789             if (client.connect("EV-Photon1")) \{\par
  790                 DEBUGPORT.println("MQTT>\\tConnected");\par
  791                 //client.subscribe("HANevse/#", client.QOS2);\par
  792                 client.subscribe("HANevse/energyMeter"); //+\par
  793                 client.subscribe("HANevse/allowUser");\par
  794                 \par
  795                 client.subscribe("HANevse/resetOlimex");\par
  796                 client.subscribe("HANevse/resetPhoton");\par
  797                 client.subscribe("HANevse/switchTest1");\par
  798                 client.subscribe("HANevse/maxC1");\par
  799                 client.subscribe("HANevse/maxC2");\par
  800             \}\par
  801             else \{\par
  802                 DEBUGPORT.println("MQTT>\\tConnection failed");\par
  803                 DEBUGPORT.println("MQTT>\\tRetrying...");\par
  804                 delay(10000);\par
  805             \}\par
  806         \}\par
  807         else if (CHARGEROFFSET==2)\{\par
  808             if (client.connect("EV-Photon2")) \{\par
  809                 DEBUGPORT.println("MQTT>\\tConnected");\par
  810                 //client.subscribe("HANevse/#", client.QOS2);\par
  811                 client.subscribe("HANevse/energyMeter"); //+\par
  812                 client.subscribe("HANevse/allowUser");\par
  813                 \par
  814                 client.subscribe("HANevse/resetOlimex");\par
  815                 client.subscribe("HANevse/resetPhoton");\par
  816                  client.subscribe("HANevse/maxC3");\par
  817                  client.subscribe("HANevse/maxC4");\par
  818                  client.subscribe("HANevse/switchTest2");\par
  819             \}\par
  820             else \{\par
  821                 DEBUGPORT.println("MQTT>\\tConnection failed");\par
  822                 DEBUGPORT.println("MQTT>\\tRetrying...");\par
  823                 delay(10000);\par
  824             \}\par
  825         \}\par
  826     \}\par
  827 \}\par
}
}
{\xe \v resetOlimex\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:resetOlimex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int resetOlimex ({\b String}  {\i input})}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sends reset signal to EV charger controller. }}\par
{
Definition at line 151 of file 2020_photon_code.cpp.}\par
{
Referenced by callback(), and progModeOlmx().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   151                               \{\par
  152     digitalWrite(RESET_OLIMEX, LOW);\par
  153     delay(500);\par
  154     digitalWrite(RESET_OLIMEX, HIGH);\par
  155     return 1;\par
  156 \}\par
}
}
{\xe \v resetParticle\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:resetParticle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int resetParticle ({\b String}  {\i input})}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Resets Photon. }}\par
{
Definition at line 164 of file 2020_photon_code.cpp.}\par
{
Referenced by callback().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   164                                 \{\par
  165     System.reset();\par
  166 \}\par
}
}
{\xe \v setup\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:setup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void setup ()}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inital setup for pin assignments and serial links start. }}\par
{
Definition at line 830 of file 2020_photon_code.cpp.}\par
{
References initRFID().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   830              \{\par
  831     DEBUGPORT.begin(115200); \par
  832     Serial1.begin(9600);\par
  833     //DEBUGPORT.println(Voltage,5);\par
  834     //DEBUGPORT.println(String(Voltage,5));\par
  835     \par
  836     waitUntil(Particle.connected);\par
  837     \par
  838     pinMode(AUTHENTICATION_CAR1, OUTPUT); //pinMode(D1, OUTPUT); //Charger1_Authorized\par
  839     pinMode(AUTHENTICATION_CAR2, OUTPUT); //pinMode(D2, OUTPUT); //Charger2_Authorized\par
  840     pinMode(PILOT_FEEDBACK_CAR_1,INPUT);\par
  841     pinMode(PILOT_FEEDBACK_CAR_2,INPUT);\par
  842     pinMode(WAKEUP_OLIMEX, OUTPUT);\par
  843     pinMode(RESET_OLIMEX, OUTPUT);\par
  844     pinMode(D7, OUTPUT);\par
  845     \par
  846     digitalWrite(AUTHENTICATION_CAR1, LOW); //digitalWrite(D1,LOW);\par
  847     digitalWrite(AUTHENTICATION_CAR2, LOW);//digitalWrite(D2,LOW);\par
  848     digitalWrite(WAKEUP_OLIMEX, LOW);\par
  849     digitalWrite(RESET_OLIMEX, HIGH);\par
  850     digitalWrite(D7, LOW);\par
  851     \par
  852     initRFID(""); //+\par
  853     \par
  854     //Particle.process();  \par
  855     //resetOlimex("");  \par
  856     //Particle.process(); \par
  857 \par
  858     Particle.function("switchTest",switchTest);\par
  859     Particle.function("maxCurrentC1",maxCurrentC1);\par
  860     Particle.function("maxCurrentC2",maxCurrentC2);\par
  861     Particle.function("resetOlimex",resetOlimex);\par
  862     Particle.function("progModeOlmx",progModeOlmx);\par
  863     Particle.function("resetParticl",resetParticle);\par
  864     //Particle.function("AuthPinsHigh",AuthPinsHigh);\par
  865     //Particle.function("AuthPinsLow",AuthPinsLow);\par
  866     Particle.function("WifiSignal",WifiSignal);\par
  867     Particle.function("initRFID",initRFID);\par
  868     Particle.variable("currentStr",currentStr);\par
  869     Particle.variable("ShareVar",ShareVar);\par
  870     //Particle.variable("Current", Current_Str);\par
  871     Particle.variable("Topic", test);\par
  872     Particle.process();\par
  873     \par
  874     //RGB.control(true);\par
  875     Time.zone(1); //Dutch time zone\par
  876 \}\par
}
}
{\xe \v STARTUP\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:STARTUP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
STARTUP (WiFi.  {\i selectAntenna}ANT_EXTERNAL)}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v switchTest\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:switchTest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int switchTest ({\b String}  {\i valueString})}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Switches between renewable mode (-input "true") and manual setpoint mode. }}\par
{
Definition at line 215 of file 2020_photon_code.cpp.}\par
{
References maxCurrentC1(), maxCurrentC2(), String::operator==(), and TESTCASE.}\par
{
Referenced by callback().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   215                                    \{\par
  216     if (valueString == "true") \{\par
  217         TESTCASE = true;\par
  218         return 1;\par
  219     \}\par
  220     if (valueString == "false") \{\par
  221         TESTCASE = false;\par
  222         maxCurrentC1("32");\par
  223         maxCurrentC2("32");\par
  224         return 0;\par
  225     \}\par
  226 \}\par
}
}
{\xe \v WifiSignal\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:WifiSignal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int WifiSignal ({\b String}  {\i input})}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return wifi strength. }}\par
{
Definition at line 159 of file 2020_photon_code.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   159                              \{\par
  160     return WiFi.RSSI();\par
  161 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v client\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:client}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MQTT} client("broker.hivemq.com", 1883, MQTT_DEFAULT_KEEPALIVE, {\b callback}, 512)}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b MQTT} client details; do not set last number to over 512! }}\par
{
Referenced by allowUser_callback(), loop(), maxCurrentC1_test(), maxCurrentC2_test(), and reconnect().}\par
}
{\xe \v counter\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:counter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int counter =1}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 96 of file 2020_photon_code.cpp.}\par
}
{\xe \v Current\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:Current}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Current[2][3]}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 30 of file Commandparser.h.}\par
{
Referenced by activeCharger(), and stringParse().}\par
}
{\xe \v CurrentList\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:CurrentList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float CurrentList[20]}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 36 of file Commandparser.h.}\par
{
Referenced by stringParse().}\par
}
{\xe \v currentStr\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:currentStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String} currentStr =""}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 135 of file 2020_photon_code.cpp.}\par
}
{\xe \v Energy\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:Energy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Energy[2]}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file Commandparser.h.}\par
{
Referenced by stringParse().}\par
}
{\xe \v Frequency\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:Frequency}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Frequency[2]}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file Commandparser.h.}\par
{
Referenced by stringParse().}\par
}
{\xe \v handledCharger\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:handledCharger}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool handledCharger =0}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds last handled socket (0 for first socket) }}\par
{
Definition at line 102 of file 2020_photon_code.cpp.}\par
{
Referenced by loop().}\par
}
{\xe \v LatestStartTime\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:LatestStartTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long LatestStartTime[2] =\{0,0\}}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Holds latest start of new charge if charger is in use. }}\par
{
Definition at line 100 of file 2020_photon_code.cpp.}\par
{
Referenced by loop().}\par
}
{\xe \v LineVoltage\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:LineVoltage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float LineVoltage[2][3]}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file Commandparser.h.}\par
{
Referenced by stringParse().}\par
}
{\xe \v mfrc522_Charger1\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:mfrc522_Charger1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MFRC522} mfrc522_Charger1({\b SS_PIN_CHARGER1}, {\b RST_PIN})}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mfrc522_Charger2\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:mfrc522_Charger2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MFRC522} mfrc522_Charger2({\b SS_PIN_CHARGER2}, {\b RST_PIN})}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v nextTime\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:nextTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int nextTime[2] = \{30000,30000\}}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Next timestamp to publish measurements in ms. }}\par
{
Definition at line 137 of file 2020_photon_code.cpp.}\par
}
{\xe \v numberOfZeroReadings\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:numberOfZeroReadings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int numberOfZeroReadings[2]}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file Commandparser.h.}\par
{
Referenced by stringParse().}\par
}
{\xe \v PhaseVoltage\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:PhaseVoltage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float PhaseVoltage[2][3]}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file Commandparser.h.}\par
{
Referenced by stringParse().}\par
}
{\xe \v Pianswer\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:Pianswer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ushort Pianswer =0}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
var that holds answer from Pi but is unused now }}\par
{
Definition at line 110 of file 2020_photon_code.cpp.}\par
{
Referenced by allowUser_callback(), and readRFIDCard().}\par
}
{\xe \v Power\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:Power}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Power[2][3]}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file Commandparser.h.}\par
{
Referenced by stringParse().}\par
}
{\xe \v ShareVar\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:ShareVar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String} ShareVar}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 103 of file 2020_photon_code.cpp.}\par
}
{\xe \v test\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:test}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String} test = "0"}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 93 of file 2020_photon_code.cpp.}\par
{
Referenced by callback().}\par
}
{\xe \v TESTCASE\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:TESTCASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool TESTCASE = false}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
var that holds the charging mode (TRUE = renewable) }}\par
{
Definition at line 107 of file 2020_photon_code.cpp.}\par
{
Referenced by callback(), maxCurrentC1(), maxCurrentC1_test(), maxCurrentC2(), maxCurrentC2_test(), and switchTest().}\par
}
{\xe \v UIDtagCharger1\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:UIDtagCharger1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String} UIDtagCharger1 ="No ID"}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
var to hold swiped RFID tag at first socket }}\par
{
Definition at line 51 of file 2020_photon_code.cpp.}\par
{
Referenced by allowUser_callback(), getUserIdAtSocket(), loop(), and readRFIDCard().}\par
}
{\xe \v UIDtagCharger2\:2020_photon_code.cpp}
{\xe \v 2020_photon_code.cpp\:UIDtagCharger2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b String} UIDtagCharger2 ="No ID"}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
var to hold swiped RFID tag at second socket }}\par
{
Definition at line 53 of file 2020_photon_code.cpp.}\par
{
Referenced by allowUser_callback(), getUserIdAtSocket(), loop(), and readRFIDCard().}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/Commandparser.h File Reference\par \pard\plain 
{\tc\tcl2 \v src/Commandparser.h}
{\xe \v src/Commandparser.h}
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Particle.h"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for Commandparser.h:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_commandparser_8h__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "_commandparser_8h__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BUFSIZE}\~ 350\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b RSTTIMEOUT}\~ 300000\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b DEBUGPORT}\~ Serial\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Send} ({\b String} {\b test})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b bytesToFloat} (unsigned char b0, unsigned char b1, unsigned char b2, unsigned char b3)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b bytesArrToFloatArr} (char *Arr, unsigned int ArrLen, float *OutputArr, unsigned int FloatLen)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b stringParse} (char *buf, int buflen)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b readSerialOlimex} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b readnextLine} = false\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b buff} [{\b BUFSIZE}]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b bufpos} = 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned long {\b lastUpload} = 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Current} [2][3] =\{\{0,0,0\},\{0,0,0\}\}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Power} [2][3] =\{\{0,0,0\},\{0,0,0\}\}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b PhaseVoltage} [2][3] =\{\{0,0,0\},\{0,0,0\}\}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b LineVoltage} [2][3] =\{\{0,0,0\},\{0,0,0\}\}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Energy} [2] =\{0,0\}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b Frequency} [2] =\{0,0\}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b CurrentList} [20]\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b numberOfZeroReadings} [2] =\{0,0\}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v BUFSIZE\:Commandparser.h}
{\xe \v Commandparser.h\:BUFSIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BUFSIZE\~ 350}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 7 of file Commandparser.h.}\par
}
{\xe \v DEBUGPORT\:Commandparser.h}
{\xe \v Commandparser.h\:DEBUGPORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define DEBUGPORT\~ Serial}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 9 of file Commandparser.h.}\par
}
{\xe \v RSTTIMEOUT\:Commandparser.h}
{\xe \v Commandparser.h\:RSTTIMEOUT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define RSTTIMEOUT\~ 300000}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 8 of file Commandparser.h.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v bytesArrToFloatArr\:Commandparser.h}
{\xe \v Commandparser.h\:bytesArrToFloatArr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool bytesArrToFloatArr (char *  {\i Arr}, unsigned int  {\i ArrLen}, float *  {\i OutputArr}, unsigned int  {\i FloatLen})}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function to convert an array of Olimex 4-byte values to float variables \par
}{
Definition at line 65 of file Commandparser.h.}\par
{
Referenced by stringParse().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    66 \{\par
   67     //FloatTriplet TriOutput;\par
   68     for(int i=0; (i<FloatLen) && (4*i+3 < ArrLen); i++)\par
   69     \{\par
   70         float output;\par
   71 \par
   72         *((unsigned char *)(&output) + 3) = (unsigned char) Arr[4*i+0];\par
   73         *((unsigned char *)(&output) + 2) = Arr[4*i+1];\par
   74         *((unsigned char *)(&output) + 1) = Arr[4*i+2];\par
   75         *((unsigned char *)(&output) + 0) = Arr[4*i+3];\par
   76         \par
   77         OutputArr[i] = output;\par
   78     \}\par
   79 \par
   80     return true;\par
   81 \}\par
}
}
{\xe \v bytesToFloat\:Commandparser.h}
{\xe \v Commandparser.h\:bytesToFloat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float bytesToFloat (unsigned char  {\i b0}, unsigned char  {\i b1}, unsigned char  {\i b2}, unsigned char  {\i b3})}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function to convert Olimex 4-byte value to float variable \par
}{
Definition at line 50 of file Commandparser.h.}\par
{
Referenced by stringParse().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    51 \{\par
   52     float output;\par
   53 \par
   54     *((unsigned char *)(&output) + 3) = b0;\par
   55     *((unsigned char *)(&output) + 2) = b1;\par
   56     *((unsigned char *)(&output) + 1) = b2;\par
   57     *((unsigned char *)(&output) + 0) = b3;\par
   58 \par
   59     return output;\par
   60 \}\par
}
}
{\xe \v readSerialOlimex\:Commandparser.h}
{\xe \v Commandparser.h\:readSerialOlimex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int readSerialOlimex ()}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function to read from Olimex serial port and run {\b stringParse()} Returns the last charger socket it received data from. \par
}{
Definition at line 271 of file Commandparser.h.}\par
{
References buff, bufpos, and stringParse().}\par
{
Referenced by loop().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   271                        \{\par
  272     int Charger;\par
  273      char input;\par
  274   //if (millis()>(lastUpload+RSTTIMEOUT))\{\par
  275    // softReset();\par
  276   //\}\par
  277   for(int k=0;k<10;k++)\{\par
  278   if (Serial1.available()) \{\par
  279     input = Serial1.read();\par
  280     //DEBUGPORT.print(input,HEX);\par
  281     //DEBUGPORT.print(" ");\par
  282     if (bufpos<BUFSIZE)\par
  283     \{\par
  284         buff[bufpos] = input;\par
  285         bufpos++;    \par
  286     \}\par
  287     else\par
  288     \{\par
  289         bufpos=0;\par
  290         DEBUGPORT.print("loopread>\\tSerial Read Error!");\par
  291     \}\par
  292     if (input == '\\n') \{ // we hebben een regel binnen, tot aan \\n   //  0x0A\par
  293       Charger = stringParse(buff, bufpos);\par
  294       //Maak de buffer leeg\par
  295       for (int i=0; i<BUFSIZE; i++)\par
  296       \{ buff[i] = 0;\}\par
  297       bufpos = 0;\par
  298     \}\par
  299   \}\par
  300 \}\par
  301 return Charger;\par
  302 \}\par
}
}
{\xe \v Send\:Commandparser.h}
{\xe \v Commandparser.h\:Send}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Send ({\b String}  {\i test})}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v stringParse\:Commandparser.h}
{\xe \v Commandparser.h\:stringParse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int stringParse (char *  {\i buf}, int  {\i buflen})}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function to parse Olimex message into energy measurements Returns the charger socket it received data from. \par
}{
Definition at line 107 of file Commandparser.h.}\par
{
References bytesArrToFloatArr(), bytesToFloat(), Current, CurrentList, Energy, Frequency, LineVoltage, numberOfZeroReadings, PhaseVoltage, and Power.}\par
{
Referenced by readSerialOlimex().}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   107                                        \{\par
  108   String cmdValue;\par
  109   int Charger=0;\par
  110   for (int i=0; i<buflen; i++)\{\par
  111     if(buf[i]==0x0F && i+2>=buflen) //error check?\par
  112     \{\par
  113       DEBUGPORT.println("E");\par
  114     \}\par
  115     if((buf[i]==0x0F || buf[i]==0x0E) && i+2<buflen) //we detect a command-character and the next two characters exists\par
  116     \{\par
  117       if (buf[i]==0x0F)\par
  118       \{\par
  119         Charger=1;  \par
  120       \}\par
  121       else\par
  122       \{\par
  123         Charger=2;\par
  124       \}\par
  125       DEBUGPORT.print("Charger "+String(Charger)+": ");\par
  126       String measurements;\par
  127       switch (buf[i+1])\par
  128       \{\par
  129         case 1:\par
  130           //Phase Voltage\par
  131           if(buflen>4)\par
  132           \{\par
  133               //Voltage[Charger-1] = bytesToFloat(buf[i+2], buf[i+3], buf[i+4], buf[i+5]);\par
  134               float VoltageArr[3];\par
  135               if(bytesArrToFloatArr(&buf[i+2], 12, VoltageArr,3))\par
  136               \{\par
  137                 //Current[Charger-1] = (CurrentArr[0]+CurrentArr[1]+CurrentArr[2])/3;  \par
  138                 for(int i=0;i<3;i++)\par
  139                 \{\par
  140                     PhaseVoltage[Charger-1][i]=VoltageArr[i];\par
  141                 \}\par
  142                 //Voltage[Charger-1] = \{VoltageArr[0],VoltageArr[1],VoltageArr[2]\};\par
  143               \}\par
  144               DEBUGPORT.print("Voltage: "+String(PhaseVoltage[Charger-1][0],4)+" "+String(PhaseVoltage[Charger-1][1],4)+" "+String(PhaseVoltage[Charger-1][2],4));\par
  145           \}\par
  146           else\par
  147           \{\par
  148               DEBUGPORT.print("did not receive enough voltage data");\par
  149           \}\par
  150           break;\par
  151         case 2:\par
  152           //Current\par
  153           if(buflen>12) //(buflen>4)\par
  154           \{\par
  155               //Current[Charger-1] = bytesToFloat(buf[i+2], buf[i+3], buf[i+4], buf[i+5]);\par
  156               float CurrentArr[3];\par
  157               if(bytesArrToFloatArr(&buf[i+2], 12, Current[Charger-1],3))\par
  158               \{\par
  159                 //Current[Charger-1] = (CurrentArr[0]+CurrentArr[1]+CurrentArr[2])/3;  \par
  160                 //Current[Charger-1] = \{CurrentArr[0],CurrentArr[1],CurrentArr[2]\}\par
  161               \}\par
  162               DEBUGPORT.print("Current: ");\par
  163               DEBUGPORT.print(Current[Charger-1][0],4);DEBUGPORT.print(" ");\par
  164               DEBUGPORT.print(Current[Charger-1][1],4);DEBUGPORT.print(" ");\par
  165               DEBUGPORT.println(Current[Charger-1][2],4);\par
  166               if((Current[Charger-1][0]+Current[Charger-1][1]+Current[Charger-1][2])<1)\par
  167               \{\par
  168                 numberOfZeroReadings[Charger-1]++;\par
  169               \}\par
  170               else\par
  171               \{\par
  172                   numberOfZeroReadings[Charger-1]=0;\par
  173               \}\par
  174               for(int i=18;i>=0;i--)\par
  175               \{\par
  176                    CurrentList[i+1]= CurrentList[i];\par
  177               \}\par
  178               CurrentList[0]=(Current[0][0]+Current[0][1]+Current[0][2]);//numberOfZeroReadings[0];\par
  179               CurrentList[1]=numberOfZeroReadings[0];\par
  180               CurrentList[2]=Current[0][2];\par
  181           \}\par
  182           else\par
  183           \{\par
  184               DEBUGPORT.print("did not receive enough current data");\par
  185           \}\par
  186           break;  \par
  187         case 3:\par
  188           //Frequency\par
  189           if(buflen>4)\par
  190           \{\par
  191               Frequency[0] = bytesToFloat(buf[i+2], buf[i+3], buf[i+4], buf[i+5]);\par
  192               Frequency[1]=Frequency[0];\par
  193               DEBUGPORT.print("Frequency: ");\par
  194               DEBUGPORT.print(Frequency[Charger-1],4);\par
  195           \}\par
  196           else\par
  197           \{\par
  198               DEBUGPORT.print("did not receive enough frequency data");\par
  199           \}\par
  200           break;\par
  201         case 4:\par
  202           //Power\par
  203           if(buflen>4)\par
  204           \{\par
  205               //Power[Charger-1] = bytesToFloat(buf[i+2], buf[i+3], buf[i+4], buf[i+5]);\par
  206               float PowerArr[3];\par
  207               if(bytesArrToFloatArr(&buf[i+2], 12, Power[Charger-1],3))\par
  208               \{\par
  209                 //Power[Charger-1] = \{PowerArr[0],PowerArr[1],PowerArr[2]\}\par
  210               \}\par
  211               DEBUGPORT.print("Power: "+String(Power[Charger-1][0],4)+" "+String(Power[Charger-1][1],4)+" "+String(Power[Charger-1][2],4));              \par
  212               //DEBUGPORT.print("Power: ");\par
  213               //DEBUGPORT.print(Power[Charger-1],4);\par
  214           \}\par
  215           else\par
  216           \{\par
  217               DEBUGPORT.print("did not receive enough power data");\par
  218           \}\par
  219           break;\par
  220         case 5:\par
  221           //Energy\par
  222           if(buflen>4)\par
  223           \{\par
  224               Energy[Charger-1] = bytesToFloat(buf[i+2], buf[i+3], buf[i+4], buf[i+5]);\par
  225               DEBUGPORT.print("Energy: ");\par
  226               DEBUGPORT.print(Energy[Charger-1],4);\par
  227           \}\par
  228           else\par
  229           \{\par
  230               DEBUGPORT.print("did not receive enough energy data");\par
  231           \}\par
  232           break;\par
  233         case 6:\par
  234           //Line Voltage\par
  235           if(buflen>4)\par
  236           \{\par
  237               //Voltage[Charger-1] = bytesToFloat(buf[i+2], buf[i+3], buf[i+4], buf[i+5]);\par
  238               float VoltageArr[3];\par
  239               if(bytesArrToFloatArr(&buf[i+2], 12, VoltageArr,3))\par
  240               \{\par
  241                 //Current[Charger-1] = (CurrentArr[0]+CurrentArr[1]+CurrentArr[2])/3;  \par
  242                 for(int i=0;i<3;i++)\par
  243                 \{\par
  244                     LineVoltage[Charger-1][i]=VoltageArr[i];\par
  245                 \}\par
  246                 //Voltage[Charger-1] = \{VoltageArr[0],VoltageArr[1],VoltageArr[2]\};\par
  247               \}\par
  248               DEBUGPORT.print("Voltage: "+String(LineVoltage[Charger-1][0],4)+" "+String(LineVoltage[Charger-1][1],4)+" "+String(LineVoltage[Charger-1][2],4));\par
  249           \}\par
  250           else\par
  251           \{\par
  252               DEBUGPORT.print("did not receive enough voltage data");\par
  253           \}\par
  254           break;     \par
  255           break;\par
  256         default:\par
  257           break;\par
  258       \}\par
  259     \}\par
  260   \}\par
  261   //Test only\par
  262   //Current[0][0] = 3.0;\par
  263   //Current[1][0] = 4.0;\par
  264   return Charger;\par
  265 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v buff\:Commandparser.h}
{\xe \v Commandparser.h\:buff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char buff[{\b BUFSIZE}]}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 14 of file Commandparser.h.}\par
{
Referenced by readSerialOlimex().}\par
}
{\xe \v bufpos\:Commandparser.h}
{\xe \v Commandparser.h\:bufpos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int bufpos = 0}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file Commandparser.h.}\par
{
Referenced by readSerialOlimex().}\par
}
{\xe \v Current\:Commandparser.h}
{\xe \v Commandparser.h\:Current}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Current[2][3] =\{\{0,0,0\},\{0,0,0\}\}}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 30 of file Commandparser.h.}\par
{
Referenced by activeCharger(), and stringParse().}\par
}
{\xe \v CurrentList\:Commandparser.h}
{\xe \v Commandparser.h\:CurrentList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float CurrentList[20]}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 36 of file Commandparser.h.}\par
{
Referenced by stringParse().}\par
}
{\xe \v Energy\:Commandparser.h}
{\xe \v Commandparser.h\:Energy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Energy[2] =\{0,0\}}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 34 of file Commandparser.h.}\par
{
Referenced by stringParse().}\par
}
{\xe \v Frequency\:Commandparser.h}
{\xe \v Commandparser.h\:Frequency}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Frequency[2] =\{0,0\}}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 35 of file Commandparser.h.}\par
{
Referenced by stringParse().}\par
}
{\xe \v lastUpload\:Commandparser.h}
{\xe \v Commandparser.h\:lastUpload}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned long lastUpload = 0}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file Commandparser.h.}\par
}
{\xe \v LineVoltage\:Commandparser.h}
{\xe \v Commandparser.h\:LineVoltage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float LineVoltage[2][3] =\{\{0,0,0\},\{0,0,0\}\}}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 33 of file Commandparser.h.}\par
{
Referenced by stringParse().}\par
}
{\xe \v numberOfZeroReadings\:Commandparser.h}
{\xe \v Commandparser.h\:numberOfZeroReadings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int numberOfZeroReadings[2] =\{0,0\}}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 37 of file Commandparser.h.}\par
{
Referenced by stringParse().}\par
}
{\xe \v PhaseVoltage\:Commandparser.h}
{\xe \v Commandparser.h\:PhaseVoltage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float PhaseVoltage[2][3] =\{\{0,0,0\},\{0,0,0\}\}}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file Commandparser.h.}\par
{
Referenced by stringParse().}\par
}
{\xe \v Power\:Commandparser.h}
{\xe \v Commandparser.h\:Power}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float Power[2][3] =\{\{0,0,0\},\{0,0,0\}\}}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file Commandparser.h.}\par
{
Referenced by stringParse().}\par
}
{\xe \v readnextLine\:Commandparser.h}
{\xe \v Commandparser.h\:readnextLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool readnextLine = false}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 13 of file Commandparser.h.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
target/2.0.1/photon/obj/src/module_info.o.d File Reference\par \pard\plain 
{\tc\tcl2 \v target/2.0.1/photon/obj/src/module_info.o.d}
{\xe \v target/2.0.1/photon/obj/src/module_info.o.d}
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
target/2.0.1/photon/obj/src/newlib_stubs.o.d File Reference\par \pard\plain 
{\tc\tcl2 \v target/2.0.1/photon/obj/src/newlib_stubs.o.d}
{\xe \v target/2.0.1/photon/obj/src/newlib_stubs.o.d}
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
target/2.0.1/photon/obj/src/user_export.o.d File Reference\par \pard\plain 
{\tc\tcl2 \v target/2.0.1/photon/obj/src/user_export.o.d}
{\xe \v target/2.0.1/photon/obj/src/user_export.o.d}
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
target/2.0.1/photon/obj/src/user_module.o.d File Reference\par \pard\plain 
{\tc\tcl2 \v target/2.0.1/photon/obj/src/user_module.o.d}
{\xe \v target/2.0.1/photon/obj/src/user_module.o.d}
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}